/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(1);
__webpack_require__(82);
__webpack_require__(84);
__webpack_require__(86);
__webpack_require__(87);
__webpack_require__(89);
module.exports = __webpack_require__(91);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(2);
var api_1 = __webpack_require__(24);
var base_1 = __webpack_require__(27);
var factory_1 = __webpack_require__(28);
var frontend_1 = __webpack_require__(30);
var frontend_2 = __webpack_require__(77);
var base_2 = __webpack_require__(61);
var frontend_3 = __webpack_require__(60);
var status_1 = __webpack_require__(4);
var completion_1 = __webpack_require__(29);
var geom_1 = __webpack_require__(9);
var json_1 = __webpack_require__(8);
var VolumeChunkSource = frontend_3.defineParameterizedVolumeChunkSource(base_1.VolumeSourceParameters);
var MeshSource = frontend_1.defineParameterizedMeshSource(base_1.MeshSourceParameters);
var BaseSkeletonSource = frontend_2.parameterizedSkeletonSource(base_1.SkeletonSourceParameters);
var SERVER_DATA_TYPES = new Map();
SERVER_DATA_TYPES.set('UINT8', base_2.DataType.UINT8);
SERVER_DATA_TYPES.set('FLOAT', base_2.DataType.FLOAT32);
SERVER_DATA_TYPES.set('UINT64', base_2.DataType.UINT64);

var VolumeInfo = function VolumeInfo(obj) {
    _classCallCheck(this, VolumeInfo);

    try {
        json_1.verifyObject(obj);
        this.numChannels = json_1.verifyPositiveInt(obj['channelCount']);
        this.dataType = json_1.verifyMapKey(obj['channelType'], SERVER_DATA_TYPES);
        this.voxelSize = json_1.parseXYZ(geom_1.vec3.create(), obj['pixelSize'], json_1.verifyFinitePositiveFloat);
        this.upperVoxelBound = json_1.parseXYZ(geom_1.vec3.create(), obj['volumeSize'], json_1.verifyPositiveInt);
    } catch (parseError) {
        throw new Error(`Failed to parse BrainMaps volume geometry: ${ parseError.message }`);
    }
};

exports.VolumeInfo = VolumeInfo;
;

var MeshInfo = function MeshInfo(obj) {
    _classCallCheck(this, MeshInfo);

    json_1.verifyObject(obj);
    this.name = json_1.verifyObjectProperty(obj, 'name', json_1.verifyString);
    this.type = json_1.verifyObjectProperty(obj, 'type', json_1.verifyString);
};

exports.MeshInfo = MeshInfo;
;

var MultiscaleVolumeChunkSource = function () {
    function MultiscaleVolumeChunkSource(instance, volume_id, volumeInfoResponse, meshesResponse) {
        _classCallCheck(this, MultiscaleVolumeChunkSource);

        this.instance = instance;
        this.volume_id = volume_id;
        try {
            json_1.verifyObject(volumeInfoResponse);
            var scales = this.scales = json_1.verifyObjectProperty(volumeInfoResponse, 'geometry', y => json_1.parseArray(y, x => new VolumeInfo(x)));
            if (scales.length === 0) {
                throw new Error('Expected at least one scale.');
            }
            var baseScale = scales[0];
            var numChannels = this.numChannels = baseScale.numChannels;
            var dataType = this.dataType = baseScale.dataType;
            for (var scaleIndex = 1, numScales = scales.length; scaleIndex < numScales; ++scaleIndex) {
                var scale = scales[scaleIndex];
                if (scale.dataType !== dataType) {
                    throw new Error(`Scale ${ scaleIndex } has data type ${ base_2.DataType[scale.dataType] } but scale 0 has data type ${ base_2.DataType[dataType] }.`);
                }
                if (scale.numChannels !== numChannels) {
                    throw new Error(`Scale ${ scaleIndex } has ${ scale.numChannels } channel(s) but scale 0 has ${ numChannels } channels.`);
                }
            }
            // Infer the VolumeType from the data type and number of channels.
            var volumeType = base_2.VolumeType.IMAGE;
            if (numChannels === 1) {
                switch (dataType) {
                    case base_2.DataType.UINT64:
                        volumeType = base_2.VolumeType.SEGMENTATION;
                        break;
                }
            }
            this.volumeType = volumeType;
        } catch (parseError) {
            throw new Error(`Failed to parse BrainMaps multiscale volume specification: ${ parseError.message }`);
        }
        try {
            json_1.verifyObject(meshesResponse);
            this.meshes = json_1.verifyObjectProperty(meshesResponse, 'meshes', y => {
                if (y === undefined) {
                    return [];
                }
                return json_1.parseArray(y, x => new MeshInfo(x));
            });
        } catch (parseError) {
            throw new Error(`Failed to parse BrainMaps meshes specification: ${ parseError.message }`);
        }
    }

    _createClass(MultiscaleVolumeChunkSource, [{
        key: 'getSources',
        value: function getSources(chunkManager) {
            var encoding = base_1.VolumeChunkEncoding.RAW;
            if (this.volumeType === base_2.VolumeType.SEGMENTATION) {
                encoding = base_1.VolumeChunkEncoding.COMPRESSED_SEGMENTATION;
            } else if (this.volumeType === base_2.VolumeType.IMAGE && this.dataType === base_2.DataType.UINT8 && this.numChannels === 1) {
                encoding = base_1.VolumeChunkEncoding.JPEG;
            }
            return this.scales.map((volumeInfo, scaleIndex) => base_2.VolumeChunkSpecification.getDefaults({
                voxelSize: volumeInfo.voxelSize,
                dataType: volumeInfo.dataType,
                numChannels: volumeInfo.numChannels,
                upperVoxelBound: volumeInfo.upperVoxelBound,
                volumeType: this.volumeType
            }).map(spec => {
                return VolumeChunkSource.get(chunkManager, spec, {
                    'instance': this.instance,
                    'volume_id': this.volume_id,
                    'scaleIndex': scaleIndex,
                    'encoding': encoding
                });
            }));
        }
    }, {
        key: 'getMeshSource',
        value: function getMeshSource(chunkManager) {
            var validMesh = this.meshes.find(x => x.type === 'TRIANGLES');
            if (validMesh === undefined) {
                return null;
            }
            return _getMeshSource(chunkManager, { 'instance': this.instance, 'volume_id': this.volume_id, 'mesh_name': validMesh.name });
        }
    }]);

    return MultiscaleVolumeChunkSource;
}();

exports.MultiscaleVolumeChunkSource = MultiscaleVolumeChunkSource;
;
function _getMeshSource(chunkManager, parameters) {
    return MeshSource.get(chunkManager, parameters);
}
exports.getMeshSource = _getMeshSource;

var SkeletonSource = function (_BaseSkeletonSource) {
    _inherits(SkeletonSource, _BaseSkeletonSource);

    function SkeletonSource() {
        _classCallCheck(this, SkeletonSource);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SkeletonSource).apply(this, arguments));
    }

    _createClass(SkeletonSource, [{
        key: 'skeletonVertexCoordinatesInVoxels',
        get: function () {
            return false;
        }
    }]);

    return SkeletonSource;
}(BaseSkeletonSource);

exports.SkeletonSource = SkeletonSource;
;
function getSkeletonSource(chunkManager, parameters) {
    return SkeletonSource.get(chunkManager, parameters);
}
exports.getSkeletonSource = getSkeletonSource;
var meshSourcePattern = /^([^\/]+)\/(.*)$/;
function getMeshSourceParameters(instance, url) {
    var match = url.match(meshSourcePattern);
    if (match === null) {
        throw new Error(`Invalid Brainmaps mesh URL: ${ url }`);
    }
    return { instance, volume_id: match[1], mesh_name: match[2] };
}
function getMeshSourceByUrl(instance, chunkManager, url) {
    return _getMeshSource(chunkManager, getMeshSourceParameters(instance, url));
}
exports.getMeshSourceByUrl = getMeshSourceByUrl;
function getSkeletonSourceByUrl(instance, chunkManager, url) {
    return getSkeletonSource(chunkManager, getMeshSourceParameters(instance, url));
}
exports.getSkeletonSourceByUrl = getSkeletonSourceByUrl;
var existingVolumes = new Map();
function getVolume(instance, key) {
    var cacheKey = json_1.stableStringify({ 'instance': instance, 'key': key });
    var existingResult = existingVolumes.get(cacheKey);
    if (existingResult !== undefined) {
        return existingResult;
    }
    var promise = Promise.all([api_1.makeRequest(instance, 'GET', `/v1beta2/volumes/${ key }`, 'json'), api_1.makeRequest(instance, 'GET', `/v1beta2/objects/${ key }/meshes`, 'json')]).then(_ref => {
        var _ref2 = _slicedToArray(_ref, 2);

        var volumeInfoResponse = _ref2[0];
        var meshesResponse = _ref2[1];
        return new MultiscaleVolumeChunkSource(instance, key, volumeInfoResponse, meshesResponse);
    });
    existingVolumes.set(cacheKey, promise);
    return promise;
}
exports.getVolume = getVolume;

var VolumeList = function VolumeList(response) {
    _classCallCheck(this, VolumeList);

    this.hierarchicalVolumeIds = new Map();
    try {
        json_1.verifyObject(response);
        var volumeIds = this.volumeIds = json_1.parseArray(response['volumeId'], json_1.verifyString);
        volumeIds.sort();
        var hierarchicalSets = new Map();
        for (var volumeId of volumeIds) {
            var componentStart = 0;
            while (true) {
                var nextColon = volumeId.indexOf(':', componentStart);
                if (nextColon === -1) {
                    nextColon = undefined;
                } else {
                    ++nextColon;
                }
                var groupString = volumeId.substring(0, componentStart);
                var group = hierarchicalSets.get(groupString);
                if (group === undefined) {
                    group = new Set();
                    hierarchicalSets.set(groupString, group);
                }
                group.add(volumeId.substring(componentStart, nextColon));
                if (nextColon === undefined) {
                    break;
                }
                componentStart = nextColon;
            }
        }
        var hierarchicalVolumeIds = this.hierarchicalVolumeIds;

        for (var _ref5 of hierarchicalSets) {
            var _ref4 = _slicedToArray(_ref5, 2);

            var _group = _ref4[0];
            var valueSet = _ref4[1];

            hierarchicalVolumeIds.set(_group, Array.from(valueSet));
        }
    } catch (parseError) {
        throw new Error(`Failed to parse Brain Maps volume list reply: ${ parseError.message }`);
    }
};

exports.VolumeList = VolumeList;
;
var volumeListCache = new Map();
function getVolumeList(instance) {
    var promise = volumeListCache.get(instance);
    if (promise === undefined) {
        promise = api_1.makeRequest(instance, 'GET', '/v1beta2/volumes/', 'json').then(response => new VolumeList(response));
        var description = `Google ${ api_1.INSTANCE_NAMES[instance] } volume list`;
        status_1.StatusMessage.forPromise(promise, {
            delay: true,
            initialMessage: `Retrieving ${ description }.`,
            errorPrefix: `Error retrieving ${ description }: `
        });
        volumeListCache.set(instance, promise);
    }
    return promise;
}
exports.getVolumeList = getVolumeList;
function volumeCompleter(instance, url) {
    return getVolumeList(instance).then(volumeList => {
        var lastColon = url.lastIndexOf(':');
        var splitPoint = lastColon + 1;
        var prefix = url.substring(0, splitPoint);
        var matchString = url.substring(splitPoint);
        var possibleMatches = volumeList.hierarchicalVolumeIds.get(prefix);
        if (possibleMatches === undefined) {
            return null;
        }
        return { offset: prefix.length, completions: completion_1.getPrefixMatches(matchString, possibleMatches) };
    });
}
exports.volumeCompleter = volumeCompleter;
function registerBrainmapsDataSource(instance) {
    var protocol = 'brainmaps';
    if (instance !== api_1.PRODUCTION_INSTANCE) {
        protocol += `-${ api_1.INSTANCE_IDENTIFIERS[instance].toLowerCase() }`;
    }
    factory_1.registerDataSourceFactory(protocol, {
        description: `Google ${ api_1.INSTANCE_NAMES[instance] } API`,
        getVolume: getVolume.bind(undefined, instance),
        getMeshSource: getMeshSourceByUrl.bind(undefined, instance),
        getSkeletonSource: getSkeletonSourceByUrl.bind(undefined, instance),
        volumeCompleter: volumeCompleter.bind(undefined, instance)
    });
}
exports.registerBrainmapsDataSource = registerBrainmapsDataSource;
registerBrainmapsDataSource(api_1.PRODUCTION_INSTANCE);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * @file
 * This implements the authentication API based on neuroglancer/util/google_auth2.
 */

var api_implementation_1 = __webpack_require__(3);
var status_1 = __webpack_require__(4);
var google_oauth2_1 = __webpack_require__(6);
var promise_1 = __webpack_require__(20);
var worker_rpc_1 = __webpack_require__(22);
var BRAINMAPS_SCOPE = 'https://www.googleapis.com/auth/brainmaps';
var nextGenerationId = 0;
api_implementation_1.implementation.getNewTokenPromise = function () {
    var status = new status_1.StatusMessage( /*delay=*/true);
    var authPromise = void 0;
    var tokenPromise = new Promise(function (resolve) {
        function writeLoginStatus() {
            var msg = arguments.length <= 0 || arguments[0] === undefined ? 'Brain Maps authorization required.' : arguments[0];
            var linkMessage = arguments.length <= 1 || arguments[1] === undefined ? 'Request authorization.' : arguments[1];

            status.setText(msg + '  ');
            var button = document.createElement('button');
            button.textContent = linkMessage;
            status.element.appendChild(button);
            button.addEventListener('click', () => {
                login( /*immediate=*/false);
            });
            status.setVisible(true);
        }
        function login(immediate) {
            if (authPromise !== undefined) {
                promise_1.cancelPromise(authPromise);
            }
            writeLoginStatus('Waiting for Brain Maps authorization...', 'Retry');
            authPromise = google_oauth2_1.authenticateGoogleOAuth2({
                clientId: ("639403125587-4k5hgdfumtrvur8v48e3pr7oo91d765k.apps.googleusercontent.com"),
                scopes: [BRAINMAPS_SCOPE],
                immediate: immediate,
                authUser: 0
            });
            authPromise.then(token => {
                token['generationId'] = nextGenerationId++;
                resolve(token);
            }, reason => {
                if (immediate) {
                    writeLoginStatus();
                } else {
                    writeLoginStatus(`Brain Maps authorization failed: ${ reason }.`, 'Retry');
                }
            });
            promise_1.callFinally(authPromise, () => {
                authPromise = undefined;
            });
        }
        login( /*immediate=*/true);
    });
    promise_1.callFinally(tokenPromise, () => {
        status.dispose();
    });
    return tokenPromise;
};
worker_rpc_1.registerRPC('brainmaps.requestToken', function (x) {
    var rpc = this;
    api_implementation_1.getToken(x['invalidToken']).then(function (authResult) {
        rpc.invoke('brainmaps.receiveToken', { 'authResult': authResult });
    });
});

/***/ },
/* 3 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Implementation = function Implementation() {
    _classCallCheck(this, Implementation);
};

exports.Implementation = Implementation;
exports.implementation = new Implementation();
var promise = null;
var token = null;
function getToken(invalidToken) {
    if (promise !== null && (token === null || invalidToken == null || invalidToken['generationId'] !== token['generationId'])) {
        // Either we already have a valid token, or we are already obtaining one.
        return promise;
    }
    token = null;
    promise = exports.implementation.getNewTokenPromise(invalidToken);
    promise.then(t => {
        token = t;
    });
    return promise;
}
exports.getToken = getToken;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(5);
var statusContainer = null;
exports.DEFAULT_STATUS_DELAY = 200;

var StatusMessage = function () {
    function StatusMessage() {
        var delay = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        _classCallCheck(this, StatusMessage);

        if (statusContainer === null) {
            statusContainer = document.createElement('ul');
            statusContainer.id = 'statusContainer';
            document.body.appendChild(statusContainer);
        }
        var element = document.createElement('li');
        this.element = element;
        if (delay === true) {
            delay = exports.DEFAULT_STATUS_DELAY;
        }
        if (delay !== false) {
            this.setVisible(false);
            this.timer = setTimeout(this.setVisible.bind(this, true), delay);
        } else {
            this.timer = null;
        }
        statusContainer.appendChild(element);
    }

    _createClass(StatusMessage, [{
        key: 'dispose',
        value: function dispose() {
            statusContainer.removeChild(this.element);
            this.element = undefined;
            if (this.timer !== null) {
                clearTimeout(this.timer);
            }
        }
    }, {
        key: 'setText',
        value: function setText(text, makeVisible) {
            this.element.textContent = text;
            if (makeVisible) {
                this.setVisible(true);
            }
        }
    }, {
        key: 'setHTML',
        value: function setHTML(text, makeVisible) {
            this.element.innerHTML = text;
            if (makeVisible) {
                this.setVisible(true);
            }
        }
    }, {
        key: 'setVisible',
        value: function setVisible(value) {
            this.timer = null;
            this.element.style.display = value ? 'block' : 'none';
        }
    }], [{
        key: 'forPromise',
        value: function forPromise(promise, options) {
            var status = new StatusMessage(options.delay);
            status.setText(options.initialMessage);
            var dispose = status.dispose.bind(status);
            promise.then(dispose, reason => {
                var msg = void 0;
                if (reason instanceof Error) {
                    msg = reason.message;
                } else {
                    msg = '' + reason;
                }
                var _options$errorPrefix = options.errorPrefix;
                var errorPrefix = _options$errorPrefix === undefined ? '' : _options$errorPrefix;

                status.element.textContent = errorPrefix + msg + '  ';
                var button = document.createElement('button');
                button.textContent = 'Dismiss';
                button.addEventListener('click', () => {
                    status.dispose();
                });
                status.element.appendChild(button);
                status.setVisible(true);
            });
            return promise;
        }
    }]);

    return StatusMessage;
}();

exports.StatusMessage = StatusMessage;
;

/***/ },
/* 5 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var dom_1 = __webpack_require__(7);
var json_1 = __webpack_require__(8);
var promise_1 = __webpack_require__(20);
var random_1 = __webpack_require__(21);
exports.AUTH_SERVER = 'https://accounts.google.com/o/oauth2/auth';
var AUTH_ORIGIN = 'https://accounts.google.com';
function embedRelayFrame(proxyName, rpcToken) {
    var iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    iframe.id = proxyName;
    iframe.name = proxyName;
    var origin = location.origin;
    iframe.src = `https://accounts.google.com/o/oauth2/postmessageRelay?parent=${ encodeURIComponent(origin) }#rpctoken=${ rpcToken }`;
    document.body.appendChild(iframe);
}
exports.embedRelayFrame = embedRelayFrame;

var AuthHandler = function () {
    function AuthHandler() {
        _classCallCheck(this, AuthHandler);

        this.proxyName = `postmessageRelay${ random_1.getRandomHexString() }`;
        this.rpcToken = `${ random_1.getRandomHexString() }`;
        this.relayReadyService = `oauth2relayReady:${ this.rpcToken }`;
        this.oauth2CallbackService = `oauth2callback:${ this.rpcToken }`;
        this.pendingRequests = new Map();
        embedRelayFrame(this.proxyName, this.rpcToken);
        this.relayReadyPromise = new Promise(relayReadyPromiseResolve => {
            addEventListener('message', event => {
                if (event.origin !== AUTH_ORIGIN) {
                    return;
                }
                try {
                    var data = json_1.verifyObject(JSON.parse(event.data));
                    var service = json_1.verifyString(data['s']);
                    if (service === this.relayReadyService) {
                        relayReadyPromiseResolve();
                    }
                    if (service === this.oauth2CallbackService) {
                        var args = json_1.parseArray(data['a'], x => x);
                        var arg = json_1.verifyString(args[0]);
                        var origin = location.origin;
                        if (!arg.startsWith(origin + '#') && !arg.startsWith(origin + '?')) {
                            throw new Error(`oauth2callback: URL ${ JSON.stringify(arg) } does not match current origin ${ origin }.`);
                        }
                        var hashPart = arg.substring(origin.length + 1);
                        var parts = hashPart.split('&');
                        var params = new Map();
                        for (var part of parts) {
                            var match = part.match('^([a-z_]+)=(.*)$');
                            if (match === null) {
                                throw new Error(`oauth2callback: URL part ${ JSON.stringify(match) } does not match expected pattern.`);
                            }
                            params.set(match[1], match[2]);
                        }
                        var state = params.get('state');
                        if (state === undefined) {
                            throw new Error(`oauth2callback: State argument is missing.`);
                        }
                        var callbacks = this.pendingRequests.get(state);
                        if (callbacks === undefined) {
                            // Request may have been cancelled.
                            return;
                        }
                        var error = params.get('error');
                        if (error !== undefined) {
                            this.pendingRequests.delete(state);
                            var errorSubtype = params.get('error_subtype');
                            var fullMessage = error;
                            if (errorSubtype !== undefined) {
                                fullMessage += ': ' + errorSubtype;
                            }
                            callbacks.reject(fullMessage);
                            return;
                        }
                        var accessToken = params.get('access_token');
                        var tokenType = params.get('token_type');
                        var expiresIn = params.get('expires_in');
                        var scope = params.get('scope');
                        if (accessToken === undefined || tokenType === undefined || expiresIn === undefined || scope === undefined) {
                            throw new Error(`oauth2callback: URL lacks expected parameters.`);
                        }
                        this.pendingRequests.delete(state);
                        callbacks.resolve({
                            accessToken: accessToken,
                            tokenType: tokenType,
                            expiresIn: expiresIn,
                            scope: scope
                        });
                        return;
                    }
                } catch (parseError) {
                    throw new Error(`Invalid message received from ${ AUTH_ORIGIN }: ${ JSON.stringify(event.data) }: ${ parseError.message }.`);
                }
            });
        });
    }

    _createClass(AuthHandler, [{
        key: 'getAuthPromise',
        value: function getAuthPromise(state) {
            var promise = promise_1.makeCancellablePromise((resolve, reject) => {
                this.pendingRequests.set(state, { resolve, reject });
            });
            promise_1.callFinally(promise, () => {
                this.pendingRequests.delete(state);
            });
            return promise;
        }
    }, {
        key: 'makeAuthRequestUrl',
        value: function makeAuthRequestUrl(options) {
            var url = `${ exports.AUTH_SERVER }?client_id=${ encodeURIComponent(options.clientId) }`;
            url += `&redirect_uri=postmessage`;
            url += `&response_type=token`;
            var _options$origin = options.origin;
            var origin = _options$origin === undefined ? location.origin : _options$origin;

            url += `&origin=${ encodeURIComponent(origin) }`;
            url += `&proxy=${ this.proxyName }`;
            url += `&include_granted_scopes=true`;
            url += `&scope=${ encodeURIComponent(options.scopes.join(' ')) }`;
            if (options.state) {
                url += `&state=${ options.state }`;
            }
            if (options.approvalPrompt) {
                url += `&approval_prompt=${ encodeURIComponent(options.approvalPrompt) }`;
            }
            if (options.loginHint) {
                url += `&login_hint=${ encodeURIComponent(options.loginHint) }`;
            }
            if (options.immediate) {
                url += `&immediate=true`;
            }
            if (options.authUser !== undefined) {
                url += `&authuser=${ options.authUser }`;
            }
            return url;
        }
    }]);

    return AuthHandler;
}();

;
var authHandlerInstance = void 0;
function authHandler() {
    if (authHandlerInstance === undefined) {
        authHandlerInstance = new AuthHandler();
    }
    return authHandlerInstance;
}
function authenticateGoogleOAuth2(options) {
    var state = random_1.getRandomHexString();
    var handler = authHandler();
    var url = handler.makeAuthRequestUrl({
        state,
        clientId: options.clientId,
        scopes: options.scopes,
        approvalPrompt: options.approvalPrompt,
        loginHint: options.loginHint,
        immediate: options.immediate,
        authUser: options.authUser
    });
    var promise = handler.getAuthPromise(state);
    if (options.immediate) {
        // For immediate mode auth, we can wait until the relay is ready, since we
        // aren't opening a new
        // window.
        handler.relayReadyPromise.then(() => {
            var iframe = document.createElement('iframe');
            iframe.src = url;
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            promise_1.callFinally(promise, () => {
                dom_1.removeFromParent(iframe);
            });
        });
    } else {
        (function () {
            var newWindow = open(url);
            promise_1.callFinally(promise, () => {
                newWindow.close();
            });
        })();
    }
    return promise;
}
exports.authenticateGoogleOAuth2 = authenticateGoogleOAuth2;

/***/ },
/* 7 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function removeChildren(element) {
    while (true) {
        var child = element.firstElementChild;
        if (!child) {
            break;
        }
        element.removeChild(child);
    }
}
exports.removeChildren = removeChildren;
function removeFromParent(element) {
    var parentElement = element.parentElement;

    if (parentElement) {
        parentElement.removeChild(element);
        return true;
    }
    return false;
}
exports.removeFromParent = removeFromParent;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var geom_1 = __webpack_require__(9);
function verifyFloat(obj) {
    var t = typeof obj;
    if (t === 'number' || t === 'string') {
        var x = parseFloat('' + obj);
        if (!Number.isNaN(x)) {
            return x;
        }
    }
    throw new Error(`Expected floating-point number, but received: ${ JSON.stringify(obj) }.`);
}
exports.verifyFloat = verifyFloat;
function verifyFiniteFloat(obj) {
    var x = verifyFloat(obj);
    if (Number.isFinite(x)) {
        return x;
    }
    throw new Error(`Expected finite floating-point number, but received: ${ x }.`);
}
exports.verifyFiniteFloat = verifyFiniteFloat;
function verifyFinitePositiveFloat(obj) {
    var x = verifyFiniteFloat(obj);
    if (x > 0) {
        return x;
    }
    throw new Error(`Expected positive finite floating-point number, but received: ${ x }.`);
}
exports.verifyFinitePositiveFloat = verifyFinitePositiveFloat;
function parseXYZ(out, obj) {
    var validator = arguments.length <= 2 || arguments[2] === undefined ? verifyFloat : arguments[2];

    verifyObject(obj);
    var keys = Object.keys(obj);
    keys.sort();
    if (keys.length !== 3 || keys[0] !== 'x' || keys[1] !== 'y' || keys[2] !== 'z') {
        throw new Error(`Expected object to have keys ['x', 'y', 'z'], but received: ${ JSON.stringify(obj) }.`);
    }
    out[0] = validator(obj['x']);
    out[1] = validator(obj['y']);
    out[2] = validator(obj['z']);
    return out;
}
exports.parseXYZ = parseXYZ;
function parseFiniteVec(out, obj) {
    var length = out.length;
    if (!Array.isArray(obj) || obj.length !== length) {
        throw new Error('Incompatible sizes');
    }
    for (var i = 0; i < length; ++i) {
        if (!Number.isFinite(parseFloat(obj[i]))) {
            throw new Error('Non-finite value.');
        }
    }
    for (var _i = 0; _i < length; ++_i) {
        out[_i] = parseFloat(obj[_i]);
    }
    return out;
}
exports.parseFiniteVec = parseFiniteVec;
function parseIntVec(out, obj) {
    var length = out.length;
    if (!Array.isArray(obj) || obj.length !== length) {
        throw new Error('Incompatible sizes.');
    }
    for (var i = 0; i < length; ++i) {
        var val = parseInt(obj[i], undefined);
        if (!Number.isInteger(val)) {
            throw new Error('Non-integer value.');
        }
    }
    for (var _i2 = 0; _i2 < length; ++_i2) {
        out[_i2] = parseInt(obj[_i2], undefined);
    }
    return out;
}
exports.parseIntVec = parseIntVec;
/**
 * Returns a JSON representation of x, with object keys sorted to ensure a
 * consistent result.
 */
function stableStringify(x) {
    if (typeof x === 'object') {
        if (x === null) {
            return 'null';
        }
        if (Array.isArray(x)) {
            var _s = '[';
            var _size = x.length;
            var _i3 = 0;
            if (_i3 < _size) {
                _s += stableStringify(x[_i3]);
                while (++_i3 < _size) {
                    _s += ',';
                    _s += stableStringify(x[_i3]);
                }
            }
            _s += ']';
            return _s;
        }
        var s = '{';
        var keys = Object.keys(x).sort();
        var i = 0;
        var size = keys.length;
        if (i < size) {
            var key = keys[i];
            s += JSON.stringify(key);
            s += ':';
            s += stableStringify(x[key]);
            while (++i < size) {
                s += ',';
                key = keys[i];
                s += JSON.stringify(key);
                s += ':';
                s += stableStringify(x[key]);
            }
        }
        s += '}';
        return s;
    }
    return JSON.stringify(x);
}
exports.stableStringify = stableStringify;
function swapQuotes(x) {
    return x.replace(/['"]/g, s => {
        return s === '"' ? '\'' : '"';
    });
}
function urlSafeStringifyString(x) {
    return swapQuotes(JSON.stringify(swapQuotes(x)));
}
exports.urlSafeStringifyString = urlSafeStringifyString;
var URL_SAFE_COMMA = '_';
function urlSafeStringify(x) {
    if (typeof x === 'object') {
        if (x === null) {
            return 'null';
        }
        var toJSON = x['toJSON'];
        if (typeof toJSON === 'function') {
            return urlSafeStringify(toJSON.call(x));
        }
        if (Array.isArray(x)) {
            var _s2 = '[';
            var size = x.length;
            var i = 0;
            if (i < size) {
                _s2 += urlSafeStringify(x[i]);
                while (++i < size) {
                    _s2 += URL_SAFE_COMMA;
                    _s2 += urlSafeStringify(x[i]);
                }
            }
            _s2 += ']';
            return _s2;
        }
        var s = '{';
        var keys = Object.keys(x);
        var first = true;
        for (var key of keys) {
            var value = x[key];
            if (value === undefined) {
                continue;
            }
            var valueString = urlSafeStringify(value);
            if (!valueString) {
                continue;
            }
            if (!first) {
                s += URL_SAFE_COMMA;
            } else {
                first = false;
            }
            s += urlSafeStringifyString(key);
            s += ':';
            s += valueString;
        }
        s += '}';
        return s;
    }
    if (typeof x === 'string') {
        return urlSafeStringifyString(x);
    }
    return JSON.stringify(x);
}
exports.urlSafeStringify = urlSafeStringify;
var SINGLE_QUOTE_STRING_PATTERN = /('(?:[^'\\]|(?:\\.))*')/;
var DOUBLE_QUOTE_STRING_PATTERN = /("(?:[^'\\]|(?:\\.))*")/;
var SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN = new RegExp(`${ SINGLE_QUOTE_STRING_PATTERN.source }|${ DOUBLE_QUOTE_STRING_PATTERN.source }`);
var DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN = new RegExp(`${ DOUBLE_QUOTE_STRING_PATTERN.source }|${ SINGLE_QUOTE_STRING_PATTERN.source }`);
var DOUBLE_QUOTE_PATTERN = /^((?:[^"'\\]|(?:\\.))*)"/;
var SINGLE_QUOTE_PATTERN = /^((?:[^"'\\]|(?:\\.))*)'/;
function convertStringLiteral(x, quoteInitial, quoteReplace, quoteSearch) {
    if (x.length >= 2 && x.charAt(0) === quoteInitial && x.charAt(x.length - 1) === quoteInitial) {
        var inner = x.substr(1, x.length - 2);
        var s = quoteReplace;
        while (inner.length > 0) {
            var m = inner.match(quoteSearch);
            if (m === null) {
                s += inner;
                break;
            }
            s += m[1];
            s += '\\';
            s += quoteReplace;
            inner = inner.substr(m.index + m[0].length);
        }
        s += quoteReplace;
        return s;
    }
    return x;
}
/**
 * Converts a string literal delimited by either single or double quotes into a string literal
 * delimited by double quotes.
 */
function normalizeStringLiteral(x) {
    return convertStringLiteral(x, '\'', '"', DOUBLE_QUOTE_PATTERN);
}
exports.normalizeStringLiteral = normalizeStringLiteral;
// quoteChar: des
function convertJsonHelper(x, desiredCommaChar, desiredQuoteChar) {
    var commaSearch = /[&_,]/g;
    var quoteInitial = void 0;
    var quoteSearch = void 0;
    var stringLiteralPattern = void 0;
    if (desiredQuoteChar === '"') {
        quoteInitial = '\'';
        quoteSearch = DOUBLE_QUOTE_PATTERN;
        stringLiteralPattern = SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN;
    } else {
        quoteInitial = '"';
        quoteSearch = SINGLE_QUOTE_PATTERN;
        stringLiteralPattern = DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN;
    }
    var s = '';
    while (x.length > 0) {
        var m = x.match(stringLiteralPattern);
        var before = void 0;
        var replacement = void 0;
        if (m === null) {
            before = x;
            x = '';
            replacement = '';
        } else {
            before = x.substr(0, m.index);
            x = x.substr(m.index + m[0].length);
            var originalString = m[1];
            if (originalString !== undefined) {
                replacement = convertStringLiteral(originalString, quoteInitial, desiredQuoteChar, quoteSearch);
            } else {
                replacement = m[2];
            }
        }
        s += before.replace(commaSearch, desiredCommaChar);
        s += replacement;
    }
    return s;
}
function urlSafeToJSON(x) {
    return convertJsonHelper(x, ',', '"');
}
exports.urlSafeToJSON = urlSafeToJSON;
function jsonToUrlSafe(x) {
    return convertJsonHelper(x, '_', '\'');
}
exports.jsonToUrlSafe = jsonToUrlSafe;
function urlSafeParse(x) {
    return JSON.parse(urlSafeToJSON(x));
}
exports.urlSafeParse = urlSafeParse;
// Converts a string containing a Python literal into a string containing an equivalent JSON
// literal.
function pythonLiteralToJSON(x) {
    var s = '';
    while (x.length > 0) {
        var m = x.match(SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN);
        var before = void 0;
        var replacement = void 0;
        if (m === null) {
            before = x;
            x = '';
            replacement = '';
        } else {
            before = x.substr(0, m.index);
            x = x.substr(m.index + m[0].length);
            var singleQuoteString = m[1];
            if (singleQuoteString !== undefined) {
                replacement = normalizeStringLiteral(singleQuoteString);
            } else {
                replacement = m[2];
            }
        }
        s += before.replace(/\(/g, '[').replace(/\)/g, ']').replace('True', 'true').replace('False', 'false').replace(/,\s*([\}\]])/g, '$1');
        s += replacement;
    }
    return s;
}
exports.pythonLiteralToJSON = pythonLiteralToJSON;
// Converts a string containing a Python literal into an equivalent JavaScript value.
function pythonLiteralParse(x) {
    return JSON.parse(pythonLiteralToJSON(x));
}
exports.pythonLiteralParse = pythonLiteralParse;
// Checks that `x' is an array, maps each element by parseElement.
function parseArray(x, parseElement) {
    if (!Array.isArray(x)) {
        throw new Error(`Expected array, but received: ${ JSON.stringify(x) }.`);
    }
    return x.map(parseElement);
}
exports.parseArray = parseArray;
function parseFixedLengthArray(out, obj, parseElement) {
    var length = out.length;
    if (!Array.isArray(obj) || obj.length !== length) {
        throw new Error(`Expected length ${ length } array, but received: ${ JSON.stringify(obj) }.`);
    }
    for (var i = 0; i < length; ++i) {
        out[i] = parseElement(obj[i], i);
    }
    return out;
}
exports.parseFixedLengthArray = parseFixedLengthArray;
function verifyObject(obj) {
    if (typeof obj !== 'object' || obj == null || Array.isArray(obj)) {
        throw new Error(`Expected JSON object, but received: ${ JSON.stringify(obj) }.`);
    }
    return obj;
}
exports.verifyObject = verifyObject;
function verifyInt(obj) {
    var result = parseInt(obj, 10);
    if (!Number.isInteger(result)) {
        throw new Error(`Expected integer, but received: ${ JSON.stringify(obj) }.`);
    }
    return result;
}
exports.verifyInt = verifyInt;
function verifyPositiveInt(obj) {
    var result = verifyInt(obj);
    if (result <= 0) {
        throw new Error(`Expected positive integer, but received: ${ result }.`);
    }
    return result;
}
exports.verifyPositiveInt = verifyPositiveInt;
function verifyMapKey(obj, map) {
    var result = map.get(obj);
    if (result === undefined) {
        throw new Error(`Expected one of ${ JSON.stringify(Array.from(map.keys())) }, but received: ${ JSON.stringify(obj) }.`);
    }
    return result;
}
exports.verifyMapKey = verifyMapKey;
function verifyString(obj) {
    if (typeof obj !== 'string') {
        throw new Error(`Expected string, but received: ${ JSON.stringify(obj) }.`);
    }
    return obj;
}
exports.verifyString = verifyString;
function verifyOptionalString(obj) {
    if (obj === undefined) {
        return undefined;
    }
    return verifyString(obj);
}
exports.verifyOptionalString = verifyOptionalString;
function verifyObjectProperty(obj, propertyName, validator) {
    var value = obj.hasOwnProperty(propertyName) ? obj[propertyName] : undefined;
    try {
        return validator(value);
    } catch (parseError) {
        throw new Error(`Error parsing ${ JSON.stringify(propertyName) } property: ${ parseError.message }`);
    }
}
exports.verifyObjectProperty = verifyObjectProperty;
function verifyObjectAsMap(obj, validator) {
    verifyObject(obj);
    var map = new Map();
    for (var key of Object.keys(obj)) {
        try {
            map.set(key, validator(obj[key]));
        } catch (parseError) {
            throw new Error(`Error parsing value associated with key ${ JSON.stringify(key) }: ${ parseError.message }`);
        }
    }
    return map;
}
exports.verifyObjectAsMap = verifyObjectAsMap;
function verifyFloat01(obj) {
    if (typeof obj !== 'number' || !Number.isFinite(obj) || obj < 0 || obj > 1) {
        throw new Error(`Expected floating point number in [0,1], but received: ${ JSON.stringify(obj) }.`);
    }
    return obj;
}
exports.verifyFloat01 = verifyFloat01;
/**
 * The query string parameters may either be specified in the usual
 * 'name=value&otherName=otherValue' form or as (optionally urlSafe) JSON: '{"name":"value"}`.
 */
function parseQueryStringParameters(queryString) {
    if (queryString === '') {
        return {};
    }
    if (queryString.startsWith('{')) {
        return urlSafeParse(queryString);
    } else {
        var result = {};
        var parts = queryString.split(/[&;]/);
        for (var part of parts) {
            var m = part.match(/^([^=&;]+)=([^&;]*)$/);
            if (m === null) {
                throw new Error(`Invalid query string part: ${ JSON.stringify(part) }.`);
            }
            result[m[1]] = m[2];
        }
        return result;
    }
}
exports.parseQueryStringParameters = parseQueryStringParameters;
/**
 * Verifies that `obj' is a string that, when converted to uppercase, matches a string property of
 * `enumType`.
 *
 * Note: TypeScript does not seem to allow better typing of the return type.
 *
 * @returns The corresponding numerical value.
 */
function verifyEnumString(obj, enumType) {
    if (typeof obj === 'string' && obj.match(/^[a-zA-Z]/) !== null) {
        obj = obj.toUpperCase();
        if (enumType.hasOwnProperty(obj)) {
            return enumType[obj];
        }
    }
    throw new Error(`Invalid enum value: ${ JSON.stringify(obj) }.`);
}
exports.verifyEnumString = verifyEnumString;
function verify3dVec(obj) {
    return parseFixedLengthArray(geom_1.vec3.create(), obj, verifyFiniteFloat);
}
exports.verify3dVec = verify3dVec;
function verify3dScale(obj) {
    return parseFixedLengthArray(geom_1.vec3.create(), obj, verifyFinitePositiveFloat);
}
exports.verify3dScale = verify3dScale;
function verify3dDimensions(obj) {
    return parseFixedLengthArray(geom_1.vec3.create(), obj, verifyPositiveInt);
}
exports.verify3dDimensions = verify3dDimensions;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl_matrix_1 = __webpack_require__(10);
var gl_matrix_2 = __webpack_require__(10);
exports.mat2 = gl_matrix_2.mat2;
exports.mat3 = gl_matrix_2.mat3;
exports.mat4 = gl_matrix_2.mat4;
exports.quat = gl_matrix_2.quat;
exports.vec2 = gl_matrix_2.vec2;
exports.vec3 = gl_matrix_2.vec3;
exports.vec4 = gl_matrix_2.vec4;
exports.identityMat4 = gl_matrix_1.mat4.create();
exports.AXES_NAMES = ['x', 'y', 'z'];

var BoundingBox = function BoundingBox(lower, upper) {
    _classCallCheck(this, BoundingBox);

    this.lower = lower;
    this.upper = upper;
};

exports.BoundingBox = BoundingBox;
;
exports.kAxes = [gl_matrix_1.vec4.fromValues(1, 0, 0, 0), gl_matrix_1.vec4.fromValues(0, 1, 0, 0), gl_matrix_1.vec4.fromValues(0, 0, 1, 0)];
exports.kZeroVec = gl_matrix_1.vec3.fromValues(0, 0, 0);
exports.kInfinityVec = gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity);
function prod3(x) {
    return x[0] * x[1] * x[2];
}
exports.prod3 = prod3;
function prod4(x) {
    return x[0] * x[1] * x[2] * x[3];
}
exports.prod4 = prod4;
/**
 * Implements a one-to-one conversion from Vec3 to string, suitable for use a Map key.
 *
 * Specifically, returns the string representation of the 3 values separated by commas.
 */
function vec3Key(x) {
    return `${ x[0] },${ x[1] },${ x[2] }`;
}
exports.vec3Key = vec3Key;
var RECTIFY_EPSILON = 1e-4;
function rectifyVec3IfAxisAligned(v, offset) {
    var a0 = Math.abs(v[offset]),
        a1 = Math.abs(v[offset + 1]),
        a2 = Math.abs(v[offset + 2]);
    var max = Math.max(a0, a1, a2);
    if (a0 / max < RECTIFY_EPSILON) {
        v[offset] = 0;
    }
    if (a1 / max < RECTIFY_EPSILON) {
        v[offset + 1] = 0;
    }
    if (a2 / max < RECTIFY_EPSILON) {
        v[offset + 2] = 0;
    }
}
exports.rectifyVec3IfAxisAligned = rectifyVec3IfAxisAligned;
/**
 * Makes columns of m that are approximately axis-aligned exactly axis aligned.
 *
 * Note that mat is stored in Fortran order, and therefore the first column is m[0], m[1], m[2].
 */
function rectifyTransformMatrixIfAxisAligned(m) {
    rectifyVec3IfAxisAligned(m, 0);
    rectifyVec3IfAxisAligned(m, 4);
    rectifyVec3IfAxisAligned(m, 8);
}
exports.rectifyTransformMatrixIfAxisAligned = rectifyTransformMatrixIfAxisAligned;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = __webpack_require__(11);
exports.mat2 = __webpack_require__(12);
exports.mat2d = __webpack_require__(13);
exports.mat3 = __webpack_require__(14);
exports.mat4 = __webpack_require__(15);
exports.quat = __webpack_require__(16);
exports.vec2 = __webpack_require__(19);
exports.vec3 = __webpack_require__(17);
exports.vec4 = __webpack_require__(18);

/***/ },
/* 11 */
/***/ function(module, exports) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);
var mat3 = __webpack_require__(14);
var vec3 = __webpack_require__(17);
var vec4 = __webpack_require__(18);

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(11);

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;


/***/ },
/* 20 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CancellationError = function () {
    function CancellationError() {
        _classCallCheck(this, CancellationError);
    }

    _createClass(CancellationError, [{
        key: "toString",
        value: function toString() {
            return 'CancellationError';
        }
    }]);

    return CancellationError;
}();

exports.CancellationError = CancellationError;
;
/**
 * Value thrown to indicate cancellation.
 */
exports.CANCELLED = new CancellationError();
/**
 * Create a new promise capable of receiving notification of cancellation.
 *
 * This extends the interface of the Promise consructor with an additional onCancel argument passed
 * to the executor function.  It is used for specifying a callback function to be invoked when
 * cancelPromise is called.
 *
 * onCancel may be invoked to set the cancellation callback any number of times, either
 * synchronously from within the executor or asynchronously.
 *
 * The effect of invoking onCancel depends on whether the promise is pending (i.e. not yet resolved,
 * rejected, or cancelled):
 *
 * - If at the time onCancel is invoked the promise is still pending, the stored cancellation
 *   callback is replaced with the supplied callback.  The supplied callback may be undefined to
 *   specify that no callback should be invoked.
 *
 * - If at the time onCancel is invoked the promise is not still pending, the supplied callback, if
 *   not undefined, is invoked synchronously.
 *
 * WARNING: Because they may be invoked either synchronously or asynchronously, great care must be
 * taken in writing callbacks to be supplied to onCancel,
 */
function makeCancellablePromise(executor) {
    var finished = false;
    var cancelHandler = void 0;
    var cancelFunction = void 0;
    var promise = new Promise((resolve, reject) => {
        function resolver(value) {
            if (!finished) {
                finished = true;
                cancelHandler = undefined;
                // This can't throw.
                resolve(value);
            }
        }
        function rejecter(value) {
            if (!finished) {
                finished = true;
                cancelHandler = undefined;
                // This can't throw.
                reject(value);
            }
        }
        function setCancelHandler(newCancelHandler) {
            if (finished) {
                try {
                    if (newCancelHandler !== undefined) {
                        newCancelHandler();
                    }
                } catch (ignoredError) {}
            } else {
                cancelHandler = newCancelHandler;
            }
        }
        try {
            executor(resolver, rejecter, setCancelHandler);
        } catch (executorError) {
            rejecter(executorError);
        }
        cancelFunction = () => {
            if (!finished) {
                finished = true;
                if (cancelHandler !== undefined) {
                    try {
                        cancelHandler();
                    } catch (ignoredError) {}
                    cancelHandler = undefined;
                }
                reject(exports.CANCELLED);
            }
        };
    });
    promise.cancel = cancelFunction;
    return promise;
}
exports.makeCancellablePromise = makeCancellablePromise;
/**
 * Try to cancel a promise.
 *
 * If the promise has a cancel method, invoke it synchronously.  For promises created by
 * makeCancellablePromise, this has the effect of synchronously invoking the most recently set
 * cancellation callback, if defined, and rejecting the promise with the error value CANCELLED.
 *
 * If the promise has no cancel method, or is null or undefined, do nothing.
 */
function cancelPromise(promise) {
    if (promise != null) {
        var cancel = promise.cancel;

        if (cancel !== undefined) {
            cancel.call(promise);
        }
    }
}
exports.cancelPromise = cancelPromise;
/**
 * Schedule a call to handler when promise is either fulfilled or rejected.  If the handler throws
 * an error, the returned promise is rejected with it.  Otherwise, the returned promise has the same
 * state as the original promise.
 *
 * If the returned promise is cancelled before the inputPromise is finished, the inputPromise is
 * cancelled.
 */
function callFinally(inputPromise, handler) {
    return makeCancellablePromise((resolve, reject, onCancel) => {
        onCancel(() => {
            cancelPromise(inputPromise);
        });
        inputPromise.then(value => {
            onCancel(undefined);
            Promise.resolve(handler(onCancel)).then(() => {
                resolve(value);
            });
        }, reason => {
            onCancel(undefined);
            try {
                Promise.resolve(handler(onCancel)).then(() => {
                    reject(reason);
                }, reject);
            } catch (otherError) {
                reject(otherError);
            }
        });
    });
}
exports.callFinally = callFinally;
/**
 * Schedule a call to onFulfilled as soon as the promise is fulfilled.
 *
 * A cancellation handler may be set, which is called if the returned promise is cancelled afer
 * inputPromise is fulfilled.  If the returned promise is cancelled before inputPromise is
 * fulfilled, inputPromise is cancelled if it supports it.
 */
function cancellableThen(inputPromise, onFulfilled) {
    return makeCancellablePromise((resolve, reject, onCancel) => {
        var cancelled = false;
        onCancel(() => {
            cancelled = true;
            cancelPromise(inputPromise);
        });
        inputPromise.then(value => {
            if (cancelled) {
                reject(exports.CANCELLED);
            } else {
                onCancel(undefined);
                resolve(onFulfilled(value, onCancel));
            }
        });
    });
}
exports.cancellableThen = cancellableThen;

/***/ },
/* 21 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function getRandomHexString() {
    var numBits = arguments.length <= 0 || arguments[0] === undefined ? 128 : arguments[0];

    var numValues = Math.ceil(numBits / 32);
    var data = new Uint32Array(numValues);
    crypto.getRandomValues(data);
    var s = '';
    for (var i = 0; i < numValues; ++i) {
        s += ('00000000' + data[i].toString(16)).slice(-8);
    }
    return s;
}
exports.getRandomHexString = getRandomHexString;
/**
 * Calls crypto.getRandomValues as many times as needed to fill array.
 */
function getRandomValues(array) {
    var byteArray = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    var blockSize = 65536;
    for (var i = 0, length = byteArray.length; i < length; i += blockSize) {
        crypto.getRandomValues(byteArray.subarray(i, Math.min(length, i + blockSize)));
    }
}
exports.getRandomValues = getRandomValues;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var disposable_1 = __webpack_require__(23);
var IS_WORKER = (false);
var DEBUG = false;
var DEBUG_MESSAGES = false;
var handlers = new Map();
function registerRPC(key, handler) {
    handlers.set(key, handler);
}
exports.registerRPC = registerRPC;
;
var INITIAL_RPC_ID = IS_WORKER ? -1 : 0;

var RPC = function () {
    function RPC(target) {
        _classCallCheck(this, RPC);

        this.target = target;
        this.objects = new Map();
        this.nextId = INITIAL_RPC_ID;
        target.onmessage = e => {
            var data = e.data;
            if (DEBUG_MESSAGES) {
                console.log('Received message', data);
            }
            handlers.get(data.functionName).call(this, data);
        };
    }

    _createClass(RPC, [{
        key: 'set',
        value: function set(id, value) {
            this.objects.set(id, value);
        }
    }, {
        key: 'delete',
        value: function _delete(id) {
            this.objects.delete(id);
        }
    }, {
        key: 'get',
        value: function get(id) {
            return this.objects.get(id);
        }
    }, {
        key: 'getRef',
        value: function getRef(x) {
            var rpcId = x['id'];
            var obj = this.get(rpcId);
            obj.referencedGeneration = x['gen'];
            obj.addRef();
            return obj;
        }
    }, {
        key: 'invoke',
        value: function invoke(name, x, transfers) {
            x.functionName = name;
            if (DEBUG_MESSAGES) {
                console.trace('Sending message', x);
            }
            this.target.postMessage(x, transfers);
        }
    }, {
        key: 'newId',
        value: function newId() {
            return IS_WORKER ? this.nextId-- : this.nextId++;
        }
    }, {
        key: 'numObjects',
        get: function () {
            return this.objects.size;
        }
    }]);

    return RPC;
}();

exports.RPC = RPC;
;

var SharedObject = function (_disposable_1$RefCoun) {
    _inherits(SharedObject, _disposable_1$RefCoun);

    function SharedObject() {
        _classCallCheck(this, SharedObject);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SharedObject).call(this, ...args));

        _this.rpc = null;
        _this.rpcId = null;
        return _this;
    }

    _createClass(SharedObject, [{
        key: 'initializeSharedObject',
        value: function initializeSharedObject(rpc) {
            var rpcId = arguments.length <= 1 || arguments[1] === undefined ? rpc.newId() : arguments[1];

            this.rpc = rpc;
            this.rpcId = rpcId;
            this.isOwner = false;
            rpc.set(rpcId, this);
        }
    }, {
        key: 'initializeCounterpart',
        value: function initializeCounterpart(rpc) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            this.initializeSharedObject(rpc);
            this.unreferencedGeneration = 0;
            this.referencedGeneration = 0;
            this.isOwner = true;
            options['id'] = this.rpcId;
            options['type'] = this.RPC_TYPE_ID;
            rpc.invoke('SharedObject.new', options);
        }
    }, {
        key: 'dispose',
        value: function dispose() {
            _get(Object.getPrototypeOf(SharedObject.prototype), 'dispose', this).call(this);
        }
        /**
         * Precondition: this.isOwner === true.
         */

    }, {
        key: 'addCounterpartRef',
        value: function addCounterpartRef() {
            return { 'id': this.rpcId, 'gen': ++this.referencedGeneration };
        }
    }, {
        key: 'refCountReachedZero',
        value: function refCountReachedZero() {
            if (this.isOwner === true) {
                if (this.referencedGeneration === this.unreferencedGeneration) {
                    this.ownerDispose();
                }
            } else if (this.isOwner === false) {
                this.rpc.invoke('SharedObject.refCountReachedZero', { 'id': this.rpcId, 'gen': this.referencedGeneration });
            } else {
                _get(Object.getPrototypeOf(SharedObject.prototype), 'refCountReachedZero', this).call(this);
            }
        }
        /**
         * Precondition: this.isOwner === true.
         */

    }, {
        key: 'ownerDispose',
        value: function ownerDispose() {
            if (DEBUG) {
                console.log(`[${ IS_WORKER }] #rpc object = ${ this.rpc.numObjects }`);
            }
            var rpc = this.rpc;
            var rpcId = this.rpcId;

            _get(Object.getPrototypeOf(SharedObject.prototype), 'refCountReachedZero', this).call(this);
            rpc.delete(rpcId);
            rpc.invoke('SharedObject.dispose', { 'id': rpcId });
        }
        /**
         * Precondition: this.isOwner === true.
         *
         * This should be called when the counterpart's refCount is decremented and reaches zero.
         */

    }, {
        key: 'counterpartRefCountReachedZero',
        value: function counterpartRefCountReachedZero(generation) {
            this.unreferencedGeneration = generation;
            if (this.refCount === 0 && generation === this.referencedGeneration) {
                this.ownerDispose();
            }
        }
    }]);

    return SharedObject;
}(disposable_1.RefCounted);

exports.SharedObject = SharedObject;
;
/**
 * Base class for defining a SharedObject type that will never be owned.
 */

var SharedObjectCounterpart = function (_SharedObject) {
    _inherits(SharedObjectCounterpart, _SharedObject);

    function SharedObjectCounterpart(rpc) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        _classCallCheck(this, SharedObjectCounterpart);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SharedObjectCounterpart).call(this));

        if (rpc != null) {
            _this2.initializeSharedObject(rpc, options['id']);
        }
        return _this2;
    }

    return SharedObjectCounterpart;
}(SharedObject);

exports.SharedObjectCounterpart = SharedObjectCounterpart;
;
registerRPC('SharedObject.dispose', function (x) {
    var obj = this.get(x['id']);
    if (obj.refCount !== 0) {
        throw new Error(`Attempted to dispose object with non-zero reference count.`);
    }
    if (DEBUG) {
        console.log(`[${ IS_WORKER }] #rpc objects: ${ this.numObjects }`);
    }
    obj.disposed();
    this.delete(obj.rpcId);
    obj.rpcId = null;
    obj.rpc = null;
});
registerRPC('SharedObject.refCountReachedZero', function (x) {
    var obj = this.get(x['id']);
    var generation = x['gen'];
    obj.counterpartRefCountReachedZero(generation);
});
var sharedObjectConstructors = new Map();
/**
 * Register a class as a SharedObject owner type under the specified identifier.
 *
 * This is intended to be used as a decorator.
 */
function registerSharedObjectOwner(identifier) {
    return constructorFunction => {
        constructorFunction.prototype.RPC_TYPE_ID = identifier;
    };
}
exports.registerSharedObjectOwner = registerSharedObjectOwner;
/**
 * Register a class as a SharedObject counterpart type under the specified identifier.
 *
 * This is intended to be used as a decorator.
 *
 * Also register the type as a SharedObject owner, which is useful if this type is also used as a
 * SharedObject owner.
 */
function registerSharedObject(identifier) {
    return constructorFunction => {
        sharedObjectConstructors.set(identifier, constructorFunction);
        constructorFunction.prototype.RPC_TYPE_ID = identifier;
    };
}
exports.registerSharedObject = registerSharedObject;
registerRPC('SharedObject.new', function (x) {
    var rpc = this;
    var typeName = x['type'];
    var constructorFunction = sharedObjectConstructors.get(typeName);
    var obj = new constructorFunction(rpc, x);
    // Counterpart objects start with a reference count of zero.
    --obj.refCount;
});

/***/ },
/* 23 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RefCounted = function () {
    function RefCounted() {
        _classCallCheck(this, RefCounted);

        this.refCount = 1;
    }

    _createClass(RefCounted, [{
        key: "addRef",
        value: function addRef() {
            ++this.refCount;
            return this;
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (--this.refCount !== 0) {
                return;
            }
            this.refCountReachedZero();
        }
    }, {
        key: "refCountReachedZero",
        value: function refCountReachedZero() {
            this.disposed();
            var disposers = this.disposers;

            if (disposers != null) {
                var numDisposers = disposers.length;
                for (var i = numDisposers; i > 0; --i) {
                    var disposer = disposers[i - 1];
                    if (typeof disposer === 'object') {
                        disposer.dispose();
                    } else {
                        disposer.call(this);
                    }
                }
                this.disposers = undefined;
            }
        }
    }, {
        key: "disposed",
        value: function disposed() {}
    }, {
        key: "registerDisposer",
        value: function registerDisposer(f) {
            var disposers = this.disposers;

            if (disposers == null) {
                this.disposers = [f];
            } else {
                disposers.push(f);
            }
            return f;
        }
    }, {
        key: "unregisterDisposer",
        value: function unregisterDisposer(f) {
            var disposers = this.disposers;

            if (disposers != null) {
                var index = disposers.indexOf(f);
                if (index !== -1) {
                    disposers.splice(index, 1);
                }
            }
            return f;
        }
    }, {
        key: "registerSignalBinding",
        value: function registerSignalBinding(binding) {
            this.registerDisposer(() => binding.detach());
        }
    }, {
        key: "registerEventListener",
        value: function registerEventListener(target, eventType, listener, arg) {
            target.addEventListener(eventType, listener, arg);
            this.registerDisposer(() => target.removeEventListener(eventType, listener, arg));
        }
    }, {
        key: "registerCancellable",
        value: function registerCancellable(cancellable) {
            this.registerDisposer(() => {
                cancellable.cancel();
            });
            return cancellable;
        }
    }]);

    return RefCounted;
}();

exports.RefCounted = RefCounted;
;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var api_implementation_1 = __webpack_require__(3);
var http_request_1 = __webpack_require__(25);
var promise_1 = __webpack_require__(20);
exports.numPendingRequests = 0;
exports.PRODUCTION_INSTANCE = 0;
exports.INSTANCE_NAMES = [];
/**
 * Maps a BrainmapsInstance to the list of base URL shards to use for accessing it.
 */
exports.INSTANCE_BASE_URLS = [];
var instanceHostname = [];
exports.INSTANCE_IDENTIFIERS = [];
function brainmapsInstanceKey(instance) {
    return exports.INSTANCE_IDENTIFIERS[instance];
}
exports.brainmapsInstanceKey = brainmapsInstanceKey;
function setupBrainmapsInstance(instance, hostname, identifier, name) {
    exports.INSTANCE_IDENTIFIERS[instance] = identifier;
    exports.INSTANCE_NAMES[instance] = name;
    instanceHostname[instance] = hostname;
    var baseUrls = [`https://${ hostname }`];
    for (var shard = 0; shard <= 9; ++shard) {
        baseUrls.push(`https://s${ shard }-${ hostname }`);
    }
    exports.INSTANCE_BASE_URLS[instance] = baseUrls;
}
exports.setupBrainmapsInstance = setupBrainmapsInstance;
setupBrainmapsInstance(exports.PRODUCTION_INSTANCE, 'brainmaps.googleapis.com', 'prod', 'Brain Maps');
function makeRequest(instance, method, path, responseType) {
    /**
     * undefined means request not yet attempted.  null means request
     * cancelled.
     */
    var xhr = undefined;
    return promise_1.makeCancellablePromise((resolve, reject, onCancel) => {
        function start(token) {
            if (xhr === null) {
                --exports.numPendingRequests;
                return;
            }
            xhr = http_request_1.openShardedHttpRequest(exports.INSTANCE_BASE_URLS[instance], path, method);
            xhr.responseType = responseType;
            xhr.setRequestHeader('Authorization', `${ token['tokenType'] } ${ token['accessToken'] }`);
            xhr.onloadend = function () {
                if (xhr === null) {
                    --exports.numPendingRequests;
                    return;
                }
                var status = this.status;
                if (status >= 200 && status < 300) {
                    --exports.numPendingRequests;
                    resolve(this.response);
                } else if (status === 403 || status === 401) {
                    // Authorization needed.
                    api_implementation_1.getToken(token).then(start);
                } else {
                    --exports.numPendingRequests;
                    reject(http_request_1.HttpError.fromXhr(this));
                }
            };
            xhr.send();
        }
        onCancel(() => {
            var origXhr = xhr;
            xhr = null;
            if (origXhr != null) {
                origXhr.abort();
            }
        });
        api_implementation_1.getToken().then(start);
    });
}
exports.makeRequest = makeRequest;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hash_1 = __webpack_require__(26);
var promise_1 = __webpack_require__(20);
exports.URL_SYMBOL = Symbol('url');
exports.METHOD_SYMBOL = Symbol('method');

var HttpError = function (_Error) {
    _inherits(HttpError, _Error);

    function HttpError(method, url, code, statusMessage) {
        _classCallCheck(this, HttpError);

        var message = `${ method } ${ JSON.stringify(url) } resulted in HTTP error ${ code }`;
        if (statusMessage) {
            message += `: ${ statusMessage }`;
        }
        message += '.';

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(HttpError).call(this, message));

        _this.name = 'HttpError';
        _this.message = message;
        _this.method = method;
        _this.url = url;
        _this.code = code;
        _this.statusMessage = statusMessage;
        return _this;
    }

    _createClass(HttpError, null, [{
        key: 'fromXhr',
        value: function fromXhr(xhr) {
            return new HttpError(xhr[exports.METHOD_SYMBOL], xhr[exports.URL_SYMBOL], xhr.status, xhr.statusText);
        }
    }]);

    return HttpError;
}(Error);

exports.HttpError = HttpError;
;
function openHttpRequest(url) {
    var method = arguments.length <= 1 || arguments[1] === undefined ? 'GET' : arguments[1];

    var xhr = new XMLHttpRequest();
    xhr[exports.METHOD_SYMBOL] = method;
    xhr[exports.URL_SYMBOL] = url;
    xhr.open(method, url);
    return xhr;
}
exports.openHttpRequest = openHttpRequest;
function pickShard(baseUrls, path) {
    if (Array.isArray(baseUrls)) {
        var numShards = baseUrls.length;
        var shard = numShards === 1 ? 0 : Math.abs(hash_1.simpleStringHash(path)) % numShards;
        return baseUrls[shard] + path;
    }
    return baseUrls + path;
}
exports.pickShard = pickShard;
function openShardedHttpRequest(baseUrls, path) {
    var method = arguments.length <= 2 || arguments[2] === undefined ? 'GET' : arguments[2];

    var xhr = new XMLHttpRequest();
    var url = pickShard(baseUrls, path);
    xhr[exports.METHOD_SYMBOL] = method;
    xhr[exports.URL_SYMBOL] = url;
    xhr.open(method, url);
    return xhr;
}
exports.openShardedHttpRequest = openShardedHttpRequest;
function sendHttpRequest(xhr, responseType) {
    xhr.responseType = responseType;
    return promise_1.makeCancellablePromise((resolve, reject, onCancel) => {
        xhr.onloadend = function () {
            var status = this.status;
            if (status >= 200 && status < 300) {
                resolve(this.response);
            } else {
                reject(HttpError.fromXhr(xhr));
            }
        };
        onCancel(() => {
            xhr.abort();
        });
        xhr.send();
    });
}
exports.sendHttpRequest = sendHttpRequest;
/**
 * Parses a URL that may have a special protocol designation into a list of base URLs and a path.
 *
 * If the protocol is 'http' or 'https', the input string is returned as a single base URL, with an
 * empty path.
 *
 * Additionally, 'gs://bucket/path' is supported for accessing Google Storage buckets.
 */
function parseSpecialUrl(url) {
    var urlProtocolPattern = /^([^:\/]+):\/\/([^\/]+)(\/.*)?$/;
    var match = url.match(urlProtocolPattern);
    if (match === null) {
        throw new Error(`Invalid URL: ${ JSON.stringify(url) }`);
    }
    var protocol = match[1];
    if (protocol === 'gs') {
        var bucket = match[2];
        var baseUrls = [`https://${ bucket }.storage.googleapis.com`, `https://storage.googleapis.com/${ bucket }`];
        return [baseUrls, match[3]];
    }
    return [[url], ''];
}
exports.parseSpecialUrl = parseSpecialUrl;

/***/ },
/* 26 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * This is a very simple string hash function.  It isn't secure, but
 * is suitable for sharding of requests.
 */

function simpleStringHash(s) {
  var h = 0;
  var length = s.length;
  for (var i = 0; i < length; ++i) {
    h = h * 31 + s.charCodeAt(i) | 0;
  }
  return h;
}
exports.simpleStringHash = simpleStringHash;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var api_1 = __webpack_require__(24);
(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 0] = "RAW";
    VolumeChunkEncoding[VolumeChunkEncoding["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding[VolumeChunkEncoding["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
})(exports.VolumeChunkEncoding || (exports.VolumeChunkEncoding = {}));
var VolumeChunkEncoding = exports.VolumeChunkEncoding;

var VolumeSourceParameters = function () {
    function VolumeSourceParameters() {
        _classCallCheck(this, VolumeSourceParameters);
    }

    _createClass(VolumeSourceParameters, null, [{
        key: "stringify",
        value: function stringify(p) {
            return `brainmaps-${ api_1.brainmapsInstanceKey(p['instance']) }:volume/${ p['volume_id'] }/${ p['scaleIndex'] }/${ VolumeChunkEncoding[p['encoding']] }`;
        }
    }]);

    return VolumeSourceParameters;
}();

VolumeSourceParameters.RPC_ID = 'brainmaps/VolumeChunkSource';
exports.VolumeSourceParameters = VolumeSourceParameters;
;

var MeshSourceParameters = function () {
    function MeshSourceParameters() {
        _classCallCheck(this, MeshSourceParameters);
    }

    _createClass(MeshSourceParameters, null, [{
        key: "stringify",
        value: function stringify(p) {
            return `brainmaps:${ api_1.brainmapsInstanceKey(p['instance']) }:mesh/${ p['volume_id'] }/${ p['mesh_name'] }`;
        }
    }]);

    return MeshSourceParameters;
}();

MeshSourceParameters.RPC_ID = 'brainmaps/MeshSource';
exports.MeshSourceParameters = MeshSourceParameters;
;

var SkeletonSourceParameters = function (_MeshSourceParameters) {
    _inherits(SkeletonSourceParameters, _MeshSourceParameters);

    function SkeletonSourceParameters() {
        _classCallCheck(this, SkeletonSourceParameters);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SkeletonSourceParameters).apply(this, arguments));
    }

    return SkeletonSourceParameters;
}(MeshSourceParameters);

SkeletonSourceParameters.RPC_ID = 'brainmaps/SkeletonSource';
exports.SkeletonSourceParameters = SkeletonSourceParameters;
;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var completion_1 = __webpack_require__(29);
var promise_1 = __webpack_require__(20);
/**
 * Returns the length of the prefix of path that corresponds to the "group", according to the
 * specified separator.
 *
 * If the separator is not specified, gueses whether it is '/' or ':'.
 */
function findSourceGroupBasedOnSeparator(path, separator) {
    if (separator === undefined) {
        // Try to guess whether '/' or ':' is the separator.
        if (path.indexOf('/') === -1) {
            separator = ':';
        } else {
            separator = '/';
        }
    }
    var index = path.lastIndexOf(separator);
    if (index === -1) {
        return 0;
    }
    return index + 1;
}
exports.findSourceGroupBasedOnSeparator = findSourceGroupBasedOnSeparator;
/**
 * Returns the last "component" of path, according to the specified separator.
 * If the separator is not specified, gueses whether it is '/' or ':'.
 */
function suggestLayerNameBasedOnSeparator(path, separator) {
    var groupIndex = findSourceGroupBasedOnSeparator(path, separator);
    return path.substring(groupIndex);
}
exports.suggestLayerNameBasedOnSeparator = suggestLayerNameBasedOnSeparator;
var dataSourceFactories = new Map();
function registerDataSourceFactory(name, factory) {
    dataSourceFactories.set(name, factory);
}
exports.registerDataSourceFactory = registerDataSourceFactory;
var protocolPattern = /^(?:([a-zA-Z-+_]+):\/\/)?(.*)$/;
function getDataSource(url) {
    var m = url.match(protocolPattern);
    if (m === null || m[1] === undefined) {
        throw new Error(`Data source URL must have the form "<protocol>://<path>".`);
    }
    var dataSource = m[1];
    var factory = dataSourceFactories.get(dataSource);
    if (factory === undefined) {
        throw new Error(`Unsupported data source: ${ JSON.stringify(dataSource) }.`);
    }
    return [factory, m[2], dataSource];
}
function getVolume(url) {
    var _getDataSource = getDataSource(url);

    var _getDataSource2 = _slicedToArray(_getDataSource, 2);

    var factories = _getDataSource2[0];
    var path = _getDataSource2[1];

    return factories.getVolume(path);
}
exports.getVolume = getVolume;
function getMeshSource(chunkManager, url) {
    var lod = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

    var _getDataSource3 = getDataSource(url);

    var _getDataSource4 = _slicedToArray(_getDataSource3, 2);

    var factories = _getDataSource4[0];
    var path = _getDataSource4[1];

    return factories.getMeshSource(chunkManager, path, lod);
}
exports.getMeshSource = getMeshSource;
function getSkeletonSource(chunkManager, url) {
    var _getDataSource5 = getDataSource(url);

    var _getDataSource6 = _slicedToArray(_getDataSource5, 2);

    var factories = _getDataSource6[0];
    var path = _getDataSource6[1];

    return factories.getSkeletonSource(chunkManager, path);
}
exports.getSkeletonSource = getSkeletonSource;
function volumeCompleter(url) {
    // Check if url matches a protocol.  Note that protocolPattern always matches.
    var protocolMatch = url.match(protocolPattern);
    var protocol = protocolMatch[1];
    if (protocol === undefined) {
        // Return protocol completions.
        var completions = [];
        for (var _ref3 of dataSourceFactories) {
            var _ref2 = _slicedToArray(_ref3, 2);

            var name = _ref2[0];
            var _factory = _ref2[1];

            name = name + '://';
            if (name.startsWith(url)) {
                completions.push({ value: name, description: _factory.description });
            }
        }
        return Promise.resolve({ offset: 0, completions });
    }
    var factory = dataSourceFactories.get(protocol);
    if (factory !== undefined) {
        var subCompleter = factory.volumeCompleter;
        if (subCompleter !== undefined) {
            return promise_1.cancellableThen(subCompleter(protocolMatch[2]), completions => completion_1.applyCompletionOffset(protocol.length + 3, completions));
        }
    }
    return Promise.reject(null);
}
exports.volumeCompleter = volumeCompleter;
function suggestLayerName(url) {
    var _getDataSource7 = getDataSource(url);

    var _getDataSource8 = _slicedToArray(_getDataSource7, 2);

    var factories = _getDataSource8[0];
    var path = _getDataSource8[1];

    var suggestor = factories.suggestLayerName;
    if (suggestor !== undefined) {
        return suggestor(path);
    }
    return suggestLayerNameBasedOnSeparator(path);
}
exports.suggestLayerName = suggestLayerName;
function findSourceGroup(url) {
    var _getDataSource9 = getDataSource(url);

    var _getDataSource10 = _slicedToArray(_getDataSource9, 3);

    var factories = _getDataSource10[0];
    var path = _getDataSource10[1];
    var dataSourceName = _getDataSource10[2];

    var helper = factories.findSourceGroup || findSourceGroupBasedOnSeparator;
    return helper(path) + dataSourceName.length + 3;
}
exports.findSourceGroup = findSourceGroup;

/***/ },
/* 29 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function applyCompletionOffset(offset, completionResult) {
    completionResult.offset += offset;
    return completionResult;
}
exports.applyCompletionOffset = applyCompletionOffset;
function getPrefixMatches(prefix, options) {
    var result = [];
    for (var option of options) {
        if (option.startsWith(prefix)) {
            result.push({ value: option });
        }
    }
    return result;
}
exports.getPrefixMatches = getPrefixMatches;
function getPrefixMatchesWithDescriptions(prefix, options, getValue, getDescription) {
    var result = [];
    for (var option of options) {
        var key = getValue(option);
        if (key.startsWith(prefix)) {
            result.push({ value: key, description: getDescription(option) });
        }
    }
    return result;
}
exports.getPrefixMatchesWithDescriptions = getPrefixMatchesWithDescriptions;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var base_1 = __webpack_require__(31);
var frontend_1 = __webpack_require__(32);
var base_2 = __webpack_require__(35);
var perspective_panel_1 = __webpack_require__(36);
var frontend_2 = __webpack_require__(75);
var geom_1 = __webpack_require__(9);
var json_1 = __webpack_require__(8);
var buffer_1 = __webpack_require__(38);
var shader_1 = __webpack_require__(41);
var shader_lib_1 = __webpack_require__(72);
var worker_rpc_1 = __webpack_require__(22);

var MeshShaderManager = function () {
    function MeshShaderManager() {
        _classCallCheck(this, MeshShaderManager);

        this.tempLightVec = geom_1.vec4.create();
        this.tempPickID = new Float32Array(4);
    }

    _createClass(MeshShaderManager, [{
        key: "defineShader",
        value: function defineShader(builder) {
            builder.addAttribute('highp vec3', 'aVertexPosition');
            builder.addAttribute('highp vec3', 'aVertexNormal');
            builder.addVarying('highp vec3', 'vColor');
            builder.addUniform('highp vec4', 'uLightDirection');
            builder.addUniform('highp vec3', 'uColor');
            builder.addUniform('highp mat4', 'uModelMatrix');
            builder.addUniform('highp mat4', 'uProjection');
            builder.addUniform('highp vec4', 'uPickID');
            builder.require(perspective_panel_1.perspectivePanelEmit);
            builder.setVertexMain(`
gl_Position = uProjection * (uModelMatrix * vec4(aVertexPosition, 1.0));
vec3 normal = (uModelMatrix * vec4(aVertexNormal, 0.0)).xyz;
float lightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
vColor = lightingFactor * uColor;
`);
            builder.setFragmentMain(`emit(vec4(vColor, 1.0), uPickID);`);
        }
    }, {
        key: "beginLayer",
        value: function beginLayer(gl, shader, renderContext) {
            var dataToDevice = renderContext.dataToDevice;
            var lightDirection = renderContext.lightDirection;
            var ambientLighting = renderContext.ambientLighting;
            var directionalLighting = renderContext.directionalLighting;

            gl.uniformMatrix4fv(shader.uniform('uProjection'), false, dataToDevice);
            var lightVec = this.tempLightVec;
            geom_1.vec3.scale(lightVec, lightDirection, directionalLighting);
            lightVec[3] = ambientLighting;
            gl.uniform4fv(shader.uniform('uLightDirection'), lightVec);
        }
    }, {
        key: "beginObject",
        value: function beginObject(gl, shader, objectToDataMatrix, color, pickID) {
            gl.uniformMatrix4fv(shader.uniform('uModelMatrix'), false, objectToDataMatrix);
            gl.uniform4fv(shader.uniform('uPickID'), shader_lib_1.setVec4FromUint32(this.tempPickID, pickID));
            gl.uniform3fv(shader.uniform('uColor'), color);
        }
    }, {
        key: "getShader",
        value: function getShader(gl) {
            return gl.memoize.get('mesh/MeshShaderManager', () => {
                var builder = new shader_1.ShaderBuilder(gl);
                this.defineShader(builder);
                return builder.build();
            });
        }
    }, {
        key: "drawFragment",
        value: function drawFragment(gl, shader, fragmentChunk) {
            fragmentChunk.vertexBuffer.bindToVertexAttrib(shader.attribute('aVertexPosition'),
            /*components=*/3);
            fragmentChunk.normalBuffer.bindToVertexAttrib(shader.attribute('aVertexNormal'),
            /*components=*/3);
            fragmentChunk.indexBuffer.bind();
            gl.drawElements(gl.TRIANGLES, fragmentChunk.numIndices, gl.UNSIGNED_INT, 0);
        }
    }, {
        key: "endLayer",
        value: function endLayer(gl, shader) {
            gl.disableVertexAttribArray(shader.attribute('aVertexPosition'));
            gl.disableVertexAttribArray(shader.attribute('aVertexNormal'));
        }
    }]);

    return MeshShaderManager;
}();

exports.MeshShaderManager = MeshShaderManager;
;

var MeshLayer = function (_perspective_panel_1$) {
    _inherits(MeshLayer, _perspective_panel_1$);

    function MeshLayer(chunkManager, source, displayState) {
        _classCallCheck(this, MeshLayer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshLayer).call(this));

        _this.chunkManager = chunkManager;
        _this.source = source;
        _this.displayState = displayState;
        _this.meshShaderManager = new MeshShaderManager();
        _this.shader = _this.registerDisposer(_this.meshShaderManager.getShader(_this.gl));
        frontend_2.registerRedrawWhenSegmentationDisplayStateChanged(displayState, _this);
        var sharedObject = _this.sharedObject = _this.registerDisposer(new frontend_2.SegmentationLayerSharedObject(chunkManager, displayState));
        sharedObject.RPC_TYPE_ID = base_2.MESH_LAYER_RPC_ID;
        sharedObject.initializeCounterpartWithChunkManager({
            'source': source.addCounterpartRef()
        });
        _this.setReady(true);
        _this.visibilityCount.addDependency(sharedObject.visibilityCount);
        return _this;
    }

    _createClass(MeshLayer, [{
        key: "draw",
        value: function draw(renderContext) {
            var gl = this.gl;
            var shader = this.shader;
            var displayState = this.displayState;
            var meshShaderManager = this.meshShaderManager;

            shader.bind();
            meshShaderManager.beginLayer(gl, shader, renderContext);
            var objectChunks = this.source.fragmentSource.objectChunks;
            var pickIDs = renderContext.pickIDs;

            var objectToDataMatrix = geom_1.identityMat4;
            frontend_2.forEachSegmentToDraw(displayState, objectChunks, (rootObjectId, objectId, fragments) => {
                meshShaderManager.beginObject(gl, shader, objectToDataMatrix, frontend_2.getObjectColor(displayState, rootObjectId), pickIDs.register(this, objectId));
                for (var fragment of fragments) {
                    if (fragment.state === base_1.ChunkState.GPU_MEMORY) {
                        meshShaderManager.drawFragment(gl, shader, fragment);
                    }
                }
            });
            meshShaderManager.endLayer(gl, shader);
        }
    }, {
        key: "gl",
        get: function () {
            return this.chunkManager.chunkQueueManager.gl;
        }
    }]);

    return MeshLayer;
}(perspective_panel_1.PerspectiveViewRenderLayer);

exports.MeshLayer = MeshLayer;
;

var FragmentChunk = function (_frontend_1$Chunk) {
    _inherits(FragmentChunk, _frontend_1$Chunk);

    function FragmentChunk(source, x) {
        _classCallCheck(this, FragmentChunk);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(FragmentChunk).call(this, source));

        _this2.objectKey = x['objectKey'];
        _this2.vertexPositions = x['vertexPositions'];
        var indices = _this2.indices = x['indices'];
        _this2.numIndices = indices.length;
        _this2.vertexNormals = x['vertexNormals'];
        return _this2;
    }

    _createClass(FragmentChunk, [{
        key: "copyToGPU",
        value: function copyToGPU(gl) {
            _get(Object.getPrototypeOf(FragmentChunk.prototype), "copyToGPU", this).call(this, gl);
            this.vertexBuffer = buffer_1.Buffer.fromData(gl, this.vertexPositions, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
            this.indexBuffer = buffer_1.Buffer.fromData(gl, this.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);
            this.normalBuffer = buffer_1.Buffer.fromData(gl, this.vertexNormals, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        }
    }, {
        key: "freeGPUMemory",
        value: function freeGPUMemory(gl) {
            _get(Object.getPrototypeOf(FragmentChunk.prototype), "freeGPUMemory", this).call(this, gl);
            this.vertexBuffer.dispose();
            this.indexBuffer.dispose();
            this.normalBuffer.dispose();
        }
    }]);

    return FragmentChunk;
}(frontend_1.Chunk);

exports.FragmentChunk = FragmentChunk;
;
var FragmentSource = function (_frontend_1$ChunkSour) {
    _inherits(FragmentSource, _frontend_1$ChunkSour);

    function FragmentSource(chunkManager, meshSource) {
        _classCallCheck(this, FragmentSource);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(FragmentSource).call(this, chunkManager));

        _this3.meshSource = meshSource;
        _this3.objectChunks = new Map();
        return _this3;
    }

    _createClass(FragmentSource, [{
        key: "addChunk",
        value: function addChunk(key, chunk) {
            _get(Object.getPrototypeOf(FragmentSource.prototype), "addChunk", this).call(this, key, chunk);
            var objectChunks = this.objectChunks;
            var objectKey = chunk.objectKey;

            var fragments = objectChunks.get(objectKey);
            if (fragments === undefined) {
                fragments = new Set();
                objectChunks.set(objectKey, fragments);
            }
            fragments.add(chunk);
        }
    }, {
        key: "deleteChunk",
        value: function deleteChunk(key) {
            var chunk = this.chunks.get(key);
            _get(Object.getPrototypeOf(FragmentSource.prototype), "deleteChunk", this).call(this, key);
            var objectChunks = this.objectChunks;
            var objectKey = chunk.objectKey;

            var fragments = objectChunks.get(objectKey);
            fragments.delete(chunk);
            if (fragments.size === 0) {
                objectChunks.delete(objectKey);
            }
        }
    }, {
        key: "getChunk",
        value: function getChunk(x) {
            return new FragmentChunk(this, x);
        }
    }]);

    return FragmentSource;
}(frontend_1.ChunkSource);
FragmentSource = __decorate([worker_rpc_1.registerSharedObjectOwner(base_2.FRAGMENT_SOURCE_RPC_ID)], FragmentSource);
exports.FragmentSource = FragmentSource;
;

var MeshSource = function (_frontend_1$ChunkSour2) {
    _inherits(MeshSource, _frontend_1$ChunkSour2);

    function MeshSource() {
        _classCallCheck(this, MeshSource);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshSource).call(this, ...args));

        _this4.fragmentSource = new FragmentSource(_this4.chunkManager, _this4);
        return _this4;
    }

    _createClass(MeshSource, [{
        key: "initializeCounterpart",
        value: function initializeCounterpart(rpc, options) {
            this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {});
            options['fragmentSource'] = this.fragmentSource.addCounterpartRef();
            _get(Object.getPrototypeOf(MeshSource.prototype), "initializeCounterpart", this).call(this, rpc, options);
        }
    }]);

    return MeshSource;
}(frontend_1.ChunkSource);

exports.MeshSource = MeshSource;
;
/**
 * Defines a MeshSource for which all state is encapsulated in an object of type Parameters.
 */
function defineParameterizedMeshSource(parametersConstructor) {
    var newConstructor = function (_MeshSource) {
        _inherits(ParameterizedMeshSource, _MeshSource);

        function ParameterizedMeshSource(chunkManager, parameters) {
            _classCallCheck(this, ParameterizedMeshSource);

            var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(ParameterizedMeshSource).call(this, chunkManager));

            _this5.parameters = parameters;
            return _this5;
        }

        _createClass(ParameterizedMeshSource, [{
            key: "initializeCounterpart",
            value: function initializeCounterpart(rpc, options) {
                options['parameters'] = this.parameters;
                _get(Object.getPrototypeOf(ParameterizedMeshSource.prototype), "initializeCounterpart", this).call(this, rpc, options);
            }
        }, {
            key: "toString",
            value: function toString() {
                return parametersConstructor.stringify(this.parameters);
            }
        }], [{
            key: "get",
            value: function get(chunkManager, parameters) {
                return chunkManager.getChunkSource(this, json_1.stableStringify(parameters), () => new this(chunkManager, parameters));
            }
        }]);

        return ParameterizedMeshSource;
    }(MeshSource);
    newConstructor.prototype.RPC_TYPE_ID = parametersConstructor.RPC_ID;
    return newConstructor;
}
exports.defineParameterizedMeshSource = defineParameterizedMeshSource;

/***/ },
/* 31 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (ChunkState) {
    // Chunk is stored in GPU memory in addition to system memory.
    ChunkState[ChunkState["GPU_MEMORY"] = 0] = "GPU_MEMORY";
    // Chunk is stored only in system memory but not in GPU memory.
    ChunkState[ChunkState["SYSTEM_MEMORY"] = 1] = "SYSTEM_MEMORY";
    // Chunk is stored in system memory on worker.
    ChunkState[ChunkState["SYSTEM_MEMORY_WORKER"] = 2] = "SYSTEM_MEMORY_WORKER";
    // Chunk is downloading.
    ChunkState[ChunkState["DOWNLOADING"] = 3] = "DOWNLOADING";
    // Chunk is not yet downloading.
    ChunkState[ChunkState["QUEUED"] = 4] = "QUEUED";
    // Chunk has just been added.
    ChunkState[ChunkState["NEW"] = 5] = "NEW";
    // Download failed.
    ChunkState[ChunkState["FAILED"] = 6] = "FAILED";
    ChunkState[ChunkState["EXPIRED"] = 7] = "EXPIRED";
})(exports.ChunkState || (exports.ChunkState = {}));
var ChunkState = exports.ChunkState;
(function (ChunkPriorityTier) {
    ChunkPriorityTier[ChunkPriorityTier["FIRST_TIER"] = 0] = "FIRST_TIER";
    ChunkPriorityTier[ChunkPriorityTier["FIRST_ORDERED_TIER"] = 0] = "FIRST_ORDERED_TIER";
    ChunkPriorityTier[ChunkPriorityTier["VISIBLE"] = 0] = "VISIBLE";
    ChunkPriorityTier[ChunkPriorityTier["PREFETCH"] = 1] = "PREFETCH";
    ChunkPriorityTier[ChunkPriorityTier["LAST_ORDERED_TIER"] = 1] = "LAST_ORDERED_TIER";
    ChunkPriorityTier[ChunkPriorityTier["RECENT"] = 2] = "RECENT";
    ChunkPriorityTier[ChunkPriorityTier["LAST_TIER"] = 2] = "LAST_TIER";
})(exports.ChunkPriorityTier || (exports.ChunkPriorityTier = {}));
var ChunkPriorityTier = exports.ChunkPriorityTier;

var AvailableCapacity = function () {
    function AvailableCapacity(maxItems, maxSize) {
        _classCallCheck(this, AvailableCapacity);

        /**
         * Number of additional items that are available.
         */
        this.availableItems = maxItems;
        /**
         * Total number of items that can be accomodated.
         */
        this.itemCapacity = maxItems;
        /**
         * Aggregate additional size capacity that is available.
         */
        this.availableSize = maxSize;
        /**
         * Total aggregate item size that can be accomodated.
         */
        this.sizeCapacity = maxSize;
    }
    /**
     * Adjust available capacity by the specified amounts.
     */


    _createClass(AvailableCapacity, [{
        key: "adjust",
        value: function adjust(items, size) {
            this.availableItems += items;
            this.availableSize += size;
        }
    }, {
        key: "toString",
        value: function toString() {
            return `${ this.availableItems }/${ this.itemCapacity } items, ${ this.availableSize }/${ this.sizeCapacity } size`;
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return { 'itemCapacity': this.itemCapacity, 'sizeCapacity': this.sizeCapacity };
        }
    }], [{
        key: "fromObject",
        value: function fromObject(x) {
            return new AvailableCapacity(x['itemCapacity'], x['sizeCapacity']);
        }
    }]);

    return AvailableCapacity;
}();

AvailableCapacity.INFINITE = new AvailableCapacity(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
exports.AvailableCapacity = AvailableCapacity;
;
exports.CHUNK_QUEUE_MANAGER_RPC_ID = 'ChunkQueueManager';
exports.CHUNK_MANAGER_RPC_ID = 'ChunkManager';

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var base_1 = __webpack_require__(31);
var memoize_1 = __webpack_require__(33);
var worker_rpc_1 = __webpack_require__(22);
var signals_1 = __webpack_require__(34);
var DEBUG_CHUNK_UPDATES = false;

var Chunk = function () {
    function Chunk(source) {
        _classCallCheck(this, Chunk);

        this.source = source;
        this.state = base_1.ChunkState.SYSTEM_MEMORY;
    }

    _createClass(Chunk, [{
        key: "copyToGPU",
        value: function copyToGPU(gl) {
            this.state = base_1.ChunkState.GPU_MEMORY;
        }
    }, {
        key: "freeGPUMemory",
        value: function freeGPUMemory(gl) {
            this.state = base_1.ChunkState.SYSTEM_MEMORY;
        }
    }, {
        key: "gl",
        get: function () {
            return this.source.gl;
        }
    }]);

    return Chunk;
}();

exports.Chunk = Chunk;
;
var ChunkQueueManager = function (_worker_rpc_1$SharedO) {
    _inherits(ChunkQueueManager, _worker_rpc_1$SharedO);

    function ChunkQueueManager(rpc, gl, capacities) {
        _classCallCheck(this, ChunkQueueManager);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ChunkQueueManager).call(this));

        _this.gl = gl;
        _this.visibleChunksChanged = new signals_1.Signal();
        _this.pendingChunkUpdates = null;
        _this.pendingChunkUpdatesTail = null;
        /**
         * If non-null, deadline in milliseconds since epoch after which chunk copies to the GPU may not
         * start (until the next frame).
         */
        _this.chunkUpdateDeadline = null;
        _this.chunkUpdateDelay = 30;
        _this.initializeCounterpart(rpc, {
            'gpuMemoryCapacity': capacities.gpuMemory.toObject(),
            'systemMemoryCapacity': capacities.systemMemory.toObject(),
            'downloadCapacity': capacities.download.toObject()
        });
        return _this;
    }

    _createClass(ChunkQueueManager, [{
        key: "scheduleChunkUpdate",
        value: function scheduleChunkUpdate() {
            var deadline = this.chunkUpdateDeadline;
            var delay = void 0;
            if (deadline === null || Date.now() < deadline) {
                delay = 0;
            } else {
                delay = this.chunkUpdateDelay;
            }
            setTimeout(this.processPendingChunkUpdates.bind(this), delay);
        }
    }, {
        key: "processPendingChunkUpdates",
        value: function processPendingChunkUpdates() {
            var deadline = this.chunkUpdateDeadline;
            if (deadline !== null && Date.now() > deadline) {
                // No time to perform chunk update now, we will wait some more.
                setTimeout(this.processPendingChunkUpdates.bind(this), this.chunkUpdateDelay);
                return;
            }
            var update = this.pendingChunkUpdates;
            var rpc = this.rpc;

            var source = rpc.get(update['source']);
            if (DEBUG_CHUNK_UPDATES) {
                console.log(`${ Date.now() } Chunk.update processed: ${ source.rpcId } ${ update['id'] } ${ update['state'] }`);
            }
            var newState = update['state'];
            if (newState === base_1.ChunkState.EXPIRED) {
                // FIXME: maybe use freeList for chunks here
                source.deleteChunk(update['id']);
            } else {
                var chunk = void 0;
                var key = update['id'];
                if (update['new']) {
                    chunk = source.getChunk(update);
                    source.addChunk(key, chunk);
                } else {
                    chunk = source.chunks.get(key);
                }
                var oldState = chunk.state;
                if (newState !== oldState) {
                    switch (newState) {
                        case base_1.ChunkState.GPU_MEMORY:
                            // console.log("Copying to GPU", chunk);
                            chunk.copyToGPU(this.gl);
                            this.visibleChunksChanged.dispatch();
                            break;
                        case base_1.ChunkState.SYSTEM_MEMORY:
                            chunk.freeGPUMemory(this.gl);
                            break;
                        default:
                            throw new Error(`INTERNAL ERROR: Invalid chunk state: ${ base_1.ChunkState[newState] }`);
                    }
                }
            }
            var nextUpdate = this.pendingChunkUpdates = update.nextUpdate;
            if (nextUpdate != null) {
                this.scheduleChunkUpdate();
            } else {
                this.pendingChunkUpdatesTail = null;
            }
        }
    }]);

    return ChunkQueueManager;
}(worker_rpc_1.SharedObject);
ChunkQueueManager = __decorate([worker_rpc_1.registerSharedObjectOwner(base_1.CHUNK_QUEUE_MANAGER_RPC_ID)], ChunkQueueManager);
exports.ChunkQueueManager = ChunkQueueManager;
;
worker_rpc_1.registerRPC('Chunk.update', function (x) {
    var source = this.get(x['source']);
    if (DEBUG_CHUNK_UPDATES) {
        console.log(`${ Date.now() } Chunk.update received: ${ source.rpcId } ${ x['id'] } ${ x['state'] } with chunkDataSize ${ x['chunkDataSize'] }`);
    }
    var queueManager = source.chunkManager.chunkQueueManager;
    var pendingTail = queueManager.pendingChunkUpdatesTail;
    if (pendingTail == null) {
        queueManager.pendingChunkUpdates = x;
        queueManager.pendingChunkUpdatesTail = x;
        queueManager.scheduleChunkUpdate();
    } else {
        pendingTail.nextUpdate = x;
        queueManager.pendingChunkUpdatesTail = x;
    }
});
var ChunkManager = function (_worker_rpc_1$SharedO2) {
    _inherits(ChunkManager, _worker_rpc_1$SharedO2);

    function ChunkManager(chunkQueueManager) {
        _classCallCheck(this, ChunkManager);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ChunkManager).call(this));

        _this2.chunkQueueManager = chunkQueueManager;
        _this2.chunkSourceCache = new Map();
        _this2.registerDisposer(chunkQueueManager.addRef());
        _this2.initializeCounterpart(chunkQueueManager.rpc, { 'chunkQueueManager': chunkQueueManager.rpcId });
        return _this2;
    }

    _createClass(ChunkManager, [{
        key: "getChunkSource",
        value: function getChunkSource(constructor, key, getter) {
            var chunkSourceCache = this.chunkSourceCache;

            var sources = chunkSourceCache.get(constructor);
            if (sources === undefined) {
                sources = new memoize_1.Memoize();
                chunkSourceCache.set(constructor, sources);
            }
            return sources.get(key, () => {
                var value = getter();
                value.initializeCounterpart(value.chunkManager.rpc, {});
                return value;
            });
        }
    }]);

    return ChunkManager;
}(worker_rpc_1.SharedObject);
ChunkManager = __decorate([worker_rpc_1.registerSharedObjectOwner(base_1.CHUNK_MANAGER_RPC_ID)], ChunkManager);
exports.ChunkManager = ChunkManager;
;

var ChunkSource = function (_worker_rpc_1$SharedO3) {
    _inherits(ChunkSource, _worker_rpc_1$SharedO3);

    function ChunkSource(chunkManager) {
        _classCallCheck(this, ChunkSource);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(ChunkSource).call(this));

        _this3.chunkManager = chunkManager;
        _this3.chunks = new Map();
        _this3.registerDisposer(chunkManager.addRef());
        return _this3;
    }

    _createClass(ChunkSource, [{
        key: "initializeCounterpart",
        value: function initializeCounterpart(rpc, options) {
            options['chunkManager'] = this.chunkManager.rpcId;
            _get(Object.getPrototypeOf(ChunkSource.prototype), "initializeCounterpart", this).call(this, rpc, options);
        }
    }, {
        key: "deleteChunk",
        value: function deleteChunk(key) {
            this.chunks.delete(key);
        }
    }, {
        key: "addChunk",
        value: function addChunk(key, chunk) {
            this.chunks.set(key, chunk);
        }
        /**
         * Default implementation for use with backendOnly chunk sources.
         */

    }, {
        key: "getChunk",
        value: function getChunk(x) {
            throw new Error('Not implemented.');
        }
    }, {
        key: "gl",
        get: function () {
            return this.chunkManager.chunkQueueManager.gl;
        }
    }]);

    return ChunkSource;
}(worker_rpc_1.SharedObject);

exports.ChunkSource = ChunkSource;
;

/***/ },
/* 33 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Memoize = function () {
    function Memoize() {
        _classCallCheck(this, Memoize);

        this.map = new Map();
    }
    /**
     * If getter throws an exception, no value is added.
     */


    _createClass(Memoize, [{
        key: "get",
        value: function get(key, getter) {
            var map = this.map;

            var obj = map.get(key);
            if (obj === undefined) {
                obj = getter();
                obj.registerDisposer(() => {
                    map.delete(key);
                });
                map.set(key, obj);
            } else {
                obj.addRef();
            }
            return obj;
        }
    }]);

    return Memoize;
}();

exports.Memoize = Memoize;
;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(true){ //AMD
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return signals; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));


/***/ },
/* 35 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

exports.MESH_LAYER_RPC_ID = 'mesh/MeshLayer';
exports.FRAGMENT_SOURCE_RPC_ID = 'mesh/FragmentSource';

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var axes_lines_1 = __webpack_require__(37);
var layer_1 = __webpack_require__(42);
var layer_2 = __webpack_require__(42);
var object_picking_1 = __webpack_require__(54);
var rendered_data_panel_1 = __webpack_require__(55);
var frontend_1 = __webpack_require__(60);
var trackable_boolean_1 = __webpack_require__(70);
var geom_1 = __webpack_require__(9);
var mouse_drag_1 = __webpack_require__(71);
var offscreen_1 = __webpack_require__(68);
var shader_lib_1 = __webpack_require__(72);
__webpack_require__(73);
__webpack_require__(74);

var PerspectiveViewRenderLayer = function (_layer_1$VisibilityTr) {
    _inherits(PerspectiveViewRenderLayer, _layer_1$VisibilityTr);

    function PerspectiveViewRenderLayer() {
        _classCallCheck(this, PerspectiveViewRenderLayer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PerspectiveViewRenderLayer).apply(this, arguments));
    }

    _createClass(PerspectiveViewRenderLayer, [{
        key: 'draw',
        value: function draw(renderContext) {
            // Must be overridden by subclasses.
        }
    }, {
        key: 'drawPicking',
        value: function drawPicking(renderContext) {
            // Do nothing by default.
        }
    }]);

    return PerspectiveViewRenderLayer;
}(layer_1.VisibilityTrackedRenderLayer);

exports.PerspectiveViewRenderLayer = PerspectiveViewRenderLayer;
;
(function (OffscreenTextures) {
    OffscreenTextures[OffscreenTextures["COLOR"] = 0] = "COLOR";
    OffscreenTextures[OffscreenTextures["Z"] = 1] = "Z";
    OffscreenTextures[OffscreenTextures["PICK"] = 2] = "PICK";
    OffscreenTextures[OffscreenTextures["NUM_TEXTURES"] = 3] = "NUM_TEXTURES";
})(exports.OffscreenTextures || (exports.OffscreenTextures = {}));
var OffscreenTextures = exports.OffscreenTextures;
exports.glsl_perspectivePanelEmit = [shader_lib_1.glsl_packFloat01ToFixedPoint, `
void emit(vec4 color, vec4 pickId) {
  gl_FragData[${ OffscreenTextures.COLOR }] = color;
  gl_FragData[${ OffscreenTextures.Z }] = packFloat01ToFixedPoint(1.0 - gl_FragCoord.z);
  gl_FragData[${ OffscreenTextures.PICK }] = pickId;
}
`];
function perspectivePanelEmit(builder) {
    builder.addFragmentExtension('GL_EXT_draw_buffers');
    builder.addFragmentCode(exports.glsl_perspectivePanelEmit);
}
exports.perspectivePanelEmit = perspectivePanelEmit;
var tempVec3 = geom_1.vec3.create();
var tempMat4 = geom_1.mat4.create();

var PerspectivePanel = function (_rendered_data_panel_) {
    _inherits(PerspectivePanel, _rendered_data_panel_);

    function PerspectivePanel(context, element, viewer) {
        _classCallCheck(this, PerspectivePanel);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(PerspectivePanel).call(this, context, element, viewer));

        _this2.visibleLayerTracker = layer_2.makeRenderedPanelVisibleLayerTracker(_this2.viewer.layerManager, PerspectiveViewRenderLayer, _this2);
        _this2.sliceViews = new Set();
        _this2.projectionMat = geom_1.mat4.create();
        _this2.inverseProjectionMat = geom_1.mat4.create();
        _this2.modelViewMat = geom_1.mat4.create();
        _this2.width = 0;
        _this2.height = 0;
        _this2.pickIDs = new object_picking_1.PickIDManager();
        _this2.axesLineHelper = _this2.registerDisposer(axes_lines_1.AxesLineHelper.get(_this2.gl));
        _this2.sliceViewRenderHelper = _this2.registerDisposer(frontend_1.SliceViewRenderHelper.get(_this2.gl, 'SliceViewRenderHelper:PerspectivePanel', perspectivePanelEmit));
        _this2.offscreenFramebuffer = new offscreen_1.OffscreenFramebuffer(_this2.gl, { numDataBuffers: OffscreenTextures.NUM_TEXTURES, depthBuffer: true, stencilBuffer: true });
        _this2.offscreenCopyHelper = offscreen_1.OffscreenCopyHelper.get(_this2.gl);
        _this2.registerSignalBinding(_this2.navigationState.changed.add(() => {
            _this2.viewportChanged();
        }));
        var showSliceViewsCheckbox = _this2.registerDisposer(new trackable_boolean_1.TrackableBooleanCheckbox(viewer.showSliceViews));
        showSliceViewsCheckbox.element.className = 'perspective-panel-show-slice-views noselect';
        var showSliceViewsLabel = document.createElement('label');
        showSliceViewsLabel.className = 'perspective-panel-show-slice-views noselect';
        showSliceViewsLabel.appendChild(document.createTextNode('Slices'));
        showSliceViewsLabel.appendChild(showSliceViewsCheckbox.element);
        _this2.element.appendChild(showSliceViewsLabel);
        _this2.registerSignalBinding(viewer.showSliceViews.changed.add(() => {
            _this2.scheduleRedraw();
        }));
        _this2.registerSignalBinding(viewer.showAxisLines.changed.add(() => {
            _this2.scheduleRedraw();
        }));
        return _this2;
    }

    _createClass(PerspectivePanel, [{
        key: 'updateProjectionMatrix',
        value: function updateProjectionMatrix() {
            var projectionMat = this.projectionMat;
            geom_1.mat4.perspective(projectionMat, Math.PI / 4.0, this.width / this.height, 10, 5000);
            var modelViewMat = this.modelViewMat;
            this.navigationState.toMat4(modelViewMat);
            geom_1.vec3.set(tempVec3, 1, -1, -1);
            geom_1.mat4.scale(modelViewMat, modelViewMat, tempVec3);
            var viewOffset = geom_1.vec3.set(tempVec3, 0, 0, 100);
            geom_1.mat4.translate(modelViewMat, modelViewMat, viewOffset);
            var modelViewMatInv = tempMat4;
            geom_1.mat4.invert(modelViewMatInv, modelViewMat);
            geom_1.mat4.multiply(projectionMat, projectionMat, modelViewMatInv);
            geom_1.mat4.invert(this.inverseProjectionMat, projectionMat);
        }
    }, {
        key: 'viewportChanged',
        value: function viewportChanged() {
            this.context.scheduleRedraw();
        }
    }, {
        key: 'onResize',
        value: function onResize() {
            this.width = this.element.clientWidth;
            this.height = this.element.clientHeight;
            this.viewportChanged();
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            for (var sliceView of this.sliceViews) {
                sliceView.dispose();
            }
            this.sliceViews.clear();
            _get(Object.getPrototypeOf(PerspectivePanel.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'updateMouseState',
        value: function updateMouseState(mouseState) {
            mouseState.pickedRenderLayer = null;
            if (!this.navigationState.valid) {
                return false;
            }
            var out = mouseState.position;
            var offscreenFramebuffer = this.offscreenFramebuffer;
            var width = this.width;
            var height = this.height;

            if (!offscreenFramebuffer.hasSize(width, height)) {
                return false;
            }
            var glWindowX = this.mouseX;
            var glWindowY = height - this.mouseY;
            var zData = offscreenFramebuffer.readPixel(OffscreenTextures.Z, glWindowX, glWindowY);
            var glWindowZ = 1.0 - shader_lib_1.unpackFloat01FromFixedPoint(zData);
            if (glWindowZ === 1.0) {
                return false;
            }
            out[0] = 2.0 * glWindowX / width - 1.0;
            out[1] = 2.0 * glWindowY / height - 1.0;
            out[2] = 2.0 * glWindowZ - 1.0;
            geom_1.vec3.transformMat4(out, out, this.inverseProjectionMat);
            this.pickIDs.setMouseState(mouseState, offscreenFramebuffer.readPixelAsUint32(OffscreenTextures.PICK, glWindowX, glWindowY));
            return true;
        }
    }, {
        key: 'onMousedown',
        value: function onMousedown(e) {
            if (e.target !== this.element) {
                return;
            }
            _get(Object.getPrototypeOf(PerspectivePanel.prototype), 'onMousedown', this).call(this, e);
            if (!this.navigationState.valid) {
                return;
            }
            if (e.button === 0) {
                mouse_drag_1.startRelativeMouseDrag(e, (event, deltaX, deltaY) => {
                    this.navigationState.pose.rotateRelative(geom_1.kAxes[1], -deltaX / 4.0 * Math.PI / 180.0);
                    this.navigationState.pose.rotateRelative(geom_1.kAxes[0], deltaY / 4.0 * Math.PI / 180.0);
                    this.viewer.navigationState.changed.dispatch();
                });
            }
        }
    }, {
        key: 'draw',
        value: function draw() {
            var width = this.width;
            var height = this.height;

            if (!this.navigationState.valid || width === 0 || height === 0) {
                return;
            }
            for (var sliceView of this.sliceViews) {
                sliceView.updateRendering();
            }
            var gl = this.gl;
            this.offscreenFramebuffer.bind(width, height);
            gl.disable(gl.SCISSOR_TEST);
            this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            var projectionMat = this.projectionMat;

            this.updateProjectionMatrix();
            // FIXME; avoid temporaries
            var lightingDirection = geom_1.vec4.create();
            geom_1.vec4.transformMat4(lightingDirection, geom_1.kAxes[2], this.modelViewMat);
            geom_1.vec4.normalize(lightingDirection, lightingDirection);
            var ambient = 0.2;
            var directional = 1 - ambient;
            var pickIDs = this.pickIDs;
            pickIDs.clear();
            var renderContext = {
                dataToDevice: projectionMat,
                lightDirection: lightingDirection.subarray(0, 3),
                ambientLighting: ambient,
                directionalLighting: directional,
                pickIDs: pickIDs
            };
            var visibleLayers = this.visibleLayerTracker.getVisibleLayers();
            for (var renderLayer of visibleLayers) {
                renderLayer.draw(renderContext);
            }
            if (this.viewer.showSliceViews.value) {
                var sliceViewRenderHelper = this.sliceViewRenderHelper;

                for (var _sliceView of this.sliceViews) {
                    var scalar = Math.abs(geom_1.vec3.dot(lightingDirection, _sliceView.viewportAxes[2]));
                    var factor = ambient + scalar * directional;
                    var mat = tempMat4;
                    // Need a matrix that maps (+1, +1, 0) to projectionMat * (width, height, 0)
                    geom_1.mat4.identity(mat);
                    mat[0] = _sliceView.width / 2.0;
                    mat[5] = -_sliceView.height / 2.0;
                    geom_1.mat4.multiply(mat, _sliceView.viewportToData, mat);
                    geom_1.mat4.multiply(mat, projectionMat, mat);
                    sliceViewRenderHelper.draw(_sliceView.offscreenFramebuffer.dataTextures[0], mat, geom_1.vec4.fromValues(factor, factor, factor, 1), geom_1.vec4.fromValues(0.5, 0.5, 0.5, 1), 0, 0, 1, 1);
                }
            }
            if (this.viewer.showAxisLines.value) {
                var _mat = tempMat4;
                geom_1.mat4.identity(_mat);
                // Draw axes lines.
                var axisLength = 200 * 8;
                // Construct matrix that maps [-1, +1] x/y range to the full viewport data
                // coordinates.
                _mat[0] = axisLength;
                _mat[5] = axisLength;
                _mat[10] = axisLength;
                var center = this.navigationState.position.spatialCoordinates;
                _mat[12] = center[0];
                _mat[13] = center[1];
                _mat[14] = center[2];
                _mat[15] = 1;
                geom_1.mat4.multiply(_mat, projectionMat, _mat);
                gl.WEBGL_draw_buffers.drawBuffersWEBGL([gl.WEBGL_draw_buffers.COLOR_ATTACHMENT0_WEBGL]);
                this.axesLineHelper.draw(_mat, false);
            }
            // Do picking only rendering pass.
            gl.WEBGL_draw_buffers.drawBuffersWEBGL([gl.NONE, gl.WEBGL_draw_buffers.COLOR_ATTACHMENT1_WEBGL, gl.WEBGL_draw_buffers.COLOR_ATTACHMENT2_WEBGL]);
            for (var _renderLayer of visibleLayers) {
                _renderLayer.drawPicking(renderContext);
            }
            gl.disable(gl.DEPTH_TEST);
            this.offscreenFramebuffer.unbind();
            // Draw the texture over the whole viewport.
            this.setGLViewport();
            this.offscreenCopyHelper.draw(this.offscreenFramebuffer.dataTextures[OffscreenTextures.COLOR]);
        }
    }, {
        key: 'zoomByMouse',
        value: function zoomByMouse(factor) {
            this.navigationState.zoomBy(factor);
        }
    }, {
        key: 'navigationState',
        get: function () {
            return this.viewer.navigationState;
        }
    }]);

    return PerspectivePanel;
}(rendered_data_panel_1.RenderedDataPanel);

exports.PerspectivePanel = PerspectivePanel;
;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var buffer_1 = __webpack_require__(38);
var trivial_shaders_1 = __webpack_require__(40);

var AxesLineHelper = function (_disposable_1$RefCoun) {
    _inherits(AxesLineHelper, _disposable_1$RefCoun);

    function AxesLineHelper(gl) {
        _classCallCheck(this, AxesLineHelper);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AxesLineHelper).call(this));

        _this.gl = gl;
        _this.vertexBuffer = _this.registerDisposer(buffer_1.Buffer.fromData(gl, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
        var alpha = 0.5;
        _this.colorBuffer = _this.registerDisposer(buffer_1.Buffer.fromData(gl, new Float32Array([1, 0, 0, alpha, 1, 0, 0, alpha, 0, 1, 0, alpha, 0, 1, 0, alpha, 0, 0, 1, alpha, 0, 0, 1, alpha]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
        _this.trivialColorShader = _this.registerDisposer(trivial_shaders_1.trivialColorShader(gl));
        return _this;
    }

    _createClass(AxesLineHelper, [{
        key: 'draw',
        value: function draw(mat) {
            var blend = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

            var shader = this.trivialColorShader;
            var gl = this.gl;
            shader.bind();
            gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, mat);
            var aVertexPosition = shader.attribute('aVertexPosition');
            this.vertexBuffer.bindToVertexAttrib(aVertexPosition, 4);
            var aColor = shader.attribute('aColor');
            this.colorBuffer.bindToVertexAttrib(aColor, 4);
            if (blend) {
                gl.colorMask(false, false, false, true);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.colorMask(true, true, true, true);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.DST_ALPHA);
            }
            gl.lineWidth(1);
            gl.drawArrays(gl.LINES, 0, 6);
            if (blend) {
                gl.disable(gl.BLEND);
            }
            gl.disableVertexAttribArray(aVertexPosition);
            gl.disableVertexAttribArray(aColor);
        }
    }], [{
        key: 'get',
        value: function get(gl) {
            return gl.memoize.get('SliceViewPanel:AxesLineHelper', () => new AxesLineHelper(gl));
        }
    }]);

    return AxesLineHelper;
}(disposable_1.RefCounted);

exports.AxesLineHelper = AxesLineHelper;
;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var constants_1 = __webpack_require__(39);

var Buffer = function () {
    function Buffer(gl) {
        var bufferType = arguments.length <= 1 || arguments[1] === undefined ? constants_1.GL_ARRAY_BUFFER : arguments[1];

        _classCallCheck(this, Buffer);

        this.gl = gl;
        this.bufferType = bufferType;
        this.gl = gl;
        // This should never return null.
        this.buffer = gl.createBuffer();
    }

    _createClass(Buffer, [{
        key: "bind",
        value: function bind() {
            this.gl.bindBuffer(this.bufferType, this.buffer);
        }
    }, {
        key: "bindToVertexAttrib",
        value: function bindToVertexAttrib(location, componentsPerVertexAttribute) {
            var attributeType = arguments.length <= 2 || arguments[2] === undefined ? constants_1.GL_FLOAT : arguments[2];
            var normalized = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
            var stride = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
            var offset = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];

            this.bind();
            this.gl.enableVertexAttribArray(location);
            this.gl.vertexAttribPointer(location, componentsPerVertexAttribute, attributeType, normalized, stride, offset);
        }
    }, {
        key: "setData",
        value: function setData(data) {
            var usage = arguments.length <= 1 || arguments[1] === undefined ? constants_1.GL_STATIC_DRAW : arguments[1];

            var gl = this.gl;
            this.bind();
            gl.bufferData(this.bufferType, data, usage);
        }
    }, {
        key: "dispose",
        value: function dispose() {
            this.gl.deleteBuffer(this.buffer);
            this.buffer = undefined;
            this.gl = undefined;
        }
    }], [{
        key: "fromData",
        value: function fromData(gl, data, bufferType, usage) {
            var buffer = new Buffer(gl, bufferType);
            buffer.setData(data, usage);
            return buffer;
        }
    }]);

    return Buffer;
}();

exports.Buffer = Buffer;
;

/***/ },
/* 39 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * This contains the WebGLRenderingContext constants defined in
 * https://www.khronos.org/registry/webgl/specs/latest/1.0/
 */
/* ClearBufferMask */

exports.GL_DEPTH_BUFFER_BIT = 0x00000100;
exports.GL_STENCIL_BUFFER_BIT = 0x00000400;
exports.GL_COLOR_BUFFER_BIT = 0x00004000;
/* BeginMode */
exports.GL_POINTS = 0x0000;
exports.GL_LINES = 0x0001;
exports.GL_LINE_LOOP = 0x0002;
exports.GL_LINE_STRIP = 0x0003;
exports.GL_TRIANGLES = 0x0004;
exports.GL_TRIANGLE_STRIP = 0x0005;
exports.GL_TRIANGLE_FAN = 0x0006;
/* AlphaFunction (not supported in ES20) */
/*      NEVER */
/*      LESS */
/*      EQUAL */
/*      LEQUAL */
/*      GREATER */
/*      NOTEQUAL */
/*      GEQUAL */
/*      ALWAYS */
/* BlendingFactorDest */
exports.GL_ZERO = 0;
exports.GL_ONE = 1;
exports.GL_SRC_COLOR = 0x0300;
exports.GL_ONE_MINUS_SRC_COLOR = 0x0301;
exports.GL_SRC_ALPHA = 0x0302;
exports.GL_ONE_MINUS_SRC_ALPHA = 0x0303;
exports.GL_DST_ALPHA = 0x0304;
exports.GL_ONE_MINUS_DST_ALPHA = 0x0305;
/* BlendingFactorSrc */
/*      ZERO */
/*      ONE */
exports.GL_DST_COLOR = 0x0306;
exports.GL_ONE_MINUS_DST_COLOR = 0x0307;
exports.GL_SRC_ALPHA_SATURATE = 0x0308;
/*      SRC_ALPHA */
/*      ONE_MINUS_SRC_ALPHA */
/*      DST_ALPHA */
/*      ONE_MINUS_DST_ALPHA */
/* BlendEquationSeparate */
exports.GL_FUNC_ADD = 0x8006;
exports.GL_BLEND_EQUATION = 0x8009;
exports.GL_BLEND_EQUATION_RGB = 0x8009; /* same as BLEND_EQUATION */
exports.GL_BLEND_EQUATION_ALPHA = 0x883D;
/* BlendSubtract */
exports.GL_FUNC_SUBTRACT = 0x800A;
exports.GL_FUNC_REVERSE_SUBTRACT = 0x800B;
/* Separate Blend Functions */
exports.GL_BLEND_DST_RGB = 0x80C8;
exports.GL_BLEND_SRC_RGB = 0x80C9;
exports.GL_BLEND_DST_ALPHA = 0x80CA;
exports.GL_BLEND_SRC_ALPHA = 0x80CB;
exports.GL_CONSTANT_COLOR = 0x8001;
exports.GL_ONE_MINUS_CONSTANT_COLOR = 0x8002;
exports.GL_CONSTANT_ALPHA = 0x8003;
exports.GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004;
exports.GL_BLEND_COLOR = 0x8005;
/* Buffer Objects */
exports.GL_ARRAY_BUFFER = 0x8892;
exports.GL_ELEMENT_ARRAY_BUFFER = 0x8893;
exports.GL_ARRAY_BUFFER_BINDING = 0x8894;
exports.GL_ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
exports.GL_STREAM_DRAW = 0x88E0;
exports.GL_STATIC_DRAW = 0x88E4;
exports.GL_DYNAMIC_DRAW = 0x88E8;
exports.GL_BUFFER_SIZE = 0x8764;
exports.GL_BUFFER_USAGE = 0x8765;
exports.GL_CURRENT_VERTEX_ATTRIB = 0x8626;
/* CullFaceMode */
exports.GL_FRONT = 0x0404;
exports.GL_BACK = 0x0405;
exports.GL_FRONT_AND_BACK = 0x0408;
/* DepthFunction */
/*      NEVER */
/*      LESS */
/*      EQUAL */
/*      LEQUAL */
/*      GREATER */
/*      NOTEQUAL */
/*      GEQUAL */
/*      ALWAYS */
/* EnableCap */
/* TEXTURE_2D */
exports.GL_CULL_FACE = 0x0B44;
exports.GL_BLEND = 0x0BE2;
exports.GL_DITHER = 0x0BD0;
exports.GL_STENCIL_TEST = 0x0B90;
exports.GL_DEPTH_TEST = 0x0B71;
exports.GL_SCISSOR_TEST = 0x0C11;
exports.GL_POLYGON_OFFSET_FILL = 0x8037;
exports.GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
exports.GL_SAMPLE_COVERAGE = 0x80A0;
/* ErrorCode */
exports.GL_NO_ERROR = 0;
exports.GL_INVALID_ENUM = 0x0500;
exports.GL_INVALID_VALUE = 0x0501;
exports.GL_INVALID_OPERATION = 0x0502;
exports.GL_OUT_OF_MEMORY = 0x0505;
/* FrontFaceDirection */
exports.GL_CW = 0x0900;
exports.GL_CCW = 0x0901;
/* GetPName */
exports.GL_LINE_WIDTH = 0x0B21;
exports.GL_ALIASED_POINT_SIZE_RANGE = 0x846D;
exports.GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;
exports.GL_CULL_FACE_MODE = 0x0B45;
exports.GL_FRONT_FACE = 0x0B46;
exports.GL_DEPTH_RANGE = 0x0B70;
exports.GL_DEPTH_WRITEMASK = 0x0B72;
exports.GL_DEPTH_CLEAR_VALUE = 0x0B73;
exports.GL_DEPTH_FUNC = 0x0B74;
exports.GL_STENCIL_CLEAR_VALUE = 0x0B91;
exports.GL_STENCIL_FUNC = 0x0B92;
exports.GL_STENCIL_FAIL = 0x0B94;
exports.GL_STENCIL_PASS_DEPTH_FAIL = 0x0B95;
exports.GL_STENCIL_PASS_DEPTH_PASS = 0x0B96;
exports.GL_STENCIL_REF = 0x0B97;
exports.GL_STENCIL_VALUE_MASK = 0x0B93;
exports.GL_STENCIL_WRITEMASK = 0x0B98;
exports.GL_STENCIL_BACK_FUNC = 0x8800;
exports.GL_STENCIL_BACK_FAIL = 0x8801;
exports.GL_STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
exports.GL_STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
exports.GL_STENCIL_BACK_REF = 0x8CA3;
exports.GL_STENCIL_BACK_VALUE_MASK = 0x8CA4;
exports.GL_STENCIL_BACK_WRITEMASK = 0x8CA5;
exports.GL_VIEWPORT = 0x0BA2;
exports.GL_SCISSOR_BOX = 0x0C10;
/*      SCISSOR_TEST */
exports.GL_COLOR_CLEAR_VALUE = 0x0C22;
exports.GL_COLOR_WRITEMASK = 0x0C23;
exports.GL_UNPACK_ALIGNMENT = 0x0CF5;
exports.GL_PACK_ALIGNMENT = 0x0D05;
exports.GL_MAX_TEXTURE_SIZE = 0x0D33;
exports.GL_MAX_VIEWPORT_DIMS = 0x0D3A;
exports.GL_SUBPIXEL_BITS = 0x0D50;
exports.GL_RED_BITS = 0x0D52;
exports.GL_GREEN_BITS = 0x0D53;
exports.GL_BLUE_BITS = 0x0D54;
exports.GL_ALPHA_BITS = 0x0D55;
exports.GL_DEPTH_BITS = 0x0D56;
exports.GL_STENCIL_BITS = 0x0D57;
exports.GL_POLYGON_OFFSET_UNITS = 0x2A00;
/*      POLYGON_OFFSET_FILL */
exports.GL_POLYGON_OFFSET_FACTOR = 0x8038;
exports.GL_TEXTURE_BINDING_2D = 0x8069;
exports.GL_SAMPLE_BUFFERS = 0x80A8;
exports.GL_SAMPLES = 0x80A9;
exports.GL_SAMPLE_COVERAGE_VALUE = 0x80AA;
exports.GL_SAMPLE_COVERAGE_INVERT = 0x80AB;
/* GetTextureParameter */
/*      TEXTURE_MAG_FILTER */
/*      TEXTURE_MIN_FILTER */
/*      TEXTURE_WRAP_S */
/*      TEXTURE_WRAP_T */
exports.GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;
/* HintMode */
exports.GL_DONT_CARE = 0x1100;
exports.GL_FASTEST = 0x1101;
exports.GL_NICEST = 0x1102;
/* HintTarget */
exports.GL_GENERATE_MIPMAP_HINT = 0x8192;
/* DataType */
exports.GL_BYTE = 0x1400;
exports.GL_UNSIGNED_BYTE = 0x1401;
exports.GL_SHORT = 0x1402;
exports.GL_UNSIGNED_SHORT = 0x1403;
exports.GL_INT = 0x1404;
exports.GL_UNSIGNED_INT = 0x1405;
exports.GL_FLOAT = 0x1406;
/* PixelFormat */
exports.GL_DEPTH_COMPONENT = 0x1902;
exports.GL_ALPHA = 0x1906;
exports.GL_RGB = 0x1907;
exports.GL_RGBA = 0x1908;
exports.GL_LUMINANCE = 0x1909;
exports.GL_LUMINANCE_ALPHA = 0x190A;
/* PixelType */
/*      UNSIGNED_BYTE */
exports.GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
exports.GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
exports.GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
/* Shaders */
exports.GL_FRAGMENT_SHADER = 0x8B30;
exports.GL_VERTEX_SHADER = 0x8B31;
exports.GL_MAX_VERTEX_ATTRIBS = 0x8869;
exports.GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
exports.GL_MAX_VARYING_VECTORS = 0x8DFC;
exports.GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
exports.GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
exports.GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
exports.GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
exports.GL_SHADER_TYPE = 0x8B4F;
exports.GL_DELETE_STATUS = 0x8B80;
exports.GL_LINK_STATUS = 0x8B82;
exports.GL_VALIDATE_STATUS = 0x8B83;
exports.GL_ATTACHED_SHADERS = 0x8B85;
exports.GL_ACTIVE_UNIFORMS = 0x8B86;
exports.GL_ACTIVE_ATTRIBUTES = 0x8B89;
exports.GL_SHADING_LANGUAGE_VERSION = 0x8B8C;
exports.GL_CURRENT_PROGRAM = 0x8B8D;
/* StencilFunction */
exports.GL_NEVER = 0x0200;
exports.GL_LESS = 0x0201;
exports.GL_EQUAL = 0x0202;
exports.GL_LEQUAL = 0x0203;
exports.GL_GREATER = 0x0204;
exports.GL_NOTEQUAL = 0x0205;
exports.GL_GEQUAL = 0x0206;
exports.GL_ALWAYS = 0x0207;
/* StencilOp */
/*      ZERO */
exports.GL_KEEP = 0x1E00;
exports.GL_REPLACE = 0x1E01;
exports.GL_INCR = 0x1E02;
exports.GL_DECR = 0x1E03;
exports.GL_INVERT = 0x150A;
exports.GL_INCR_WRAP = 0x8507;
exports.GL_DECR_WRAP = 0x8508;
/* StringName */
exports.GL_VENDOR = 0x1F00;
exports.GL_RENDERER = 0x1F01;
exports.GL_VERSION = 0x1F02;
/* TextureMagFilter */
exports.GL_NEAREST = 0x2600;
exports.GL_LINEAR = 0x2601;
/* TextureMinFilter */
/*      NEAREST */
/*      LINEAR */
exports.GL_NEAREST_MIPMAP_NEAREST = 0x2700;
exports.GL_LINEAR_MIPMAP_NEAREST = 0x2701;
exports.GL_NEAREST_MIPMAP_LINEAR = 0x2702;
exports.GL_LINEAR_MIPMAP_LINEAR = 0x2703;
/* TextureParameterName */
exports.GL_TEXTURE_MAG_FILTER = 0x2800;
exports.GL_TEXTURE_MIN_FILTER = 0x2801;
exports.GL_TEXTURE_WRAP_S = 0x2802;
exports.GL_TEXTURE_WRAP_T = 0x2803;
/* TextureTarget */
exports.GL_TEXTURE_2D = 0x0DE1;
exports.GL_TEXTURE = 0x1702;
exports.GL_TEXTURE_CUBE_MAP = 0x8513;
exports.GL_TEXTURE_BINDING_CUBE_MAP = 0x8514;
exports.GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
exports.GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
exports.GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
exports.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
exports.GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
exports.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
exports.GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
/* TextureUnit */
exports.GL_TEXTURE0 = 0x84C0;
exports.GL_TEXTURE1 = 0x84C1;
exports.GL_TEXTURE2 = 0x84C2;
exports.GL_TEXTURE3 = 0x84C3;
exports.GL_TEXTURE4 = 0x84C4;
exports.GL_TEXTURE5 = 0x84C5;
exports.GL_TEXTURE6 = 0x84C6;
exports.GL_TEXTURE7 = 0x84C7;
exports.GL_TEXTURE8 = 0x84C8;
exports.GL_TEXTURE9 = 0x84C9;
exports.GL_TEXTURE10 = 0x84CA;
exports.GL_TEXTURE11 = 0x84CB;
exports.GL_TEXTURE12 = 0x84CC;
exports.GL_TEXTURE13 = 0x84CD;
exports.GL_TEXTURE14 = 0x84CE;
exports.GL_TEXTURE15 = 0x84CF;
exports.GL_TEXTURE16 = 0x84D0;
exports.GL_TEXTURE17 = 0x84D1;
exports.GL_TEXTURE18 = 0x84D2;
exports.GL_TEXTURE19 = 0x84D3;
exports.GL_TEXTURE20 = 0x84D4;
exports.GL_TEXTURE21 = 0x84D5;
exports.GL_TEXTURE22 = 0x84D6;
exports.GL_TEXTURE23 = 0x84D7;
exports.GL_TEXTURE24 = 0x84D8;
exports.GL_TEXTURE25 = 0x84D9;
exports.GL_TEXTURE26 = 0x84DA;
exports.GL_TEXTURE27 = 0x84DB;
exports.GL_TEXTURE28 = 0x84DC;
exports.GL_TEXTURE29 = 0x84DD;
exports.GL_TEXTURE30 = 0x84DE;
exports.GL_TEXTURE31 = 0x84DF;
exports.GL_ACTIVE_TEXTURE = 0x84E0;
/* TextureWrapMode */
exports.GL_REPEAT = 0x2901;
exports.GL_CLAMP_TO_EDGE = 0x812F;
exports.GL_MIRRORED_REPEAT = 0x8370;
/* Uniform Types */
exports.GL_FLOAT_VEC2 = 0x8B50;
exports.GL_FLOAT_VEC3 = 0x8B51;
exports.GL_FLOAT_VEC4 = 0x8B52;
exports.GL_INT_VEC2 = 0x8B53;
exports.GL_INT_VEC3 = 0x8B54;
exports.GL_INT_VEC4 = 0x8B55;
exports.GL_BOOL = 0x8B56;
exports.GL_BOOL_VEC2 = 0x8B57;
exports.GL_BOOL_VEC3 = 0x8B58;
exports.GL_BOOL_VEC4 = 0x8B59;
exports.GL_FLOAT_MAT2 = 0x8B5A;
exports.GL_FLOAT_MAT3 = 0x8B5B;
exports.GL_FLOAT_MAT4 = 0x8B5C;
exports.GL_SAMPLER_2D = 0x8B5E;
exports.GL_SAMPLER_CUBE = 0x8B60;
/* Vertex Arrays */
exports.GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
exports.GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
exports.GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
exports.GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
exports.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
exports.GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
exports.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
/* Read Format */
exports.GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;
exports.GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
/* Shader Source */
exports.GL_COMPILE_STATUS = 0x8B81;
/* Shader Precision-Specified Types */
exports.GL_LOW_FLOAT = 0x8DF0;
exports.GL_MEDIUM_FLOAT = 0x8DF1;
exports.GL_HIGH_FLOAT = 0x8DF2;
exports.GL_LOW_INT = 0x8DF3;
exports.GL_MEDIUM_INT = 0x8DF4;
exports.GL_HIGH_INT = 0x8DF5;
/* Framebuffer Object. */
exports.GL_FRAMEBUFFER = 0x8D40;
exports.GL_RENDERBUFFER = 0x8D41;
exports.GL_RGBA4 = 0x8056;
exports.GL_RGB5_A1 = 0x8057;
exports.GL_RGB565 = 0x8D62;
exports.GL_DEPTH_COMPONENT16 = 0x81A5;
exports.GL_STENCIL_INDEX = 0x1901;
exports.GL_STENCIL_INDEX8 = 0x8D48;
exports.GL_DEPTH_STENCIL = 0x84F9;
exports.GL_RENDERBUFFER_WIDTH = 0x8D42;
exports.GL_RENDERBUFFER_HEIGHT = 0x8D43;
exports.GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
exports.GL_RENDERBUFFER_RED_SIZE = 0x8D50;
exports.GL_RENDERBUFFER_GREEN_SIZE = 0x8D51;
exports.GL_RENDERBUFFER_BLUE_SIZE = 0x8D52;
exports.GL_RENDERBUFFER_ALPHA_SIZE = 0x8D53;
exports.GL_RENDERBUFFER_DEPTH_SIZE = 0x8D54;
exports.GL_RENDERBUFFER_STENCIL_SIZE = 0x8D55;
exports.GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
exports.GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
exports.GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
exports.GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
exports.GL_COLOR_ATTACHMENT0 = 0x8CE0;
exports.GL_DEPTH_ATTACHMENT = 0x8D00;
exports.GL_STENCIL_ATTACHMENT = 0x8D20;
exports.GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;
exports.GL_NONE = 0;
exports.GL_FRAMEBUFFER_COMPLETE = 0x8CD5;
exports.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
exports.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
exports.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
exports.GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
exports.GL_FRAMEBUFFER_BINDING = 0x8CA6;
exports.GL_RENDERBUFFER_BINDING = 0x8CA7;
exports.GL_MAX_RENDERBUFFER_SIZE = 0x84E8;
exports.GL_INVALID_FRAMEBUFFER_OPERATION = 0x0506;
/* WebGL-specific enums */
exports.GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
exports.GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
exports.GL_CONTEXT_LOST_WEBGL = 0x9242;
exports.GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
exports.GL_BROWSER_DEFAULT_WEBGL = 0x9244;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var shader_1 = __webpack_require__(41);
function trivialTextureShader(gl) {
    return gl.memoize.get('trivialTextureShader', () => {
        var builder = new shader_1.ShaderBuilder(gl);
        builder.addVarying('vec2', 'vTexCoord');
        builder.addUniform('sampler2D', 'uSampler');
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.setFragmentMain('gl_FragColor = texture2D(uSampler, vTexCoord);');
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.addAttribute('vec2', 'aTexCoord');
        builder.setVertexMain('vTexCoord = aTexCoord; gl_Position = uProjectionMatrix * aVertexPosition;');
        return builder.build();
    });
}
exports.trivialTextureShader = trivialTextureShader;
function trivialColorShader(gl) {
    return gl.memoize.get('trivialColorShader', () => {
        var builder = new shader_1.ShaderBuilder(gl);
        builder.addVarying('vec4', 'vColor');
        builder.setFragmentMain('gl_FragColor = vColor;');
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.addAttribute('vec4', 'aColor');
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.setVertexMain('vColor = aColor; gl_Position = uProjectionMatrix * aVertexPosition;');
        return builder.build();
    });
}
exports.trivialColorShader = trivialColorShader;
function trivialUniformColorShader(gl) {
    return gl.memoize.get('trivialUniformColorShader', () => {
        var builder = new shader_1.ShaderBuilder(gl);
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.addUniform('vec4', 'uColor');
        builder.setFragmentMain('gl_FragColor = uColor;');
        builder.setVertexMain('gl_Position = uProjectionMatrix * aVertexPosition;');
        return builder.build();
    });
}
exports.trivialUniformColorShader = trivialUniformColorShader;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var constants_1 = __webpack_require__(39);
(function (ShaderType) {
    ShaderType[ShaderType["VERTEX"] = constants_1.GL_VERTEX_SHADER] = "VERTEX";
    ShaderType[ShaderType["FRAGMENT"] = constants_1.GL_FRAGMENT_SHADER] = "FRAGMENT";
})(exports.ShaderType || (exports.ShaderType = {}));
var ShaderType = exports.ShaderType;
/**
 * Parses the output of getShaderInfoLog into a list of messages.
 */
function parseShaderErrors(log) {
    log = log.replace('\0', '');
    var result = [];
    for (var line of log.split('\n')) {
        var m = line.match(/^ERROR:\s*(\d+):(\d+)\s*(.+)$/);
        if (m !== null) {
            result.push({ message: m[3].trim(), file: parseInt(m[1], 10), line: parseInt(m[2], 10) });
        } else {
            m = line.match(/^ERROR:\s*(.+)$/);
            if (m !== null) {
                result.push({ message: m[1] });
            } else {
                line = line.trim();
                if (line) {
                    result.push({ message: line });
                }
            }
        }
    }
    return result;
}
exports.parseShaderErrors = parseShaderErrors;

var ShaderCompilationError = function (_Error) {
    _inherits(ShaderCompilationError, _Error);

    function ShaderCompilationError(shaderType, source, log, errorMessages) {
        _classCallCheck(this, ShaderCompilationError);

        var message = `Error compiling ${ ShaderType[shaderType].toLowerCase() } shader: ${ log }`;

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ShaderCompilationError).call(this, message));

        _this.name = 'ShaderCompilationError';
        _this.log = log;
        _this.message = message;
        _this.shaderType = shaderType;
        _this.source = source;
        _this.errorMessages = errorMessages;
        return _this;
    }

    return ShaderCompilationError;
}(Error);

exports.ShaderCompilationError = ShaderCompilationError;
;

var ShaderLinkError = function (_Error2) {
    _inherits(ShaderLinkError, _Error2);

    function ShaderLinkError(vertexSource, fragmentSource, log) {
        _classCallCheck(this, ShaderLinkError);

        var message = `Error linking shader: ${ log }`;

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ShaderLinkError).call(this, message));

        _this2.name = 'ShaderLinkError';
        _this2.log = log;
        _this2.message = message;
        _this2.vertexSource = vertexSource;
        _this2.fragmentSource = fragmentSource;
        return _this2;
    }

    return ShaderLinkError;
}(Error);

exports.ShaderLinkError = ShaderLinkError;
;
function getShader(gl, source, shaderType) {
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var log = gl.getShaderInfoLog(shader) || '';
        throw new ShaderCompilationError(shaderType, source, log, parseShaderErrors(log));
    }
    return shader;
}
exports.getShader = getShader;

var ShaderProgram = function (_disposable_1$RefCoun) {
    _inherits(ShaderProgram, _disposable_1$RefCoun);

    function ShaderProgram(gl, vertexSource, fragmentSource, uniformNames, attributeNames) {
        _classCallCheck(this, ShaderProgram);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(ShaderProgram).call(this));

        _this3.gl = gl;
        _this3.vertexSource = vertexSource;
        _this3.fragmentSource = fragmentSource;
        _this3.attributes = new Map();
        _this3.uniforms = new Map();
        var vertexShader = _this3.vertexShader = getShader(gl, vertexSource, gl.VERTEX_SHADER);
        var fragmentShader = _this3.fragmentShader = getShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
        // DEBUG
        // {
        //   let combinedSource = 'VERTEX SHADER\n\n' + vertexSource + '\n\n\nFRAGMENT SHADER\n\n' +
        //   fragmentSource + '\n';
        //   let w = window.open("about:blank", "_blank");
        //   w.document.write('<pre>' + combinedSource.replace('<', '&lt;').replace('>', '&gt;') +
        //   '</pre>');
        // }
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            var log = gl.getProgramInfoLog(shaderProgram) || '';
            throw new ShaderLinkError(vertexSource, fragmentSource, log);
        }
        _this3.program = shaderProgram;
        var uniforms = _this3.uniforms;
        var attributes = _this3.attributes;

        if (uniformNames) {
            for (var name of uniformNames) {
                uniforms.set(name, gl.getUniformLocation(shaderProgram, name));
            }
        }
        if (attributeNames) {
            for (var _name of attributeNames) {
                attributes.set(_name, gl.getAttribLocation(shaderProgram, _name));
            }
        }
        return _this3;
    }

    _createClass(ShaderProgram, [{
        key: 'uniform',
        value: function uniform(name) {
            return this.uniforms.get(name);
        }
    }, {
        key: 'attribute',
        value: function attribute(name) {
            return this.attributes.get(name);
        }
    }, {
        key: 'textureUnit',
        value: function textureUnit(symbol) {
            return this.textureUnits.get(symbol);
        }
    }, {
        key: 'bind',
        value: function bind() {
            this.gl.useProgram(this.program);
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            var gl = this.gl;

            gl.deleteShader(this.vertexShader);
            this.vertexShader = undefined;
            gl.deleteShader(this.fragmentShader);
            this.fragmentShader = undefined;
            gl.deleteProgram(this.program);
            this.program = undefined;
            this.gl = undefined;
            this.attributes = undefined;
            this.uniforms = undefined;
        }
    }]);

    return ShaderProgram;
}(disposable_1.RefCounted);

exports.ShaderProgram = ShaderProgram;
;

var ShaderCode = function () {
    function ShaderCode() {
        _classCallCheck(this, ShaderCode);

        this.code = '';
        this.parts = new Set();
    }

    _createClass(ShaderCode, [{
        key: 'add',
        value: function add(x) {
            if (this.parts.has(x)) {
                return;
            }
            this.parts.add(x);
            switch (typeof x) {
                case 'string':
                    this.code += x;
                    break;
                case 'function':
                    this.add(x());
                    break;
                default:
                    if (Array.isArray(x)) {
                        for (var y of x) {
                            this.add(y);
                        }
                    } else {
                        throw new Error('Invalid code type');
                    }
            }
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.code;
        }
    }]);

    return ShaderCode;
}();

exports.ShaderCode = ShaderCode;
;

var ShaderBuilder = function () {
    function ShaderBuilder(gl) {
        _classCallCheck(this, ShaderBuilder);

        this.gl = gl;
        this.nextSymbolID = 0;
        this.nextTextureUnit = 0;
        this.uniformsCode = '';
        this.attributesCode = '';
        this.varyingsCode = '';
        this.fragmentExtensionsSet = new Set();
        this.fragmentExtensions = '';
        this.vertexCode = new ShaderCode();
        this.vertexMain = '';
        this.fragmentCode = new ShaderCode();
        this.fragmentMain = '';
        this.required = new Set();
        this.uniforms = new Array();
        this.attributes = new Array();
        this.initializers = [];
        this.textureUnits = new Map();
    }

    _createClass(ShaderBuilder, [{
        key: 'allocateTextureUnit',
        value: function allocateTextureUnit(symbol) {
            var count = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

            if (this.textureUnits.has(symbol)) {
                throw new Error('Duplicate texture unit symbol: ' + symbol);
            }
            var old = this.nextTextureUnit;
            this.nextTextureUnit += count;
            this.textureUnits.set(symbol, old);
            return old;
        }
    }, {
        key: 'addTextureSampler2D',
        value: function addTextureSampler2D(name, symbol, extent) {
            var textureUnit = this.allocateTextureUnit(symbol, extent);
            this.addUniform('highp sampler2D', name, extent);
            this.addInitializer(shader => {
                if (extent) {
                    var textureUnits = new Int32Array(extent);
                    for (var i = 0; i < extent; ++i) {
                        textureUnits[i] = i + textureUnit;
                    }
                    shader.gl.uniform1iv(shader.uniform(name), textureUnits);
                } else {
                    shader.gl.uniform1i(shader.uniform(name), textureUnit);
                }
            });
            return textureUnit;
        }
    }, {
        key: 'symbol',
        value: function symbol(name) {
            return name + this.nextSymbolID++;
        }
    }, {
        key: 'addAttribute',
        value: function addAttribute(typeName, name) {
            this.attributes.push(name);
            this.attributesCode += `attribute ${ typeName } ${ name };\n`;
            return name;
        }
    }, {
        key: 'addVarying',
        value: function addVarying(typeName, name) {
            this.varyingsCode += `varying ${ typeName } ${ name };\n`;
        }
    }, {
        key: 'addUniform',
        value: function addUniform(typeName, name, extent) {
            this.uniforms.push(name);
            if (extent != null) {
                this.uniformsCode += `uniform ${ typeName } ${ name }[${ extent }];\n`;
            } else {
                this.uniformsCode += `uniform ${ typeName } ${ name };\n`;
            }
            return name;
        }
    }, {
        key: 'addFragmentExtension',
        value: function addFragmentExtension(name) {
            if (this.fragmentExtensionsSet.has(name)) {
                return;
            }
            this.fragmentExtensionsSet.add(name);
            this.fragmentExtensions += `#extension ${ name } : require\n`;
        }
    }, {
        key: 'addVertexCode',
        value: function addVertexCode(code) {
            this.vertexCode.add(code);
        }
    }, {
        key: 'addFragmentCode',
        value: function addFragmentCode(code) {
            this.fragmentCode.add(code);
        }
    }, {
        key: 'setVertexMain',
        value: function setVertexMain(code) {
            this.vertexMain = code;
        }
    }, {
        key: 'setFragmentMain',
        value: function setFragmentMain(code) {
            this.fragmentMain = `void main() {
${ code }
}
`;
        }
    }, {
        key: 'setFragmentMainFunction',
        value: function setFragmentMainFunction(code) {
            this.fragmentMain = code;
        }
    }, {
        key: 'addInitializer',
        value: function addInitializer(f) {
            this.initializers.push(f);
        }
    }, {
        key: 'require',
        value: function require(f) {
            if (this.required.has(f)) {
                return;
            }
            this.required.add(f);
            f(this);
        }
    }, {
        key: 'build',
        value: function build() {
            var vertexSource = `
precision highp float;
${ this.uniformsCode }
${ this.attributesCode }
${ this.varyingsCode }
${ this.vertexCode }
void main() {
${ this.vertexMain }
}
`;
            var fragmentSource = `
${ this.fragmentExtensions }
precision highp float;
${ this.uniformsCode }
${ this.varyingsCode }
${ this.fragmentCode }
${ this.fragmentMain }
`;
            var shader = new ShaderProgram(this.gl, vertexSource, fragmentSource, this.uniforms, this.attributes);
            shader.textureUnits = this.textureUnits;
            var initializers = this.initializers;

            if (initializers.length > 0) {
                shader.bind();
                for (var initializer of initializers) {
                    initializer(shader);
                }
            }
            return shader;
        }
    }]);

    return ShaderBuilder;
}();

exports.ShaderBuilder = ShaderBuilder;
;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debounce = __webpack_require__(43);
var throttle = __webpack_require__(50);
var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var signal_binding_updater_1 = __webpack_require__(51);
var uint64_1 = __webpack_require__(52);
var use_count_1 = __webpack_require__(53);
var signals_1 = __webpack_require__(34);

var RenderLayer = function (_disposable_1$RefCoun) {
    _inherits(RenderLayer, _disposable_1$RefCoun);

    function RenderLayer() {
        _classCallCheck(this, RenderLayer);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RenderLayer).call(this, ...args));

        _this.ready = false;
        _this.layerChanged = new signals_1.Signal();
        _this.redrawNeeded = new signals_1.Signal();
        _this.readyStateChanged = new signals_1.Signal();
        /**
         * Base voxel size for this layer, in nanometers per voxel.
         */
        _this.voxelSize = null;
        /**
         * Bounding box for this layer, in nanometers.
         */
        _this.boundingBox = null;
        return _this;
    }

    _createClass(RenderLayer, [{
        key: 'setReady',
        value: function setReady(value) {
            this.ready = value;
            this.readyStateChanged.dispatch();
            this.layerChanged.dispatch();
        }
    }, {
        key: 'handleAction',
        value: function handleAction(action) {
            // Do nothing by default.
        }
    }, {
        key: 'getValueAt',
        value: function getValueAt(x) {
            return undefined;
        }
    }]);

    return RenderLayer;
}(disposable_1.RefCounted);

exports.RenderLayer = RenderLayer;
;
/**
 * Extends RenderLayer with functionality for tracking the number of panels in which the layer is
 * visible.
 */

var VisibilityTrackedRenderLayer = function (_RenderLayer) {
    _inherits(VisibilityTrackedRenderLayer, _RenderLayer);

    function VisibilityTrackedRenderLayer() {
        _classCallCheck(this, VisibilityTrackedRenderLayer);

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(VisibilityTrackedRenderLayer).call(this, ...args));

        _this2.visibilityCount = _this2.registerDisposer(new use_count_1.UseCount());
        return _this2;
    }

    return VisibilityTrackedRenderLayer;
}(RenderLayer);

exports.VisibilityTrackedRenderLayer = VisibilityTrackedRenderLayer;
;

var UserLayerDropdown = function (_disposable_1$RefCoun2) {
    _inherits(UserLayerDropdown, _disposable_1$RefCoun2);

    function UserLayerDropdown() {
        _classCallCheck(this, UserLayerDropdown);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(UserLayerDropdown).apply(this, arguments));
    }

    _createClass(UserLayerDropdown, [{
        key: 'onShow',
        value: function onShow() {}
    }, {
        key: 'onHide',
        value: function onHide() {}
    }]);

    return UserLayerDropdown;
}(disposable_1.RefCounted);

exports.UserLayerDropdown = UserLayerDropdown;

var UserLayer = function (_disposable_1$RefCoun3) {
    _inherits(UserLayer, _disposable_1$RefCoun3);

    function UserLayer() {
        var renderLayers = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

        _classCallCheck(this, UserLayer);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(UserLayer).call(this));

        _this4.layersChanged = new signals_1.Signal();
        _this4.readyStateChanged = new signals_1.Signal();
        _this4.specificationChanged = new signals_1.Signal();
        _this4.renderLayers = new Array();
        renderLayers.forEach(_this4.addRenderLayer.bind(_this4));
        return _this4;
    }

    _createClass(UserLayer, [{
        key: 'addRenderLayer',
        value: function addRenderLayer(layer) {
            this.renderLayers.push(layer);
            var layersChanged = this.layersChanged;
            var readyStateChanged = this.readyStateChanged;

            this.registerDisposer(layer);
            this.registerSignalBinding(layer.layerChanged.add(layersChanged.dispatch, layersChanged));
            this.registerSignalBinding(layer.readyStateChanged.add(readyStateChanged.dispatch, readyStateChanged));
            layersChanged.dispatch();
        }
    }, {
        key: 'getValueAt',
        value: function getValueAt(position, pickedRenderLayer, pickedObject) {
            var result = void 0;
            var renderLayers = this.renderLayers;

            if (pickedRenderLayer !== null && renderLayers.indexOf(pickedRenderLayer) !== -1) {
                return this.transformPickedValue(pickedObject);
            }
            for (var layer of renderLayers) {
                if (!layer.ready) {
                    continue;
                }
                result = layer.getValueAt(position);
                if (result !== undefined) {
                    break;
                }
            }
            return this.transformPickedValue(result);
        }
    }, {
        key: 'transformPickedValue',
        value: function transformPickedValue(value) {
            return value;
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            return null;
        }
    }, {
        key: 'makeDropdown',
        value: function makeDropdown(element) {
            return undefined;
        }
    }, {
        key: 'handleAction',
        value: function handleAction(action) {}
    }]);

    return UserLayer;
}(disposable_1.RefCounted);

exports.UserLayer = UserLayer;
;

var ManagedUserLayer = function (_disposable_1$RefCoun4) {
    _inherits(ManagedUserLayer, _disposable_1$RefCoun4);

    /**
     * If layer is not null, tranfers ownership of a reference.
     */

    function ManagedUserLayer(name) {
        var layer = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
        var visible = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        _classCallCheck(this, ManagedUserLayer);

        var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(ManagedUserLayer).call(this));

        _this5.name = name;
        _this5.visible = visible;
        _this5.readyStateChanged = new signals_1.Signal();
        _this5.layerChanged = new signals_1.Signal();
        _this5.specificationChanged = new signals_1.Signal();
        _this5.wasDisposed = false;
        _this5.layer_ = null;
        _this5.layer = layer;
        return _this5;
    }

    _createClass(ManagedUserLayer, [{
        key: 'updateSignalBindings',
        value: function updateSignalBindings(layer, callback) {
            callback(layer.layersChanged, this.handleLayerChanged, this);
            callback(layer.readyStateChanged, this.readyStateChanged.dispatch, this.readyStateChanged);
            callback(layer.specificationChanged, this.specificationChanged.dispatch, this.specificationChanged);
        }
        /**
         * If layer is not null, tranfers ownership of a reference.
         */

    }, {
        key: 'handleLayerChanged',
        value: function handleLayerChanged() {
            if (this.visible) {
                this.layerChanged.dispatch();
            }
        }
    }, {
        key: 'setVisible',
        value: function setVisible(value) {
            if (value !== this.visible) {
                this.visible = value;
                this.layerChanged.dispatch();
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            this.wasDisposed = true;
            this.layer = null;
            _get(Object.getPrototypeOf(ManagedUserLayer.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'layer',
        get: function () {
            return this.layer_;
        },
        set: function (layer) {
            var oldLayer = this.layer_;
            if (oldLayer != null) {
                this.updateSignalBindings(oldLayer, signal_binding_updater_1.removeSignalBinding);
                oldLayer.dispose();
            }
            this.layer_ = layer;
            if (layer != null) {
                this.updateSignalBindings(layer, signal_binding_updater_1.addSignalBinding);
                this.readyStateChanged.dispatch();
                this.handleLayerChanged();
            }
        }
    }]);

    return ManagedUserLayer;
}(disposable_1.RefCounted);

exports.ManagedUserLayer = ManagedUserLayer;
;

var LayerManager = function (_disposable_1$RefCoun5) {
    _inherits(LayerManager, _disposable_1$RefCoun5);

    function LayerManager() {
        _classCallCheck(this, LayerManager);

        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
        }

        var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(LayerManager).call(this, ...args));

        _this6.managedLayers = new Array();
        _this6.layersChanged = new signals_1.Signal();
        _this6.readyStateChanged = new signals_1.Signal();
        _this6.specificationChanged = new signals_1.Signal();
        _this6.boundPositions = new WeakSet();
        return _this6;
    }

    _createClass(LayerManager, [{
        key: 'updateSignalBindings',
        value: function updateSignalBindings(layer, callback) {
            callback(layer.layerChanged, this.layersChanged.dispatch, this.layersChanged);
            callback(layer.readyStateChanged, this.readyStateChanged.dispatch, this.readyStateChanged);
            callback(layer.specificationChanged, this.specificationChanged.dispatch, this.specificationChanged);
        }
        /**
         * Assumes ownership of an existing reference to managedLayer.
         */

    }, {
        key: 'addManagedLayer',
        value: function addManagedLayer(managedLayer) {
            this.updateSignalBindings(managedLayer, signal_binding_updater_1.addSignalBinding);
            this.managedLayers.push(managedLayer);
            this.layersChanged.dispatch();
            return managedLayer;
        }
        /**
         * Assumes ownership of an existing reference to userLayer.
         */

    }, {
        key: 'addUserLayer',
        value: function addUserLayer(name, userLayer, visible) {
            var managedLayer = new ManagedUserLayer(name, userLayer, visible);
            return this.addManagedLayer(managedLayer);
        }
    }, {
        key: 'readyRenderLayers',
        value: function* readyRenderLayers() {
            for (var managedUserLayer of this.managedLayers) {
                if (!managedUserLayer.visible || !managedUserLayer.layer) {
                    continue;
                }
                for (var renderLayer of managedUserLayer.layer.renderLayers) {
                    if (!renderLayer.ready) {
                        continue;
                    }
                    yield renderLayer;
                }
            }
        }
    }, {
        key: 'unbindManagedLayer',
        value: function unbindManagedLayer(managedLayer) {
            this.updateSignalBindings(managedLayer, signal_binding_updater_1.removeSignalBinding);
            managedLayer.dispose();
        }
    }, {
        key: 'clear',
        value: function clear() {
            for (var managedLayer of this.managedLayers) {
                this.unbindManagedLayer(managedLayer);
            }
            this.managedLayers.length = 0;
            this.layersChanged.dispatch();
        }
    }, {
        key: 'removeManagedLayer',
        value: function removeManagedLayer(managedLayer) {
            var index = this.managedLayers.indexOf(managedLayer);
            if (index === -1) {
                throw new Error(`Internal error: invalid managed layer.`);
            }
            this.unbindManagedLayer(managedLayer);
            this.managedLayers.splice(index, 1);
            this.layersChanged.dispatch();
        }
    }, {
        key: 'reorderManagedLayer',
        value: function reorderManagedLayer(oldIndex, newIndex) {
            var numLayers = this.managedLayers.length;
            if (oldIndex === newIndex || oldIndex < 0 || oldIndex >= numLayers || newIndex < 0 || newIndex >= numLayers) {
                // Don't do anything.
                return;
            }

            var _managedLayers$splice = this.managedLayers.splice(oldIndex, 1);

            var _managedLayers$splice2 = _slicedToArray(_managedLayers$splice, 1);

            var oldLayer = _managedLayers$splice2[0];

            this.managedLayers.splice(newIndex, 0, oldLayer);
            this.layersChanged.dispatch();
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            this.clear();
            _get(Object.getPrototypeOf(LayerManager.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'getLayerByName',
        value: function getLayerByName(name) {
            return this.managedLayers.find(x => x.name === name);
        }
        /**
         * Asynchronously initialize the voxelSize and position based on the managed layers.
         *
         * The first ready layer with an associated bounding box will set the position to the center of
         * the bounding box.
         *
         * If the position later becomes invalid, it will be initialized again.
         */

    }, {
        key: 'initializePosition',
        value: function initializePosition(position) {
            var boundPositions = this.boundPositions;

            if (boundPositions.has(position)) {
                return;
            }
            boundPositions.add(position);
            // Deboucne to ensure that if the position is reset and the layers are reset immediately after,
            // the position will not be reinitialized based on the soon to be reset layers.
            var handler = debounce(() => {
                this.updatePositionFromLayers(position);
            });
            this.readyStateChanged.add(handler);
            position.changed.add(handler);
            this.updatePositionFromLayers(position);
        }
    }, {
        key: 'updatePositionFromLayers',
        value: function updatePositionFromLayers(position) {
            if (position.valid) {
                return;
            }
            for (var managedLayer of this.managedLayers) {
                var userLayer = managedLayer.layer;
                if (userLayer == null) {
                    continue;
                }
                for (var renderLayer of userLayer.renderLayers) {
                    if (!renderLayer.ready) {
                        continue;
                    }
                    if (!position.voxelSize.valid && renderLayer.voxelSize != null) {
                        geom_1.vec3.copy(position.voxelSize.size, renderLayer.voxelSize);
                        position.voxelSize.setValid();
                    }
                    if (!position.spatialCoordinatesValid && !position.voxelCoordinatesValid && renderLayer.boundingBox != null) {
                        var boundingBox = renderLayer.boundingBox;
                        var centerPosition = position.spatialCoordinates;
                        geom_1.vec3.add(centerPosition, boundingBox.lower, boundingBox.upper);
                        geom_1.vec3.scale(centerPosition, centerPosition, 0.5);
                        position.spatialCoordinatesValid = true;
                        position.changed.dispatch();
                    }
                }
            }
        }
    }, {
        key: 'invokeAction',
        value: function invokeAction(action) {
            for (var managedLayer of this.managedLayers) {
                if (managedLayer.layer === null || !managedLayer.visible) {
                    continue;
                }
                var userLayer = managedLayer.layer;
                userLayer.handleAction(action);
                for (var renderLayer of userLayer.renderLayers) {
                    if (!renderLayer.ready) {
                        continue;
                    }
                    renderLayer.handleAction(action);
                }
            }
        }
    }, {
        key: 'renderLayers',
        get: function () {
            var layerManager = this;
            return {
                *[Symbol.iterator]() {
                    for (var managedLayer of layerManager.managedLayers) {
                        if (managedLayer.layer === null) {
                            continue;
                        }
                        for (var renderLayer of managedLayer.layer.renderLayers) {
                            yield renderLayer;
                        }
                    }
                }
            };
        }
    }, {
        key: 'visibleRenderLayers',
        get: function () {
            var layerManager = this;
            return {
                *[Symbol.iterator]() {
                    for (var managedLayer of layerManager.managedLayers) {
                        if (managedLayer.layer === null || !managedLayer.visible) {
                            continue;
                        }
                        for (var renderLayer of managedLayer.layer.renderLayers) {
                            yield renderLayer;
                        }
                    }
                }
            };
        }
    }]);

    return LayerManager;
}(disposable_1.RefCounted);

exports.LayerManager = LayerManager;
;
var MOUSE_STATE_UPDATE_INTERVAL = 50;

var MouseSelectionState = function () {
    function MouseSelectionState() {
        _classCallCheck(this, MouseSelectionState);

        this.changed = new signals_1.Signal();
        this.position = geom_1.vec3.create();
        this.active = false;
        this.pickedRenderLayer = null;
        this.pickedValue = new uint64_1.Uint64(0, 0);
        this.updater = undefined;
        this.stale = false;
        this.triggerUpdate = throttle(() => {
            this.update();
        }, MOUSE_STATE_UPDATE_INTERVAL, { leading: true, trailing: true });
    }

    _createClass(MouseSelectionState, [{
        key: 'updateUnconditionally',
        value: function updateUnconditionally() {
            this.triggerUpdate.cancel();
            this.update();
            return this.active;
        }
    }, {
        key: 'updateIfStale',
        value: function updateIfStale() {
            if (this.stale) {
                this.update();
            }
        }
    }, {
        key: 'update',
        value: function update() {
            var updater = this.updater;

            this.stale = false;
            if (!updater) {
                this.setActive(false);
            } else {
                this.setActive(updater(this));
            }
        }
    }, {
        key: 'setActive',
        value: function setActive(value) {
            this.stale = false;
            if (this.active !== value || value === true) {
                this.active = value;
                this.changed.dispatch();
            }
        }
    }]);

    return MouseSelectionState;
}();

exports.MouseSelectionState = MouseSelectionState;
;

var LayerSelectedValues = function (_disposable_1$RefCoun6) {
    _inherits(LayerSelectedValues, _disposable_1$RefCoun6);

    function LayerSelectedValues(layerManager, mouseState) {
        _classCallCheck(this, LayerSelectedValues);

        var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(LayerSelectedValues).call(this));

        _this7.layerManager = layerManager;
        _this7.mouseState = mouseState;
        _this7.values = new Map();
        _this7.changed = new signals_1.Signal();
        _this7.needsUpdate = true;
        _this7.registerSignalBinding(mouseState.changed.add(_this7.handleChange, _this7));
        _this7.registerSignalBinding(layerManager.layersChanged.add(() => {
            _this7.handleLayerChange();
        }));
        return _this7;
    }
    /**
     * This should be called when the layer data may have changed, due to the set of managed layers
     * changing or new data having been received.
     */


    _createClass(LayerSelectedValues, [{
        key: 'handleLayerChange',
        value: function handleLayerChange() {
            if (this.mouseState.active) {
                this.handleChange();
            }
        }
    }, {
        key: 'handleChange',
        value: function handleChange() {
            this.needsUpdate = true;
            this.changed.dispatch();
        }
    }, {
        key: 'update',
        value: function update() {
            if (!this.needsUpdate) {
                return;
            }
            this.needsUpdate = false;
            var values = this.values;
            var mouseState = this.mouseState;
            values.clear();
            if (mouseState.active) {
                var position = mouseState.position;
                for (var layer of this.layerManager.managedLayers) {
                    var userLayer = layer.layer;
                    if (layer.visible && userLayer) {
                        values.set(userLayer, userLayer.getValueAt(position, mouseState.pickedRenderLayer, mouseState.pickedValue));
                    }
                }
            }
        }
    }, {
        key: 'get',
        value: function get(userLayer) {
            this.update();
            return this.values.get(userLayer);
        }
    }]);

    return LayerSelectedValues;
}(disposable_1.RefCounted);

exports.LayerSelectedValues = LayerSelectedValues;
;

var VisibleRenderLayerTracker = function (_disposable_1$RefCoun7) {
    _inherits(VisibleRenderLayerTracker, _disposable_1$RefCoun7);

    function VisibleRenderLayerTracker(layerManager, renderLayerType, layerAdded, layerRemoved) {
        _classCallCheck(this, VisibleRenderLayerTracker);

        var _this8 = _possibleConstructorReturn(this, Object.getPrototypeOf(VisibleRenderLayerTracker).call(this));

        _this8.layerManager = layerManager;
        _this8.renderLayerType = renderLayerType;
        _this8.layerAdded = layerAdded;
        _this8.layerRemoved = layerRemoved;
        _this8.visibleLayers = new Set();
        _this8.newVisibleLayers = new Set();
        _this8.updatePending = null;
        _this8.registerSignalBinding(layerManager.layersChanged.add(_this8.handleLayersChanged, _this8));
        _this8.updateVisibleLayers();
        return _this8;
    }

    _createClass(VisibleRenderLayerTracker, [{
        key: 'handleLayersChanged',
        value: function handleLayersChanged() {
            if (this.updatePending === null) {
                this.updatePending = setTimeout(() => {
                    this.updatePending = null;
                    this.updateVisibleLayers();
                }, 0);
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            this.cancelUpdate();
            this.visibleLayers.forEach(this.layerRemoved);
            this.visibleLayers.clear();
            _get(Object.getPrototypeOf(VisibleRenderLayerTracker.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'cancelUpdate',
        value: function cancelUpdate() {
            var updatePending = this.updatePending;

            if (updatePending !== null) {
                clearTimeout(updatePending);
                updatePending = null;
            }
        }
    }, {
        key: 'updateVisibleLayers',
        value: function updateVisibleLayers() {
            var visibleLayers = this.visibleLayers;
            var newVisibleLayers = this.newVisibleLayers;
            var renderLayerType = this.renderLayerType;
            var layerAdded = this.layerAdded;
            var layerRemoved = this.layerRemoved;

            for (var renderLayer of this.layerManager.readyRenderLayers()) {
                if (renderLayer instanceof renderLayerType) {
                    var typedLayer = renderLayer;
                    newVisibleLayers.add(typedLayer);
                    if (!visibleLayers.has(typedLayer)) {
                        visibleLayers.add(typedLayer);
                        typedLayer.visibilityCount.inc();
                        layerAdded(typedLayer);
                    }
                }
            }
            for (var _renderLayer of visibleLayers) {
                if (!newVisibleLayers.has(_renderLayer)) {
                    visibleLayers.delete(_renderLayer);
                    layerRemoved(_renderLayer);
                    _renderLayer.visibilityCount.dec();
                }
            }
            newVisibleLayers.clear();
        }
    }, {
        key: 'getVisibleLayers',
        value: function getVisibleLayers() {
            if (this.updatePending !== null) {
                this.cancelUpdate();
                this.updateVisibleLayers();
            }
            return this.visibleLayers;
        }
    }]);

    return VisibleRenderLayerTracker;
}(disposable_1.RefCounted);

exports.VisibleRenderLayerTracker = VisibleRenderLayerTracker;
;
function makeRenderedPanelVisibleLayerTracker(layerManager, renderLayerType, panel) {
    return panel.registerDisposer(new VisibleRenderLayerTracker(layerManager, renderLayerType, layer => {
        layer.redrawNeeded.add(panel.scheduleRedraw, panel);
        panel.scheduleRedraw();
    }, layer => {
        layer.redrawNeeded.remove(panel.scheduleRedraw, panel);
        panel.scheduleRedraw();
    }));
}
exports.makeRenderedPanelVisibleLayerTracker = makeRenderedPanelVisibleLayerTracker;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(44),
    now = __webpack_require__(45),
    toNumber = __webpack_require__(46);

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide an options object to indicate whether `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent calls
 * to the debounced function return the result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ },
/* 44 */
/***/ function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ },
/* 45 */
/***/ function(module, exports) {

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
function now() {
  return Date.now();
}

module.exports = now;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(47),
    isObject = __webpack_require__(44),
    isSymbol = __webpack_require__(48);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(44);

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

var isObjectLike = __webpack_require__(49);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;


/***/ },
/* 49 */
/***/ function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(43),
    isObject = __webpack_require__(44);

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide an options object to indicate whether
 * `func` should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ },
/* 51 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function removeSignalBinding(signal, handler, context) {
    signal.remove(handler, context);
}
exports.removeSignalBinding = removeSignalBinding;
function addSignalBinding(signal, handler, context) {
    signal.add(handler, context);
}
exports.addSignalBinding = addSignalBinding;

/***/ },
/* 52 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var randomTempBuffer = new Uint32Array(2);
var trueBase = 0x100000000;
var stringConversionData = [];
for (var base = 2; base <= 36; ++base) {
    var lowDigits = Math.floor(32 / Math.log2(base));
    var lowBase = Math.pow(base, lowDigits);
    var lowDigits1 = Math.floor(lowDigits / 2);
    var lowBase1 = Math.pow(base, lowDigits1);
    var lowBase2 = Math.pow(base, lowDigits - lowDigits1);
    var patternString = `^[0-${ String.fromCharCode('0'.charCodeAt(0) + Math.min(9, base - 1)) }`;
    if (base > 10) {
        patternString += `a-${ String.fromCharCode('a'.charCodeAt(0) + base - 11) }`;
        patternString += `A-${ String.fromCharCode('A'.charCodeAt(0) + base - 11) }`;
    }
    var maxDigits = Math.ceil(64 / Math.log2(base));
    patternString += `]{1,${ maxDigits }}$`;
    var pattern = new RegExp(patternString);
    stringConversionData[base] = { lowDigits, lowBase, lowBase1, lowBase2, pattern };
}

var Uint64 = function () {
    function Uint64() {
        var low = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
        var high = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        _classCallCheck(this, Uint64);

        this.low = low;
        this.high = high;
    }

    _createClass(Uint64, [{
        key: 'clone',
        value: function clone() {
            return new Uint64(this.low, this.high);
        }
    }, {
        key: 'assign',
        value: function assign(x) {
            this.low = x.low;
            this.high = x.high;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var base = arguments.length <= 0 || arguments[0] === undefined ? 10 : arguments[0];

            var vLow = this.low,
                vHigh = this.high;
            if (vHigh === 0) {
                return vLow.toString(base);
            }
            vHigh *= trueBase;
            var _stringConversionData = stringConversionData[base];
            var lowBase = _stringConversionData.lowBase;
            var lowDigits = _stringConversionData.lowDigits;

            var vHighExtra = vHigh % lowBase;
            vHigh = Math.floor(vHigh / lowBase);
            vLow += vHighExtra;
            vHigh += Math.floor(vLow / lowBase);
            vLow = vLow % lowBase;
            var vLowStr = vLow.toString(base);
            return vHigh.toString(base) + '0'.repeat(lowDigits - vLowStr.length) + vLowStr;
        }
        /**
         * Returns true if a is strictly less than b.
         */

    }, {
        key: 'tryParseString',
        value: function tryParseString(s) {
            var base = arguments.length <= 1 || arguments[1] === undefined ? 10 : arguments[1];
            var _stringConversionData2 = stringConversionData[base];
            var lowDigits = _stringConversionData2.lowDigits;
            var lowBase = _stringConversionData2.lowBase;
            var lowBase1 = _stringConversionData2.lowBase1;
            var lowBase2 = _stringConversionData2.lowBase2;
            var pattern = _stringConversionData2.pattern;

            if (!pattern.test(s)) {
                return false;
            }
            if (s.length <= lowDigits) {
                this.low = parseInt(s, base);
                this.high = 0;
                return true;
            }
            var splitPoint = s.length - lowDigits;
            var lowPrime = parseInt(s.substr(splitPoint), base);
            var highPrime = parseInt(s.substr(0, splitPoint), base);
            var highConverted = highPrime * lowBase;
            var high = Math.floor(highConverted / trueBase);
            var low = lowPrime + highPrime % trueBase * lowBase1 % trueBase * lowBase2 % trueBase;
            if (low > trueBase) {
                ++high;
                low -= trueBase;
            }
            if (low >>> 0 !== low || high >>> 0 !== high) {
                return false;
            }
            this.low = low;
            this.high = high;
            return true;
        }
    }, {
        key: 'parseString',
        value: function parseString(s) {
            var base = arguments.length <= 1 || arguments[1] === undefined ? 10 : arguments[1];

            if (!this.tryParseString(s, base)) {
                throw new Error(`Failed to parse string as uint64 value: ${ JSON.stringify(s) }.`);
            }
            return this;
        }
    }, {
        key: 'valid',
        value: function valid() {
            var low = this.low;
            var high = this.high;

            return low >>> 0 === low && high >>> 0 === high;
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            return this.toString();
        }
    }], [{
        key: 'less',
        value: function less(a, b) {
            return a.high < b.high || a.high === b.high && a.low < b.low;
        }
        /**
         * Returns a negative number if a is strictly less than b, 0 if a is equal to b, or a positive
         * number if a is strictly greater than b.
         */

    }, {
        key: 'compare',
        value: function compare(a, b) {
            return a.high - b.high || a.low - b.low;
        }
    }, {
        key: 'equal',
        value: function equal(a, b) {
            return a.low === b.low && a.high === b.high;
        }
    }, {
        key: 'min',
        value: function min(a, b) {
            return Uint64.less(a, b) ? a : b;
        }
    }, {
        key: 'random',
        value: function random() {
            crypto.getRandomValues(randomTempBuffer);
            return new Uint64(randomTempBuffer[0], randomTempBuffer[1]);
        }
    }, {
        key: 'parseString',
        value: function parseString(s) {
            var base = arguments.length <= 1 || arguments[1] === undefined ? 10 : arguments[1];

            var x = new Uint64();
            return x.parseString(s, base);
        }
    }]);

    return Uint64;
}();

Uint64.ZERO = new Uint64(0, 0);
exports.Uint64 = Uint64;
;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var signals_1 = __webpack_require__(34);
/**
 * Contains a count and signals that are invoked when the count becomes zero or non-zero.
 */

var UseCount = function (_disposable_1$RefCoun) {
    _inherits(UseCount, _disposable_1$RefCoun);

    function UseCount() {
        _classCallCheck(this, UseCount);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(UseCount).call(this, ...args));

        _this.count = 0;
        _this.dependencies = new Map();
        _this.becameZero = new signals_1.Signal();
        _this.becameNonZero = new signals_1.Signal();
        return _this;
    }

    _createClass(UseCount, [{
        key: 'inc',
        value: function inc() {
            if (++this.count === 1) {
                this.becameNonZero.dispatch();
            }
        }
    }, {
        key: 'dec',
        value: function dec() {
            if (--this.count === 0) {
                this.becameZero.dispatch();
            }
        }
        /**
         * Ensure that an additional count is added to other whenever this.count is non-zero.
         */

    }, {
        key: 'addDependency',
        value: function addDependency(other) {
            var dependencies = this.dependencies;

            var existingCount = dependencies.get(other);
            if (existingCount !== undefined) {
                dependencies.set(other, existingCount + 1);
            } else {
                dependencies.set(other, 1);
                this.becameZero.add(other.dec, other);
                this.becameNonZero.add(other.inc, other);
                if (this.count > 0) {
                    other.inc();
                }
            }
        }
    }, {
        key: 'removeDependency_',
        value: function removeDependency_(other) {
            this.becameZero.remove(other.dec, other);
            this.becameNonZero.remove(other.inc, other);
            if (this.count > 0) {
                other.dec();
            }
        }
        /**
         * Undoes the effect of addDependency.
         */

    }, {
        key: 'removeDependency',
        value: function removeDependency(other) {
            var dependencies = this.dependencies;

            var existing = dependencies.get(other);
            if (existing === undefined) {
                throw new Error('Attempted to remove non-existing dependency.');
            }
            if (--existing === 0) {
                dependencies.delete(other);
                this.removeDependency_(other);
            } else {
                dependencies.set(other, existing);
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            for (var other of this.dependencies.keys()) {
                this.removeDependency_(other);
            }
            this.dependencies.clear();
        }
    }, {
        key: 'value',
        get: function () {
            return this.count;
        }
    }]);

    return UseCount;
}(disposable_1.RefCounted);

exports.UseCount = UseCount;
;

/***/ },
/* 54 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PickIDManager = function () {
    function PickIDManager() {
        _classCallCheck(this, PickIDManager);

        this.renderLayers = [null];
        this.lowValues = [0];
        this.highValues = [0];
    }

    _createClass(PickIDManager, [{
        key: "clear",
        value: function clear() {
            this.renderLayers.length = 1;
            this.lowValues.length = 1;
            this.highValues.length = 1;
        }
    }, {
        key: "register",
        value: function register(renderLayer, x) {
            var renderLayers = this.renderLayers;
            var lowValues = this.lowValues;
            var highValues = this.highValues;

            var id = renderLayers.length;
            renderLayers[id] = renderLayer;
            lowValues[id] = x.low;
            highValues[id] = x.high;
            return id;
        }
        /**
         * Set the object state according to the specified pick ID.
         */

    }, {
        key: "setMouseState",
        value: function setMouseState(mouseState, pickID) {
            mouseState.pickedRenderLayer = this.renderLayers[pickID];
            var pickedValue = mouseState.pickedValue;

            pickedValue.low = this.lowValues[pickID];
            pickedValue.high = this.highValues[pickID];
        }
    }]);

    return PickIDManager;
}();

exports.PickIDManager = PickIDManager;
;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var display_context_1 = __webpack_require__(56);
var geom_1 = __webpack_require__(9);
var wheel_zoom_1 = __webpack_require__(58);
__webpack_require__(59);
exports.KEY_COMMANDS = new Map();

var _loop = function (axis) {
    var axisName = geom_1.AXES_NAMES[axis];

    var _loop2 = function (sign) {
        var signStr = sign < 0 ? '-' : '+';
        exports.KEY_COMMANDS.set(`rotate-relative-${ axisName }${ signStr }`, function () {
            this.navigationState.pose.rotateRelative(geom_1.kAxes[axis], sign * 0.1);
        });
        var tempOffset = geom_1.vec3.create();
        exports.KEY_COMMANDS.set(`${ axisName }${ signStr }`, function () {
            var navigationState = this.navigationState;

            var offset = tempOffset;
            offset[0] = 0;
            offset[1] = 0;
            offset[2] = 0;
            offset[axis] = sign;
            navigationState.pose.translateVoxelsRelative(offset);
        });
    };

    for (var sign of [-1, +1]) {
        _loop2(sign);
    }
};

for (var axis = 0; axis < 3; ++axis) {
    _loop(axis);
}
exports.KEY_COMMANDS.set('snap', function () {
    this.navigationState.pose.snap();
});
exports.KEY_COMMANDS.set('zoom-in', function () {
    this.navigationState.zoomBy(0.5);
});
exports.KEY_COMMANDS.set('zoom-out', function () {
    this.navigationState.zoomBy(2.0);
});
var tempVec3 = geom_1.vec3.create();

var RenderedDataPanel = function (_display_context_1$Re) {
    _inherits(RenderedDataPanel, _display_context_1$Re);

    function RenderedDataPanel(context, element, viewer) {
        _classCallCheck(this, RenderedDataPanel);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RenderedDataPanel).call(this, context, element));

        _this.viewer = viewer;
        // Last mouse position within the panel.
        _this.mouseX = 0;
        _this.mouseY = 0;
        _this.mouseStateUpdater = _this.updateMouseState.bind(_this);
        element.classList.add('rendered-data-panel');
        _this.registerEventListener(element, 'mousemove', _this.onMousemove.bind(_this));
        _this.registerEventListener(element, 'mouseleave', _this.onMouseout.bind(_this));
        _this.registerEventListener(element, 'mousedown', _this.onMousedown.bind(_this), false);
        _this.registerEventListener(element, 'wheel', _this.onMousewheel.bind(_this), false);
        _this.registerEventListener(element, 'dblclick', () => {
            _this.viewer.layerManager.invokeAction('select');
        });
        return _this;
    }

    _createClass(RenderedDataPanel, [{
        key: 'onMouseout',
        value: function onMouseout(event) {
            var mouseState = this.viewer.mouseState;

            mouseState.updater = undefined;
            mouseState.setActive(false);
        }
    }, {
        key: 'onKeyCommand',
        value: function onKeyCommand(action) {
            var command = exports.KEY_COMMANDS.get(action);
            if (command) {
                command.call(this);
                return true;
            }
            return false;
        }
    }, {
        key: 'onMousemove',
        value: function onMousemove(event) {
            var element = this.element;

            if (event.target !== element) {
                return;
            }
            this.mouseX = event.offsetX - element.clientLeft;
            this.mouseY = event.offsetY - element.clientTop;
            var mouseState = this.viewer.mouseState;

            mouseState.updater = this.mouseStateUpdater;
            mouseState.triggerUpdate();
        }
    }, {
        key: 'onMousewheel',
        value: function onMousewheel(e) {
            if (e.ctrlKey) {
                this.onMousemove(e);
                this.zoomByMouse(wheel_zoom_1.getWheelZoomAmount(e));
            } else {
                var navigationState = this.navigationState;

                var offset = tempVec3;
                var delta = e.deltaY !== 0 ? e.deltaY : e.deltaX;
                offset[0] = 0;
                offset[1] = 0;
                offset[2] = (delta > 0 ? -1 : 1) * (e.shiftKey ? 10 : 1);
                navigationState.pose.translateVoxelsRelative(offset);
            }
            e.preventDefault();
        }
    }, {
        key: 'onMousedown',
        value: function onMousedown(e) {
            if (e.target !== this.element) {
                return;
            }
            this.onMousemove(e);
            if (e.button === 2) {
                var mouseState = this.viewer.mouseState;

                if (mouseState.updateUnconditionally()) {
                    var position = this.navigationState.pose.position;
                    geom_1.vec3.copy(position.spatialCoordinates, mouseState.position);
                    position.changed.dispatch();
                }
            }
        }
    }]);

    return RenderedDataPanel;
}(display_context_1.RenderedPanel);

exports.RenderedDataPanel = RenderedDataPanel;
;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var context_1 = __webpack_require__(57);
var signals_1 = __webpack_require__(34);

var RenderedPanel = function (_disposable_1$RefCoun) {
    _inherits(RenderedPanel, _disposable_1$RefCoun);

    function RenderedPanel(context, element) {
        _classCallCheck(this, RenderedPanel);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RenderedPanel).call(this));

        _this.context = context;
        _this.element = element;
        _this.gl = context.gl;
        _this.registerEventListener(element, 'mouseenter', event => {
            _this.context.setActivePanel(_this);
        });
        context.addPanel(_this);
        return _this;
    }

    _createClass(RenderedPanel, [{
        key: 'scheduleRedraw',
        value: function scheduleRedraw() {
            this.context.scheduleRedraw();
        }
    }, {
        key: 'setGLViewport',
        value: function setGLViewport() {
            var element = this.element;
            var left = element.offsetLeft + element.clientLeft;
            var width = element.clientWidth;
            var top = element.offsetTop + element.clientTop;
            var height = element.clientHeight;
            var bottom = top + height;
            var gl = this.gl;
            gl.enable(gl.SCISSOR_TEST);
            var glBottom = this.context.canvas.height - bottom;
            gl.viewport(left, glBottom, width, height);
            gl.scissor(left, glBottom, width, height);
        }
    }, {
        key: 'onKeyCommand',
        value: function onKeyCommand(action) {
            return false;
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            this.context.removePanel(this);
            _get(Object.getPrototypeOf(RenderedPanel.prototype), 'disposed', this).call(this);
        }
    }]);

    return RenderedPanel;
}(disposable_1.RefCounted);

exports.RenderedPanel = RenderedPanel;
;

var DisplayContext = function (_disposable_1$RefCoun2) {
    _inherits(DisplayContext, _disposable_1$RefCoun2);

    function DisplayContext(container) {
        _classCallCheck(this, DisplayContext);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(DisplayContext).call(this));

        _this2.container = container;
        _this2.canvas = document.createElement('canvas');
        _this2.updateStarted = new signals_1.Signal();
        _this2.updateFinished = new signals_1.Signal();
        _this2.panels = new Set();
        _this2.activePanel = null;
        _this2.updatePending = null;
        _this2.needsRedraw = false;
        var canvas = _this2.canvas;

        canvas.className = 'gl-canvas';
        container.appendChild(canvas);
        _this2.gl = context_1.initializeWebGL(canvas);
        _this2.registerEventListener(window, 'resize', _this2.onResize.bind(_this2));
        return _this2;
    }

    _createClass(DisplayContext, [{
        key: 'disposed',
        value: function disposed() {
            if (this.updatePending != null) {
                cancelAnimationFrame(this.updatePending);
                this.updatePending = null;
            }
        }
    }, {
        key: 'addPanel',
        value: function addPanel(panel) {
            this.panels.add(panel);
            if (this.activePanel == null) {
                this.setActivePanel(panel);
            }
        }
    }, {
        key: 'setActivePanel',
        value: function setActivePanel(panel) {
            var existingPanel = this.activePanel;
            if (existingPanel != null) {
                existingPanel.element.attributes.removeNamedItem('isActivePanel');
            }
            if (panel != null) {
                panel.element.setAttribute('isActivePanel', 'true');
            }
            this.activePanel = panel;
        }
    }, {
        key: 'removePanel',
        value: function removePanel(panel) {
            this.panels.delete(panel);
            if (panel === this.activePanel) {
                this.setActivePanel(null);
            }
            panel.dispose();
        }
    }, {
        key: 'onResize',
        value: function onResize() {
            this.scheduleRedraw();
            for (var panel of this.panels) {
                panel.onResize();
            }
        }
    }, {
        key: 'scheduleUpdate',
        value: function scheduleUpdate() {
            if (this.updatePending === null) {
                this.updatePending = requestAnimationFrame(this.update.bind(this));
            }
        }
    }, {
        key: 'scheduleRedraw',
        value: function scheduleRedraw() {
            if (!this.needsRedraw) {
                this.needsRedraw = true;
                this.scheduleUpdate();
            }
        }
    }, {
        key: 'update',
        value: function update() {
            this.updatePending = null;
            this.updateStarted.dispatch();
            if (this.needsRedraw) {
                // console.log("Redraw");
                this.needsRedraw = false;
                var gl = this.gl;
                var canvas = this.canvas;
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                for (var panel of this.panels) {
                    var element = panel.element;

                    if (element.clientWidth === 0 || element.clientHeight === 0) {
                        // Skip drawing if the panel has zero client area.
                        continue;
                    }
                    panel.setGLViewport();
                    panel.draw();
                }
            }
            this.updateFinished.dispatch();
        }
    }]);

    return DisplayContext;
}(disposable_1.RefCounted);

exports.DisplayContext = DisplayContext;
;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var memoize_1 = __webpack_require__(33);
exports.DEBUG_SHADERS = false;
function initializeWebGL(canvas) {
    var options = {
        'antialias': false,
        'stencil': true
    };
    if (exports.DEBUG_SHADERS) {
        console.log('DEBUGGING via preserveDrawingBuffer');
        options['preserveDrawingBuffer'] = true;
    }
    var gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
    gl.memoize = new memoize_1.Memoize();
    gl.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    gl.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    gl.tempTextureUnit = gl.maxTextureImageUnits - 1;
    // FIXME: verify that we received a stencil buffer
    // var contextAttributes = gl.getContextAttributes();
    // var haveStencilBuffer = contextAttributes.stencil;
    gl.WEBGL_draw_buffers = gl.getExtension('WEBGL_draw_buffers');
    if (!gl.WEBGL_draw_buffers) {
        throw new Error('WEBGL_draw_buffers extension not available');
    }
    for (var extension of ['OES_texture_float', 'OES_element_index_uint']) {
        if (!gl.getExtension(extension)) {
            throw new Error(`${ extension } extension not available`);
        }
    }
    return gl;
}
exports.initializeWebGL = initializeWebGL;

/***/ },
/* 58 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var DOM_DELTA_PIXEL = 0;
var DOM_DELTA_LINE = 1;
var DOM_DELTA_PAGE = 2;
function getWheelZoomAmount(event) {
    var multiplier = 0;
    var deltaMode = event.deltaMode;

    switch (deltaMode) {
        case DOM_DELTA_PIXEL:
            multiplier = 1 / 200.0;
            break;
        case DOM_DELTA_LINE:
            multiplier = 1 / 10.0;
            break;
        case DOM_DELTA_PAGE:
            multiplier = 2;
            break;
    }
    return Math.exp(event.deltaY * multiplier);
}
exports.getWheelZoomAmount = getWheelZoomAmount;

/***/ },
/* 59 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var base_1 = __webpack_require__(31);
var frontend_1 = __webpack_require__(32);
var base_2 = __webpack_require__(61);
var renderlayer_1 = __webpack_require__(66);
var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var json_1 = __webpack_require__(8);
var buffer_1 = __webpack_require__(38);
var offscreen_1 = __webpack_require__(68);
var shader_1 = __webpack_require__(41);
var worker_rpc_1 = __webpack_require__(22);
var signals_1 = __webpack_require__(34);
var tempMat = geom_1.mat4.create();
var SliceView = function (_base_2$SliceViewBase) {
    _inherits(SliceView, _base_2$SliceViewBase);

    function SliceView(gl, chunkManager, layerManager, navigationState) {
        _classCallCheck(this, SliceView);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SliceView).call(this));

        _this.gl = gl;
        _this.chunkManager = chunkManager;
        _this.layerManager = layerManager;
        _this.navigationState = navigationState;
        _this.dataToViewport = geom_1.mat4.create();
        // Transforms viewport coordinates to OpenGL normalized device coordinates
        // [left: -1, right: 1], [top: 1, bottom: -1].
        _this.viewportToDevice = geom_1.mat4.create();
        // Equals viewportToDevice * dataToViewport.
        _this.dataToDevice = geom_1.mat4.create();
        _this.visibleChunks = new Map();
        _this.viewChanged = new signals_1.Signal();
        _this.renderingStale = true;
        _this.visibleChunksStale = true;
        _this.visibleLayersStale = false;
        _this.visibleLayerList = new Array();
        _this.newVisibleLayers = new Set();
        _this.offscreenFramebuffer = new offscreen_1.OffscreenFramebuffer(_this.gl, { numDataBuffers: 1, depthBuffer: false, stencilBuffer: true });
        geom_1.mat4.identity(_this.dataToViewport);
        _this.initializeCounterpart(_this.chunkManager.rpc, { 'chunkManager': chunkManager.rpcId });
        _this.updateVisibleLayers();
        _this.registerSignalBinding(navigationState.changed.add(() => {
            _this.updateViewportFromNavigationState();
        }));
        _this.updateViewportFromNavigationState();
        _this.registerSignalBinding(layerManager.layersChanged.add(() => {
            if (!_this.visibleLayersStale) {
                if (_this.hasValidViewport) {
                    _this.visibleLayersStale = true;
                    setTimeout(_this.updateVisibleLayers.bind(_this), 0);
                }
            }
        }));
        _this.viewChanged.add(() => {
            _this.renderingStale = true;
        });
        _this.registerSignalBinding(chunkManager.chunkQueueManager.visibleChunksChanged.add(_this.viewChanged.dispatch, _this.viewChanged));
        _this.updateViewportFromNavigationState();
        return _this;
    }

    _createClass(SliceView, [{
        key: "updateViewportFromNavigationState",
        value: function updateViewportFromNavigationState() {
            var navigationState = this.navigationState;

            if (!navigationState.valid) {
                return;
            }
            navigationState.toMat4(tempMat);
            this.setViewportToDataMatrix(tempMat);
        }
    }, {
        key: "updateVisibleLayers",
        value: function updateVisibleLayers() {
            if (!this.hasValidViewport) {
                return false;
            }
            this.visibleLayersStale = false;
            var visibleLayers = this.visibleLayers;
            var rpc = this.rpc;
            var rpcMessage = { 'id': this.rpcId };
            var newVisibleLayers = this.newVisibleLayers;
            var changed = false;
            var visibleLayerList = this.visibleLayerList;
            visibleLayerList.length = 0;
            for (var renderLayer of this.layerManager.readyRenderLayers()) {
                if (renderLayer instanceof renderlayer_1.RenderLayer) {
                    newVisibleLayers.add(renderLayer);
                    visibleLayerList.push(renderLayer);
                    if (!visibleLayers.has(renderLayer)) {
                        visibleLayers.set(renderLayer.addRef(), []);
                        renderLayer.redrawNeeded.add(this.viewChanged.dispatch, this.viewChanged);
                        rpcMessage['layerId'] = renderLayer.rpcId;
                        rpc.invoke('SliceView.addVisibleLayer', rpcMessage);
                        changed = true;
                    }
                }
            }
            for (var _renderLayer of visibleLayers.keys()) {
                if (!newVisibleLayers.has(_renderLayer)) {
                    visibleLayers.delete(_renderLayer);
                    _renderLayer.redrawNeeded.remove(this.viewChanged.dispatch, this.viewChanged);
                    rpcMessage['layerId'] = _renderLayer.rpcId;
                    rpc.invoke('SliceView.removeVisibleLayer', rpcMessage);
                    _renderLayer.dispose();
                    changed = true;
                }
            }
            newVisibleLayers.clear();
            if (changed) {
                this.visibleSourcesStale = true;
            }
            // Unconditionally call viewChanged, because layers may have been reordered even if the set of
            // sources is the same.
            this.viewChanged.dispatch();
            return changed;
        }
    }, {
        key: "onViewportChanged",
        value: function onViewportChanged() {
            var width = this.width;
            var height = this.height;
            var viewportToDevice = this.viewportToDevice;
            var dataToViewport = this.dataToViewport;
            var dataToDevice = this.dataToDevice;

            geom_1.mat4.ortho(viewportToDevice, -width / 2, width / 2, height / 2, -height / 2, -1, 1);
            geom_1.mat4.multiply(dataToDevice, viewportToDevice, dataToViewport);
            this.visibleChunksStale = true;
            this.viewChanged.dispatch();
        }
    }, {
        key: "setViewportSize",
        value: function setViewportSize(width, height) {
            if (_get(Object.getPrototypeOf(SliceView.prototype), "setViewportSize", this).call(this, width, height)) {
                this.rpc.invoke('SliceView.updateView', { id: this.rpcId, width: width, height: height });
                // this.chunkManager.scheduleUpdateChunkPriorities();
                return true;
            }
            return false;
        }
    }, {
        key: "onViewportToDataMatrixChanged",
        value: function onViewportToDataMatrixChanged() {
            var viewportToData = this.viewportToData;
            var dataToViewport = this.dataToViewport;

            geom_1.mat4.invert(dataToViewport, viewportToData);
            geom_1.rectifyTransformMatrixIfAxisAligned(dataToViewport);
            this.rpc.invoke('SliceView.updateView', { id: this.rpcId, viewportToData: viewportToData });
        }
    }, {
        key: "onHasValidViewport",
        value: function onHasValidViewport() {
            this.updateVisibleLayers();
        }
    }, {
        key: "updateRendering",
        value: function updateRendering() {
            if (!this.renderingStale || !this.hasValidViewport || this.width === 0 || this.height === 0) {
                return;
            }
            this.renderingStale = false;
            this.maybeUpdateVisibleChunks();
            var gl = this.gl;
            var offscreenFramebuffer = this.offscreenFramebuffer;
            var width = this.width;
            var height = this.height;

            offscreenFramebuffer.bind(width, height);
            gl.disable(gl.SCISSOR_TEST);
            // we have viewportToData
            // we need: matrix that maps input x to the output x axis, scaled by
            gl.clearStencil(0);
            gl.clearColor(0, 0, 0, 0);
            gl.colorMask(true, true, true, true);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.STENCIL_TEST);
            gl.disable(gl.DEPTH_TEST);
            gl.stencilOpSeparate(
            /*face=*/gl.FRONT_AND_BACK, /*sfail=*/gl.KEEP, /*dpfail=*/gl.KEEP,
            /*dppass=*/gl.REPLACE);
            // console.log("Drawing sliceview");
            var renderLayerNum = 0;
            for (var renderLayer of this.visibleLayerList) {
                gl.clear(gl.STENCIL_BUFFER_BIT);
                gl.stencilFuncSeparate(
                /*face=*/gl.FRONT_AND_BACK,
                /*func=*/gl.GREATER,
                /*ref=*/1,
                /*mask=*/1);
                if (renderLayerNum === 1) {
                    // Turn on blending after the first layer.
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }
                renderLayer.draw(this);
                ++renderLayerNum;
            }
            gl.disable(gl.BLEND);
            gl.disable(gl.STENCIL_TEST);
            offscreenFramebuffer.unbind();
        }
    }, {
        key: "maybeUpdateVisibleChunks",
        value: function maybeUpdateVisibleChunks() {
            if (!this.visibleChunksStale && !this.visibleSourcesStale) {
                // console.log("Not updating visible chunks");
                return false;
            }
            // console.log("Updating visible");
            this.visibleChunksStale = false;
            this.updateVisibleChunks();
            return true;
        }
    }, {
        key: "updateVisibleChunks",
        value: function updateVisibleChunks() {
            var allVisibleChunks = this.visibleChunks;
            function getLayoutObject(chunkLayout) {
                var visibleChunks = allVisibleChunks.get(chunkLayout);
                if (visibleChunks === undefined) {
                    visibleChunks = [];
                    allVisibleChunks.set(chunkLayout, visibleChunks);
                } else {
                    visibleChunks.length = 0;
                }
                return visibleChunks;
            }
            function addChunk(chunkLayout, visibleChunks, positionInChunks) {
                var key = geom_1.vec3Key(positionInChunks);
                visibleChunks[visibleChunks.length] = key;
            }
            this.computeVisibleChunks(getLayoutObject, addChunk);
        }
    }, {
        key: "disposed",
        value: function disposed() {
            for (var renderLayer of this.visibleLayers.keys()) {
                renderLayer.dispose();
            }
            this.visibleLayers.clear();
            this.visibleLayerList.length = 0;
        }
    }]);

    return SliceView;
}(base_2.SliceViewBase);
SliceView = __decorate([worker_rpc_1.registerSharedObjectOwner(base_2.SLICEVIEW_RPC_ID)], SliceView);
exports.SliceView = SliceView;
;
var chunkFormatHandlers = new Array();
function registerChunkFormatHandler(factory) {
    chunkFormatHandlers.push(factory);
}
exports.registerChunkFormatHandler = registerChunkFormatHandler;
function getChunkFormatHandler(gl, spec) {
    for (var handler of chunkFormatHandlers) {
        var result = handler(gl, spec);
        if (result != null) {
            return result;
        }
    }
    throw new Error('No chunk format handler found.');
}

var VolumeChunkSource = function (_frontend_1$ChunkSour) {
    _inherits(VolumeChunkSource, _frontend_1$ChunkSour);

    function VolumeChunkSource(chunkManager, spec) {
        _classCallCheck(this, VolumeChunkSource);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(VolumeChunkSource).call(this, chunkManager));

        _this2.spec = spec;
        _this2.chunkFormatHandler = _this2.registerDisposer(getChunkFormatHandler(chunkManager.chunkQueueManager.gl, spec));
        return _this2;
    }

    _createClass(VolumeChunkSource, [{
        key: "initializeCounterpart",
        value: function initializeCounterpart(rpc, options) {
            options['spec'] = this.spec.toObject();
            _get(Object.getPrototypeOf(VolumeChunkSource.prototype), "initializeCounterpart", this).call(this, rpc, options);
        }
    }, {
        key: "getValueAt",
        value: function getValueAt(position) {
            var chunkGridPosition = geom_1.vec3.create();
            var spec = this.spec;
            var chunkLayout = spec.chunkLayout;
            var offset = chunkLayout.offset;
            var chunkSize = chunkLayout.size;
            for (var i = 0; i < 3; ++i) {
                chunkGridPosition[i] = Math.floor((position[i] - offset[i]) / chunkSize[i]);
            }
            var key = geom_1.vec3Key(chunkGridPosition);
            var chunk = this.chunks.get(key);
            if (!chunk) {
                return null;
            }
            // Reuse temporary variable.
            var dataPosition = chunkGridPosition;
            var voxelSize = spec.voxelSize;
            for (var _i = 0; _i < 3; ++_i) {
                dataPosition[_i] = Math.floor((position[_i] - offset[_i] - chunkGridPosition[_i] * chunkSize[_i]) / voxelSize[_i]);
            }
            var chunkDataSize = chunk.chunkDataSize;
            for (var _i2 = 0; _i2 < 3; ++_i2) {
                if (dataPosition[_i2] >= chunkDataSize[_i2]) {
                    return undefined;
                }
            }
            var numChannels = spec.numChannels;

            if (numChannels === 1) {
                return chunk.getChannelValueAt(dataPosition, 0);
            } else {
                var result = new Array(numChannels);
                for (var _i3 = 0; _i3 < numChannels; ++_i3) {
                    result[_i3] = chunk.getChannelValueAt(dataPosition, _i3);
                }
                return result;
            }
        }
    }, {
        key: "getChunk",
        value: function getChunk(x) {
            return this.chunkFormatHandler.getChunk(this, x);
        }
    }, {
        key: "chunkFormat",
        get: function () {
            return this.chunkFormatHandler.chunkFormat;
        }
    }]);

    return VolumeChunkSource;
}(frontend_1.ChunkSource);

exports.VolumeChunkSource = VolumeChunkSource;
;
/**
 * Defines a VolumeChunkSource for which all state, other than the VolumeChunkSpecification, is
 * encapsulated in an object of type Parameters.
 */
function defineParameterizedVolumeChunkSource(parametersConstructor) {
    var newConstructor = function (_VolumeChunkSource) {
        _inherits(ParameterizedVolumeChunkSource, _VolumeChunkSource);

        function ParameterizedVolumeChunkSource(chunkManager, spec, parameters) {
            _classCallCheck(this, ParameterizedVolumeChunkSource);

            var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(ParameterizedVolumeChunkSource).call(this, chunkManager, spec));

            _this3.parameters = parameters;
            return _this3;
        }

        _createClass(ParameterizedVolumeChunkSource, [{
            key: "initializeCounterpart",
            value: function initializeCounterpart(rpc, options) {
                options['parameters'] = this.parameters;
                _get(Object.getPrototypeOf(ParameterizedVolumeChunkSource.prototype), "initializeCounterpart", this).call(this, rpc, options);
            }
        }, {
            key: "toString",
            value: function toString() {
                return parametersConstructor.stringify(this.parameters);
            }
        }], [{
            key: "get",
            value: function get(chunkManager, spec, parameters) {
                return chunkManager.getChunkSource(this, json_1.stableStringify({ parameters, spec: spec.toObject() }), () => new this(chunkManager, spec, parameters));
            }
        }]);

        return ParameterizedVolumeChunkSource;
    }(VolumeChunkSource);
    newConstructor.prototype.RPC_TYPE_ID = parametersConstructor.RPC_ID;
    return newConstructor;
}
exports.defineParameterizedVolumeChunkSource = defineParameterizedVolumeChunkSource;

var VolumeChunk = function (_frontend_1$Chunk) {
    _inherits(VolumeChunk, _frontend_1$Chunk);

    function VolumeChunk(source, x) {
        _classCallCheck(this, VolumeChunk);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(VolumeChunk).call(this, source));

        _this4.chunkGridPosition = x['chunkGridPosition'];
        _this4.chunkDataSize = x['chunkDataSize'] || source.spec.chunkDataSize;
        _this4.state = base_1.ChunkState.SYSTEM_MEMORY;
        return _this4;
    }

    _createClass(VolumeChunk, [{
        key: "chunkFormat",
        get: function () {
            return this.source.chunkFormat;
        }
    }]);

    return VolumeChunk;
}(frontend_1.Chunk);

exports.VolumeChunk = VolumeChunk;
;
/**
 * Helper for rendering a SliceView that has been pre-rendered to a texture.
 */

var SliceViewRenderHelper = function (_disposable_1$RefCoun) {
    _inherits(SliceViewRenderHelper, _disposable_1$RefCoun);

    function SliceViewRenderHelper(gl, emitter) {
        _classCallCheck(this, SliceViewRenderHelper);

        var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(SliceViewRenderHelper).call(this));

        _this5.gl = gl;
        _this5.copyVertexPositionsBuffer = _this5.registerDisposer(buffer_1.Buffer.fromData(_this5.gl, new Float32Array([-1, -1, 0, 1, -1, +1, 0, 1, +1, +1, 0, 1, +1, -1, 0, 1]), _this5.gl.ARRAY_BUFFER, _this5.gl.STATIC_DRAW));
        _this5.copyTexCoordsBuffer = _this5.registerDisposer(buffer_1.Buffer.fromData(_this5.gl, new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]), _this5.gl.ARRAY_BUFFER, _this5.gl.STATIC_DRAW));
        _this5.textureCoordinateAdjustment = new Float32Array(4);
        var builder = new shader_1.ShaderBuilder(gl);
        builder.addVarying('vec2', 'vTexCoord');
        builder.addUniform('sampler2D', 'uSampler');
        builder.addInitializer(shader => {
            gl.uniform1i(shader.uniform('uSampler'), 0);
        });
        builder.addUniform('vec4', 'uColorFactor');
        builder.addUniform('vec4', 'uBackgroundColor');
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.addUniform('vec4', 'uTextureCoordinateAdjustment');
        builder.require(emitter);
        builder.setFragmentMain(`
vec4 sampledColor = texture2D(uSampler, vTexCoord);
if (sampledColor.a == 0.0) {
  sampledColor = uBackgroundColor;
}
emit(sampledColor * uColorFactor, vec4(0,0,0,0));
`);
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.addAttribute('vec2', 'aTexCoord');
        builder.setVertexMain(`
vTexCoord = uTextureCoordinateAdjustment.xy + aTexCoord * uTextureCoordinateAdjustment.zw;
gl_Position = uProjectionMatrix * aVertexPosition;
`);
        _this5.shader = _this5.registerDisposer(builder.build());
        return _this5;
    }

    _createClass(SliceViewRenderHelper, [{
        key: "draw",
        value: function draw(texture, projectionMatrix, colorFactor, backgroundColor, xStart, yStart, xEnd, yEnd) {
            var gl = this.gl;
            var shader = this.shader;
            var textureCoordinateAdjustment = this.textureCoordinateAdjustment;

            textureCoordinateAdjustment[0] = xStart;
            textureCoordinateAdjustment[1] = yStart;
            textureCoordinateAdjustment[2] = xEnd - xStart;
            textureCoordinateAdjustment[3] = yEnd - yStart;
            shader.bind();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, projectionMatrix);
            gl.uniform4fv(shader.uniform('uColorFactor'), colorFactor);
            gl.uniform4fv(shader.uniform('uBackgroundColor'), backgroundColor);
            gl.uniform4fv(shader.uniform('uTextureCoordinateAdjustment'), textureCoordinateAdjustment);
            var aVertexPosition = shader.attribute('aVertexPosition');
            this.copyVertexPositionsBuffer.bindToVertexAttrib(aVertexPosition, 4);
            var aTexCoord = shader.attribute('aTexCoord');
            this.copyTexCoordsBuffer.bindToVertexAttrib(aTexCoord, 2);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            gl.disableVertexAttribArray(aVertexPosition);
            gl.disableVertexAttribArray(aTexCoord);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }], [{
        key: "get",
        value: function get(gl, key, emitter) {
            return gl.memoize.get(key, () => {
                return new SliceViewRenderHelper(gl, emitter);
            });
        }
    }]);

    return SliceViewRenderHelper;
}(disposable_1.RefCounted);

exports.SliceViewRenderHelper = SliceViewRenderHelper;
;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var chunk_layout_1 = __webpack_require__(62);
var array_1 = __webpack_require__(63);
var compare_1 = __webpack_require__(64);
var data_type_1 = __webpack_require__(65);
exports.DATA_TYPE_BYTES = data_type_1.DATA_TYPE_BYTES;
exports.DataType = data_type_1.DataType;
var geom_1 = __webpack_require__(9);
var worker_rpc_1 = __webpack_require__(22);
var DEBUG_CHUNK_INTERSECTIONS = false;
var DEBUG_VISIBLE_SOURCES = false;
/**
 * Heuristic estimate of the slice area contained within a chunk of the
 * specified size.
 */
function estimateSliceAreaPerChunk(xAxis, yAxis, chunkSize) {
    var w = 0;
    var h = w;
    for (var i = 0; i < 3; ++i) {
        var chunkSizeValue = chunkSize[i];
        w = Math.max(w, chunkSizeValue * Math.abs(xAxis[i]));
        h = Math.max(h, chunkSizeValue * Math.abs(yAxis[i]));
    }
    return w * h;
}
/**
 * All valid chunks are in the range [lowerBound, upperBound).
 *
 * @param lowerBound Output parameter for lowerBound.
 * @param upperBound Output parameter for upperBound.
 * @param sources Sources for which to compute the chunk bounds.
 */
function computeSourcesChunkBounds(lowerBound, upperBound, sources) {
    for (var i = 0; i < 3; ++i) {
        lowerBound[i] = Number.POSITIVE_INFINITY;
        upperBound[i] = Number.NEGATIVE_INFINITY;
    }
    for (var source of sources) {
        var spec = source.spec;
        var lowerChunkBound = spec.lowerChunkBound;
        var upperChunkBound = spec.upperChunkBound;

        for (var _i = 0; _i < 3; ++_i) {
            lowerBound[_i] = Math.min(lowerBound[_i], lowerChunkBound[_i]);
            upperBound[_i] = Math.max(upperBound[_i], upperChunkBound[_i]);
        }
    }
}
var BoundsComparisonResult;
(function (BoundsComparisonResult) {
    // Needle is fully outside haystack.
    BoundsComparisonResult[BoundsComparisonResult["FULLY_OUTSIDE"] = 0] = "FULLY_OUTSIDE";
    // Needle is fully inside haystack.
    BoundsComparisonResult[BoundsComparisonResult["FULLY_INSIDE"] = 1] = "FULLY_INSIDE";
    // Needle is partially inside haystack.
    BoundsComparisonResult[BoundsComparisonResult["PARTIALLY_INSIDE"] = 2] = "PARTIALLY_INSIDE";
})(BoundsComparisonResult || (BoundsComparisonResult = {}));
function compareBoundsSingleDimension(needleLower, needleUpper, haystackLower, haystackUpper) {
    if (needleLower >= haystackUpper || needleUpper <= haystackLower) {
        return BoundsComparisonResult.FULLY_OUTSIDE;
    }
    if (needleLower >= haystackLower && needleUpper <= haystackUpper) {
        return BoundsComparisonResult.FULLY_INSIDE;
    }
    return BoundsComparisonResult.PARTIALLY_INSIDE;
}
function compareBounds(needleLowerBound, needleUpperBound, haystackLowerBound, haystackUpperBound) {
    var curResult = BoundsComparisonResult.FULLY_INSIDE;
    for (var i = 0; i < 3; ++i) {
        var newResult = compareBoundsSingleDimension(needleLowerBound[i], needleUpperBound[i], haystackLowerBound[i], haystackUpperBound[i]);
        switch (newResult) {
            case BoundsComparisonResult.FULLY_OUTSIDE:
                return newResult;
            case BoundsComparisonResult.PARTIALLY_INSIDE:
                curResult = newResult;
                break;
        }
    }
    return curResult;
}
function pickBestAlternativeSource(xAxis, yAxis, alternatives) {
    var numAlternatives = alternatives.length;
    var bestAlternativeIndex = 0;
    if (DEBUG_VISIBLE_SOURCES) {
        console.log(alternatives);
    }
    if (numAlternatives > 1) {
        var bestSliceArea = 0;
        for (var alternativeIndex = 0; alternativeIndex < numAlternatives; ++alternativeIndex) {
            var alternative = alternatives[alternativeIndex];
            var sliceArea = estimateSliceAreaPerChunk(xAxis, yAxis, alternative.spec.chunkLayout.size);
            if (DEBUG_VISIBLE_SOURCES) {
                console.log(`xAxis = ${ xAxis }, yAxis = ${ yAxis }, chunksize = ${ alternative.spec.chunkLayout.size }, sliceArea = ${ sliceArea }`);
            }
            if (sliceArea > bestSliceArea) {
                bestSliceArea = sliceArea;
                bestAlternativeIndex = alternativeIndex;
            }
        }
    }
    return alternatives[bestAlternativeIndex];
}

var SliceViewBase = function (_worker_rpc_1$SharedO) {
    _inherits(SliceViewBase, _worker_rpc_1$SharedO);

    function SliceViewBase() {
        _classCallCheck(this, SliceViewBase);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SliceViewBase).call(this));

        _this.width = -1;
        _this.height = -1;
        _this.hasViewportToData = false;
        /**
         * Specifies whether width, height, and viewportToData are valid.
         */
        _this.hasValidViewport = false;
        // Transforms (x,y) viewport coordinates in the range:
        //
        // x=[left: -width/2, right: width/2] and
        //
        // y=[top: -height/2, bottom: height/2],
        //
        // to data coordinates.
        _this.viewportToData = geom_1.mat4.create();
        // Normalized x, y, and z viewport axes in data coordinate space.
        _this.viewportAxes = [geom_1.vec4.create(), geom_1.vec4.create(), geom_1.vec4.create()];
        // Viewport axes used for selecting visible sources.
        _this.previousViewportAxes = [geom_1.vec3.create(), geom_1.vec3.create()];
        _this.centerDataPosition = geom_1.vec3.create();
        _this.viewportPlaneDistanceToOrigin = 0;
        /**
         * For each visible ChunkLayout, maps each visible VolumeChunkSource to its priority index.
         */
        _this.visibleChunkLayouts = new Map();
        _this.visibleLayers = new Map();
        _this.visibleSourcesStale = true;
        _this.pixelSize = 0;
        geom_1.mat4.identity(_this.viewportToData);
        return _this;
    }
    /**
     * Called when hasValidViewport == true and the viewport width/height or data transform matrix
     * changes.
     */


    _createClass(SliceViewBase, [{
        key: 'onViewportChanged',
        value: function onViewportChanged() {}
    }, {
        key: 'maybeSetHasValidViewport',
        value: function maybeSetHasValidViewport() {
            if (!this.hasValidViewport && this.width !== -1 && this.height !== -1 && this.hasViewportToData) {
                this.hasValidViewport = true;
                this.onHasValidViewport();
            }
            if (this.hasValidViewport) {
                this.onViewportChanged();
            }
        }
    }, {
        key: 'onHasValidViewport',
        value: function onHasValidViewport() {}
    }, {
        key: 'setViewportSize',
        value: function setViewportSize(width, height) {
            if (width !== this.width || height !== this.height) {
                this.width = width;
                this.height = height;
                this.maybeSetHasValidViewport();
                return true;
            }
            return false;
        }
    }, {
        key: 'setViewportToDataMatrix',
        value: function setViewportToDataMatrix(mat) {
            if (this.hasViewportToData && geom_1.mat4.equals(this.viewportToData, mat)) {
                return false;
            }
            this.hasViewportToData = true;
            var viewportToData = this.viewportToData;

            geom_1.mat4.copy(viewportToData, mat);
            geom_1.rectifyTransformMatrixIfAxisAligned(viewportToData);
            geom_1.vec3.transformMat4(this.centerDataPosition, geom_1.kZeroVec, mat);
            // Initialize to zero to avoid confusing TypeScript compiler.
            var newPixelSize = 0;
            // Swap previousViewportAxes with viewportAxes.
            var viewportAxes = this.viewportAxes;
            var previousViewportAxes = this.previousViewportAxes;
            // Compute axes.
            for (var i = 0; i < 3; ++i) {
                var a = viewportAxes[i];
                geom_1.vec4.transformMat4(a, geom_1.kAxes[i], viewportToData);
                // a[3] is guaranteed to be 0.
                if (i === 0) {
                    newPixelSize = geom_1.vec3.length(a);
                }
                geom_1.vec4.normalize(a, a);
            }
            this.viewportAxes = viewportAxes;
            this.previousViewportAxes = previousViewportAxes;
            if (!compare_1.approxEqual(newPixelSize, this.pixelSize) || geom_1.vec3.dot(viewportAxes[0], previousViewportAxes[0]) < 0.95 || geom_1.vec3.dot(viewportAxes[1], previousViewportAxes[1]) < 0.95) {
                geom_1.vec3.copy(previousViewportAxes[0], viewportAxes[0]);
                geom_1.vec3.copy(previousViewportAxes[1], viewportAxes[1]);
                this.visibleSourcesStale = true;
                this.pixelSize = newPixelSize;
            }
            // Compute viewport plane distance to origin.
            this.viewportPlaneDistanceToOrigin = geom_1.vec3.dot(this.centerDataPosition, this.viewportAxes[2]);
            this.onViewportToDataMatrixChanged();
            this.maybeSetHasValidViewport();
            return true;
        }
    }, {
        key: 'onViewportToDataMatrixChanged',
        value: function onViewportToDataMatrixChanged() {}
        /**
         * Computes the list of sources to use for each visible layer, based on the
         * current pixelSize.
         */

    }, {
        key: 'updateVisibleSources',
        value: function updateVisibleSources() {
            if (!this.visibleSourcesStale) {
                return;
            }
            this.visibleSourcesStale = false;
            // Increase pixel size by a small margin.
            var pixelSize = this.pixelSize * 1.1;
            // console.log("pixelSize", pixelSize);
            var visibleChunkLayouts = this.visibleChunkLayouts;

            var _viewportAxes = _slicedToArray(this.viewportAxes, 2);

            var xAxis = _viewportAxes[0];
            var yAxis = _viewportAxes[1];

            var visibleLayers = this.visibleLayers;
            visibleChunkLayouts.clear();

            var _loop = function (_ref) {
                _ref2 = _slicedToArray(_ref, 2);
                var renderLayer = _ref2[0];
                var visibleSources = _ref2[1];

                visibleSources.length = 0;
                var sources = renderLayer.sources;
                var numSources = sources.length;
                var scaleIndex = void 0;
                // At the smallest scale, all alternative sources must have the same voxel size, which is
                // considered to be the base voxel size.
                var smallestVoxelSize = sources[0][0].spec.voxelSize;
                /**
                 * Determines whether we should continue to look for a finer-resolution source *after* one
                 * with the specified voxelSize.
                 */
                var canImproveOnVoxelSize = voxelSize => {
                    for (var i = 0; i < 3; ++i) {
                        var size = voxelSize[i];
                        // If size <= pixelSize, no need for improvement.
                        // If size === smallestVoxelSize, also no need for improvement.
                        if (size > pixelSize && size > smallestVoxelSize[i]) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * Registers a source as being visible.  This should be called with consecutively decreasing
                 * values of scaleIndex.
                 */
                var addVisibleSource = (source, scaleIndex) => {
                    // Add to end of visibleSources list.  We will reverse the list after all sources are added.
                    visibleSources[visibleSources.length++] = source;
                    var chunkLayout = source.spec.chunkLayout;
                    var existingSources = visibleChunkLayouts.get(chunkLayout);
                    if (existingSources === undefined) {
                        existingSources = new Map();
                        visibleChunkLayouts.set(chunkLayout, existingSources);
                    }
                    existingSources.set(source, numSources - scaleIndex - 1);
                };
                scaleIndex = numSources - 1;
                while (true) {
                    var source = pickBestAlternativeSource(xAxis, yAxis, sources[scaleIndex]);
                    addVisibleSource(source, scaleIndex);
                    if (scaleIndex === 0 || !canImproveOnVoxelSize(source.spec.voxelSize)) {
                        break;
                    }
                    --scaleIndex;
                }
                // Reverse visibleSources list since we added sources from coarsest to finest resolution, but
                // we want them ordered from finest to coarsest.
                visibleSources.reverse();
            };

            for (var _ref of visibleLayers) {
                var _ref2;

                _loop(_ref);
            }
        }
    }, {
        key: 'computeVisibleChunks',
        value: function computeVisibleChunks(getLayoutObject, addChunk) {
            this.updateVisibleSources();
            var center = this.centerDataPosition;
            // Lower and upper bound in global data coordinates.
            var dataLowerBound = geom_1.vec3.clone(center);
            var dataUpperBound = geom_1.vec3.clone(center);
            var corner = geom_1.vec3.create();
            for (var xScalar of [-this.width / 2, this.width / 2]) {
                for (var yScalar of [-this.height / 2, this.height / 2]) {
                    geom_1.vec3.scale(corner, geom_1.kAxes[0], xScalar);
                    geom_1.vec3.scaleAndAdd(corner, corner, geom_1.kAxes[1], yScalar);
                    geom_1.vec3.transformMat4(corner, corner, this.viewportToData);
                    geom_1.vec3.min(dataLowerBound, dataLowerBound, corner);
                    geom_1.vec3.max(dataUpperBound, dataUpperBound, corner);
                }
            }
            // console.log("data bounds", dataLowerBound, dataUpperBound);
            var lowerBound = geom_1.vec3.create();
            var upperBound = geom_1.vec3.create();
            // Vertex with maximal dot product with the positive viewport plane normal.
            // Implicitly, negativeVertex = 1 - positiveVertex.
            var positiveVertex = geom_1.vec3.create();
            var planeNormal = this.viewportAxes[2];
            for (var i = 0; i < 3; ++i) {
                if (planeNormal[i] > 0) {
                    positiveVertex[i] = 1;
                }
            }
            // Sources whose bounds partially contain the current bounding box.
            var partiallyVisibleSources = new Array();
            // Sources whose bounds fully contain the current bounding box.
            var fullyVisibleSources = new Array();
            this.visibleChunkLayouts.forEach((visibleSources, chunkLayout) => {
                var layoutObject = getLayoutObject(chunkLayout);
                var chunkSize = chunkLayout.size;
                var offset = chunkLayout.offset;
                var planeDistanceToOrigin = this.viewportPlaneDistanceToOrigin - geom_1.vec3.dot(offset, this.viewportAxes[2]);
                computeSourcesChunkBounds(lowerBound, upperBound, visibleSources.keys());
                if (DEBUG_CHUNK_INTERSECTIONS) {
                    console.log(`Initial sources chunk bounds: ${ geom_1.vec3.str(lowerBound) }, ${ geom_1.vec3.str(upperBound) }, data bounds: ${ geom_1.vec3.str(dataLowerBound) }, ${ geom_1.vec3.str(dataUpperBound) }, offset = ${ geom_1.vec3.str(offset) }, chunkSize = ${ geom_1.vec3.str(chunkSize) }`);
                }
                for (var _i2 = 0; _i2 < 3; ++_i2) {
                    lowerBound[_i2] = Math.max(lowerBound[_i2], Math.floor((dataLowerBound[_i2] - offset[_i2]) / chunkSize[_i2]));
                    //
                    upperBound[_i2] = Math.min(upperBound[_i2], Math.floor((dataUpperBound[_i2] - offset[_i2]) / chunkSize[_i2] + 1));
                }
                // console.log('chunkBounds', lowerBound, upperBound);
                // Checks whether [lowerBound, upperBound) intersects the viewport plane.
                //
                // positiveVertexDistanceToOrigin = dot(planeNormal, lowerBound +
                // positiveVertex * (upperBound - lowerBound)) - planeDistanceToOrigin;
                // negativeVertexDistanceToOrigin = dot(planeNormal, lowerBound +
                // negativeVertex * (upperBound - lowerBound)) - planeDistanceToOrigin;
                //
                // positive vertex must have positive distance, and negative vertex must
                // have negative distance.
                function intersectsPlane() {
                    var positiveVertexDistanceToOrigin = 0;
                    var negativeVertexDistanceToOrigin = 0;
                    // Check positive vertex.
                    for (var _i3 = 0; _i3 < 3; ++_i3) {
                        var chunkSizeValue = chunkSize[_i3];
                        var normalValue = planeNormal[_i3];
                        var lowerValue = lowerBound[_i3];
                        var upperValue = upperBound[_i3];
                        var diff = upperValue - lowerValue;
                        var positiveOffset = positiveVertex[_i3] * diff;
                        // console.log(
                        //     normalValue, lowerValue, upperValue, diff, positiveOffset,
                        //     positiveVertexDistanceToOrigin, negativeVertexDistanceToOrigin);
                        positiveVertexDistanceToOrigin += normalValue * chunkSizeValue * (lowerValue + positiveOffset);
                        negativeVertexDistanceToOrigin += normalValue * chunkSizeValue * (lowerValue + diff - positiveOffset);
                    }
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log(`    planeNormal = ${ planeNormal }`);
                        console.log('    {positive,negative}VertexDistanceToOrigin: ', positiveVertexDistanceToOrigin, negativeVertexDistanceToOrigin, planeDistanceToOrigin);
                        console.log('    intersectsPlane:', negativeVertexDistanceToOrigin, planeDistanceToOrigin, positiveVertexDistanceToOrigin);
                    }
                    if (positiveVertexDistanceToOrigin < planeDistanceToOrigin) {
                        return false;
                    }
                    return negativeVertexDistanceToOrigin <= planeDistanceToOrigin;
                }
                fullyVisibleSources.length = 0;
                partiallyVisibleSources.length = 0;
                for (var source of visibleSources.keys()) {
                    var spec = source.spec;
                    var result = compareBounds(lowerBound, upperBound, spec.lowerChunkBound, spec.upperChunkBound);
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log(`Comparing source bounds lowerBound=${ geom_1.vec3.str(lowerBound) }, upperBound=${ geom_1.vec3.str(upperBound) }, lowerChunkBound=${ geom_1.vec3.str(spec.lowerChunkBound) }, upperChunkBound=${ geom_1.vec3.str(spec.upperChunkBound) }, got ${ BoundsComparisonResult[result] }`, spec, source);
                    }
                    switch (result) {
                        case BoundsComparisonResult.FULLY_INSIDE:
                            fullyVisibleSources.push(source);
                            break;
                        case BoundsComparisonResult.PARTIALLY_INSIDE:
                            partiallyVisibleSources.push(source);
                            break;
                    }
                }
                var partiallyVisibleSourcesLength = partiallyVisibleSources.length;
                // Mutates lowerBound and upperBound while running, but leaves them the
                // same once finished.
                function checkBounds(nextSplitDim) {
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log(`chunk bounds: ${ lowerBound } ${ upperBound } fullyVisible: ${ fullyVisibleSources } partiallyVisible: ${ partiallyVisibleSources.slice(0, partiallyVisibleSourcesLength) }`);
                    }
                    if (fullyVisibleSources.length === 0 && partiallyVisibleSourcesLength === 0) {
                        if (DEBUG_CHUNK_INTERSECTIONS) {
                            console.log('  no visible sources');
                        }
                        return;
                    }
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log(`Check bounds: [ ${ geom_1.vec3.str(lowerBound) }, ${ geom_1.vec3.str(upperBound) } ]`);
                    }
                    var volume = 1;
                    for (var _i4 = 0; _i4 < 3; ++_i4) {
                        volume *= Math.max(0, upperBound[_i4] - lowerBound[_i4]);
                    }
                    if (volume === 0) {
                        if (DEBUG_CHUNK_INTERSECTIONS) {
                            console.log('  volume == 0');
                        }
                        return;
                    }
                    if (!intersectsPlane()) {
                        if (DEBUG_CHUNK_INTERSECTIONS) {
                            console.log('  doesn\'t intersect plane');
                        }
                        return;
                    }
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log('Within bounds: [' + geom_1.vec3.str(lowerBound) + ', ' + geom_1.vec3.str(upperBound) + ']');
                    }
                    if (volume === 1) {
                        addChunk(chunkLayout, layoutObject, lowerBound, fullyVisibleSources);
                        return;
                    }
                    var dimLower, dimUpper, diff;
                    while (true) {
                        dimLower = lowerBound[nextSplitDim];
                        dimUpper = upperBound[nextSplitDim];
                        diff = dimUpper - dimLower;
                        if (diff === 1) {
                            nextSplitDim = (nextSplitDim + 1) % 3;
                        } else {
                            break;
                        }
                    }
                    var splitPoint = dimLower + Math.floor(0.5 * diff);
                    var newNextSplitDim = (nextSplitDim + 1) % 3;
                    var fullyVisibleSourcesLength = fullyVisibleSources.length;
                    upperBound[nextSplitDim] = splitPoint;
                    var oldPartiallyVisibleSourcesLength = partiallyVisibleSourcesLength;
                    function adjustSources() {
                        partiallyVisibleSourcesLength = array_1.partitionArray(partiallyVisibleSources, 0, oldPartiallyVisibleSourcesLength, source => {
                            var spec = source.spec;
                            var result = compareBounds(lowerBound, upperBound, spec.lowerChunkBound, spec.upperChunkBound);
                            switch (result) {
                                case BoundsComparisonResult.PARTIALLY_INSIDE:
                                    return true;
                                case BoundsComparisonResult.FULLY_INSIDE:
                                    fullyVisibleSources.push(source);
                                default:
                                    return false;
                            }
                        });
                    }
                    adjustSources();
                    checkBounds(newNextSplitDim);
                    // Truncate list of fully visible sources.
                    fullyVisibleSources.length = fullyVisibleSourcesLength;
                    // Restore partiallyVisibleSources.
                    partiallyVisibleSourcesLength = oldPartiallyVisibleSourcesLength;
                    upperBound[nextSplitDim] = dimUpper;
                    lowerBound[nextSplitDim] = splitPoint;
                    adjustSources();
                    checkBounds(newNextSplitDim);
                    lowerBound[nextSplitDim] = dimLower;
                    // Truncate list of fully visible sources.
                    fullyVisibleSources.length = fullyVisibleSourcesLength;
                    // Restore partiallyVisibleSources.
                    partiallyVisibleSourcesLength = oldPartiallyVisibleSourcesLength;
                }
                checkBounds(0);
            });
        }
    }]);

    return SliceViewBase;
}(worker_rpc_1.SharedObject);

exports.SliceViewBase = SliceViewBase;
;
/**
 * Specifies the interpretation of volumetric data.
 */
(function (VolumeType) {
    VolumeType[VolumeType["UNKNOWN"] = 0] = "UNKNOWN";
    VolumeType[VolumeType["IMAGE"] = 1] = "IMAGE";
    VolumeType[VolumeType["SEGMENTATION"] = 2] = "SEGMENTATION";
})(exports.VolumeType || (exports.VolumeType = {}));
var VolumeType = exports.VolumeType;
/**
 * By default, choose a chunk size with at most 2^18 = 262144 voxels.
 */
exports.DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;
/**
 * Determines a near-isotropic (in nanometers) block size.  All dimensions will be powers of 2, and
 * will not exceed upperVoxelBound - lowerVoxelBound.  The total number of voxels will not exceed
 * maxVoxelsPerChunkLog2.
 */
function getNearIsotropicBlockSize(options) {
    var voxelSize = options.voxelSize;
    var _options$lowerVoxelBo = options.lowerVoxelBound;
    var lowerVoxelBound = _options$lowerVoxelBo === undefined ? geom_1.kZeroVec : _options$lowerVoxelBo;
    var upperVoxelBound = options.upperVoxelBound;
    var _options$maxVoxelsPer = options.maxVoxelsPerChunkLog2;
    var maxVoxelsPerChunkLog2 = _options$maxVoxelsPer === undefined ? exports.DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 : _options$maxVoxelsPer;

    var chunkDataSize = geom_1.vec3.fromValues(1, 1, 1);
    var maxChunkDataSize = void 0;
    if (upperVoxelBound === undefined) {
        maxChunkDataSize = geom_1.kInfinityVec;
    } else {
        maxChunkDataSize = geom_1.vec3.create();
        for (var i = 0; i < 3; ++i) {
            maxChunkDataSize[i] = Math.pow(2, Math.floor(Math.log2(upperVoxelBound[i] - lowerVoxelBound[i])));
        }
    }
    // Determine the dimension in which chunkDataSize should be increased.  This is the smallest
    // dimension (in nanometers) that is < maxChunkDataSize (in voxels).
    //
    // Returns -1 if there is no such dimension.
    function findNextDimension() {
        var minSize = Infinity;
        var minDimension = -1;
        for (var _i5 = 0; _i5 < 3; ++_i5) {
            if (chunkDataSize[_i5] >= maxChunkDataSize[_i5]) {
                continue;
            }
            var size = chunkDataSize[_i5] * voxelSize[_i5];
            if (size < minSize) {
                minSize = size;
                minDimension = _i5;
            }
        }
        return minDimension;
    }
    for (var _i6 = 0; _i6 < maxVoxelsPerChunkLog2; ++_i6) {
        var nextDim = findNextDimension();
        if (nextDim === -1) {
            break;
        }
        chunkDataSize[nextDim] *= 2;
    }
    return chunkDataSize;
}
exports.getNearIsotropicBlockSize = getNearIsotropicBlockSize;
var tempVec3 = geom_1.vec3.create();
/**
 * Computes a 3-d block size that has depth 1 in flatDimension and is near-isotropic (in nanometers)
 * in the other two dimensions.  The remaining options are the same as for
 * getNearIsotropicBlockSize.
 */
function getTwoDimensionalBlockSize(options) {
    var _options$lowerVoxelBo2 = options.lowerVoxelBound;
    var lowerVoxelBound = _options$lowerVoxelBo2 === undefined ? geom_1.kZeroVec : _options$lowerVoxelBo2;
    var _options$upperVoxelBo = options.upperVoxelBound;
    var upperVoxelBound = _options$upperVoxelBo === undefined ? geom_1.kInfinityVec : _options$upperVoxelBo;
    var flatDimension = options.flatDimension;
    var voxelSize = options.voxelSize;
    var maxVoxelsPerChunkLog2 = options.maxVoxelsPerChunkLog2;

    geom_1.vec3.subtract(tempVec3, upperVoxelBound, lowerVoxelBound);
    tempVec3[flatDimension] = 1;
    return getNearIsotropicBlockSize({ voxelSize, upperVoxelBound: tempVec3, maxVoxelsPerChunkLog2 });
}
exports.getTwoDimensionalBlockSize = getTwoDimensionalBlockSize;
/**
 * Specifies a chunk layout and voxel size.
 */

var VolumeChunkSpecification = function () {
    function VolumeChunkSpecification(options) {
        _classCallCheck(this, VolumeChunkSpecification);

        var dataType = options.dataType;
        var _options$lowerVoxelBo3 = options.lowerVoxelBound;
        var lowerVoxelBound = _options$lowerVoxelBo3 === undefined ? geom_1.kZeroVec : _options$lowerVoxelBo3;
        var upperVoxelBound = options.upperVoxelBound;
        var chunkDataSize = options.chunkDataSize;
        var _options$chunkLayoutO = options.chunkLayoutOffset;
        var chunkLayoutOffset = _options$chunkLayoutO === undefined ? geom_1.kZeroVec : _options$chunkLayoutO;
        var voxelSize = options.voxelSize;
        var _options$baseVoxelOff = options.baseVoxelOffset;
        var baseVoxelOffset = _options$baseVoxelOff === undefined ? geom_1.kZeroVec : _options$baseVoxelOff;
        var numChannels = options.numChannels;
        var _options$lowerClipBou = options.lowerClipBound;
        var lowerClipBound = _options$lowerClipBou === undefined ? geom_1.vec3.multiply(geom_1.vec3.create(), voxelSize, lowerVoxelBound) : _options$lowerClipBou;
        var _options$upperClipBou = options.upperClipBound;
        var upperClipBound = _options$upperClipBou === undefined ? geom_1.vec3.multiply(geom_1.vec3.create(), voxelSize, upperVoxelBound) : _options$upperClipBou;

        this.dataType = options.dataType;
        this.numChannels = numChannels;
        this.voxelSize = voxelSize;
        this.chunkDataSize = chunkDataSize;
        this.chunkLayout = chunk_layout_1.ChunkLayout.get(geom_1.vec3.multiply(geom_1.vec3.create(), options.chunkDataSize, voxelSize), chunkLayoutOffset);
        this.chunkBytes = geom_1.prod3(options.chunkDataSize) * data_type_1.DATA_TYPE_BYTES[dataType] * numChannels;
        this.lowerClipBound = lowerClipBound;
        this.upperClipBound = upperClipBound;
        this.lowerVoxelBound = lowerVoxelBound;
        this.upperVoxelBound = upperVoxelBound;
        this.baseVoxelOffset = baseVoxelOffset;
        var lowerChunkBound = this.lowerChunkBound = geom_1.vec3.create();
        var upperChunkBound = this.upperChunkBound = geom_1.vec3.create();
        for (var i = 0; i < 3; ++i) {
            lowerChunkBound[i] = Math.floor(lowerVoxelBound[i] / chunkDataSize[i]);
            upperChunkBound[i] = Math.floor((upperVoxelBound[i] - 1) / chunkDataSize[i] + 1);
        }
        this.compressedSegmentationBlockSize = options.compressedSegmentationBlockSize;
    }

    _createClass(VolumeChunkSpecification, [{
        key: 'toObject',
        value: function toObject() {
            return {
                chunkLayoutOffset: this.chunkLayout.offset,
                numChannels: this.numChannels,
                chunkDataSize: this.chunkDataSize,
                voxelSize: this.voxelSize,
                dataType: this.dataType,
                lowerVoxelBound: this.lowerVoxelBound,
                upperVoxelBound: this.upperVoxelBound,
                lowerClipBound: this.lowerClipBound,
                upperClipBound: this.upperClipBound,
                baseVoxelOffset: this.baseVoxelOffset,
                compressedSegmentationBlockSize: this.compressedSegmentationBlockSize
            };
        }
        /**
         * Returns a VolumeChunkSpecification with default compression specified if suitable for the
         * volumeType.
         */

    }], [{
        key: 'fromObject',
        value: function fromObject(msg) {
            return new VolumeChunkSpecification(msg);
        }
    }, {
        key: 'withDefaultCompression',
        value: function withDefaultCompression(options) {
            var compressedSegmentationBlockSize = options.compressedSegmentationBlockSize;
            var dataType = options.dataType;
            var voxelSize = options.voxelSize;
            var lowerVoxelBound = options.lowerVoxelBound;
            var upperVoxelBound = options.upperVoxelBound;

            if (compressedSegmentationBlockSize === undefined && options.volumeType === VolumeType.SEGMENTATION && (dataType === data_type_1.DataType.UINT32 || dataType === data_type_1.DataType.UINT64)) {
                compressedSegmentationBlockSize = getNearIsotropicBlockSize({ voxelSize, lowerVoxelBound, upperVoxelBound, maxVoxelsPerChunkLog2: 9 });
            }
            return new VolumeChunkSpecification(Object.assign({}, options, { compressedSegmentationBlockSize }));
        }
    }, {
        key: 'getDefaults',
        value: function getDefaults(options) {
            var _options$chunkDataSiz = options.chunkDataSizes;
            var chunkDataSizes = _options$chunkDataSiz === undefined ? [getNearIsotropicBlockSize(options)] : _options$chunkDataSiz;

            return chunkDataSizes.map(chunkDataSize => VolumeChunkSpecification.withDefaultCompression(Object.assign({}, options, { chunkDataSize })));
        }
    }]);

    return VolumeChunkSpecification;
}();

exports.VolumeChunkSpecification = VolumeChunkSpecification;
;
exports.SLICEVIEW_RPC_ID = 'SliceView';
exports.SLICEVIEW_RENDERLAYER_RPC_ID = 'sliceview/RenderLayer';

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var geom_1 = __webpack_require__(9);
/**
 * @param size Size of each chunk in nanometers.
 * @param offset Offset of chunk boundaries relative to
 *   (0,0,0).  It should be the case that 0 >= offset > size.
 */

var ChunkLayout = function () {
    function ChunkLayout(size, offset) {
        _classCallCheck(this, ChunkLayout);

        this.size = geom_1.vec3.clone(size);
        if (offset === undefined) {
            this.offset = geom_1.vec3.create();
        } else {
            this.offset = geom_1.vec3.clone(offset);
        }
    }

    _createClass(ChunkLayout, [{
        key: 'toObject',
        value: function toObject(msg) {
            msg['size'] = this.size;
            msg['offset'] = this.offset;
        }
    }], [{
        key: 'get',
        value: function get(size) {
            var offset = arguments.length <= 1 || arguments[1] === undefined ? geom_1.kZeroVec : arguments[1];

            var cache = ChunkLayout.cache;
            var key = `${ geom_1.vec3Key(size) }+${ geom_1.vec3Key(offset) }`;
            var obj = cache.get(key);
            if (obj === undefined) {
                obj = new ChunkLayout(size, offset);
                cache.set(key, obj);
            }
            return obj;
        }
    }, {
        key: 'fromObject',
        value: function fromObject(msg) {
            return ChunkLayout.get(msg['size'], msg['offset']);
        }
    }]);

    return ChunkLayout;
}();

ChunkLayout.cache = new Map();
exports.ChunkLayout = ChunkLayout;
;

/***/ },
/* 63 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Partitions array[start:end] such that all elements for which predicate
 * returns true are before the elements for which predicate returns false.
 *
 * predicate will be called exactly once for each element in array[start:end],
 * in order.
 *
 * @returns {number} The index of the first element for which predicate returns
 * false, or end if there is no such element.
 */

function partitionArray(array, start, end, predicate) {
    while (start < end) {
        var x = array[start];
        if (predicate(x)) {
            ++start;
            continue;
        }
        --end;
        array[start] = array[end];
        array[end] = x;
    }
    return end;
}
exports.partitionArray = partitionArray;
/**
 * Returns an array of size newSize that starts with the contents of array.
 * Either returns array if it has the correct size, or a new array with zero
 * padding at the end.
 */
function maybePadArray(array, newSize) {
    if (array.length === newSize) {
        return array;
    }
    var newArray = new array.constructor(newSize);
    newArray.set(array);
    return newArray;
}
exports.maybePadArray = maybePadArray;
function getFortranOrderStrides(size) {
    var baseStride = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    var length = size.length;
    var strides = new Array(length);
    var stride = strides[0] = baseStride;
    for (var i = 1; i < length; ++i) {
        stride *= size[i - 1];
        strides[i] = stride;
    }
    return strides;
}
exports.getFortranOrderStrides = getFortranOrderStrides;

/***/ },
/* 64 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function approxEqual(a, b) {
    if (a === b) {
        return true;
    }
    return Math.abs(a - b) / Math.min(Math.abs(a), Math.abs(b)) < 1e-6;
}
exports.approxEqual = approxEqual;

/***/ },
/* 65 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * If this is updated, DATA_TYPE_BYTES must also be updated.
 */

(function (DataType) {
  DataType[DataType["UINT8"] = 0] = "UINT8";
  DataType[DataType["UINT16"] = 1] = "UINT16";
  DataType[DataType["UINT32"] = 2] = "UINT32";
  DataType[DataType["UINT64"] = 3] = "UINT64";
  DataType[DataType["FLOAT32"] = 4] = "FLOAT32";
})(exports.DataType || (exports.DataType = {}));
var DataType = exports.DataType;
exports.DATA_TYPE_BYTES = [];
exports.DATA_TYPE_BYTES[DataType.UINT8] = 1;
exports.DATA_TYPE_BYTES[DataType.UINT16] = 2;
exports.DATA_TYPE_BYTES[DataType.UINT32] = 4;
exports.DATA_TYPE_BYTES[DataType.UINT64] = 8;
exports.DATA_TYPE_BYTES[DataType.FLOAT32] = 4;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
// We use the approach described in the following paper to determine the
// intersection between the
// viewport plane and a given 3-D chunk inside of a WebGL vertex shader:
//
// A Vertex Program for Efficient Box-Plane Intersection
// Christof Rezk Salama and Adreas Kolb
// VMV 2005.
// http://www.cg.informatik.uni-siegen.de/data/Publications/2005/rezksalamaVMV2005.pdf

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var base_1 = __webpack_require__(31);
var layer_1 = __webpack_require__(42);
var base_2 = __webpack_require__(61);
var trackable_value_1 = __webpack_require__(67);
var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var json_1 = __webpack_require__(8);
var buffer_1 = __webpack_require__(38);
var shader_1 = __webpack_require__(41);
var worker_rpc_1 = __webpack_require__(22);
exports.GLSL_TYPE_FOR_DATA_TYPE = new Map([[base_2.DataType.UINT8, 'uint8_t'], [base_2.DataType.FLOAT32, 'float'], [base_2.DataType.UINT16, 'uint16_t'], [base_2.DataType.UINT32, 'uint32_t'], [base_2.DataType.UINT64, 'uint64_t']]);
function trackableAlphaValue() {
    var initialValue = arguments.length <= 0 || arguments[0] === undefined ? 0.5 : arguments[0];

    return new trackable_value_1.TrackableValue(initialValue, json_1.verifyFloat01);
}
exports.trackableAlphaValue = trackableAlphaValue;
var DEBUG_VERTICES = false;
/**
 * Amount by which a computed intersection point may lie outside the [0, 1] range and still be
 * considered valid.  This needs to be non-zero in order to avoid vertex placement artifacts.
 */
var LAMBDA_EPSILON = 1e-3;
/**
 * If the absolute value of the dot product of a cube edge direction and the viewport plane normal
 * is less than this value, intersections along that cube edge will be exluded.  This needs to be
 * non-zero in order to avoid vertex placement artifacts.
 */
var ORTHOGONAL_EPSILON = 1e-3;

var SliceViewShaderBuffers = function (_disposable_1$RefCoun) {
    _inherits(SliceViewShaderBuffers, _disposable_1$RefCoun);

    function SliceViewShaderBuffers(gl) {
        _classCallCheck(this, SliceViewShaderBuffers);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SliceViewShaderBuffers).call(this));

        _this.outputVertexIndices = _this.registerDisposer(buffer_1.Buffer.fromData(gl, new Float32Array([0, 1, 2, 3, 4, 5]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
        // This specifies the original, "uncorrected" vertex positions.
        // var vertexBasePositions = [
        //   0, 0, 0,
        //   1, 0, 0,
        //   0, 1, 0,
        //   0, 0, 1,
        //   1, 0, 1,
        //   1, 1, 0,
        //   0, 1, 1,
        //   1, 1, 1,
        // ];
        // This specifies the "corrected" vertex positions.
        _this.vertexBasePositions = [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1];
        // correct_index, vertex_position, uncorrected_index
        // 0:  0, 0, 0   0
        // 1:  1, 0, 0   1
        // 2:  0, 1, 0   2
        // 4:  0, 0, 1   3
        // 5:  1, 0, 1   4
        // 3:  1, 1, 0   5
        // 6:  0, 1, 1   6
        // 7:  1, 1, 1   7
        // This maps uncorrected vertex indices to corrected vertex indices.
        var vertexUncorrectedToCorrected = [0, 1, 2, 4, 5, 3, 6, 7];
        // This maps corrected vertex indices to uncorrected vertex indices.
        var vertexCorrectedToUncorrected = [0, 1, 2, 5, 3, 4, 6, 7];
        // Page 666
        var vertexBaseIndices = [0, 1, 1, 4, 4, 7, 4, 7, 1, 5, 0, 1, 1, 4, 4, 7, 0, 2, 2, 5, 5, 7, 5, 7, 2, 6, 0, 2, 2, 5, 5, 7, 0, 3, 3, 6, 6, 7, 6, 7, 3, 4, 0, 3, 3, 6, 6, 7];
        // Determined by looking at the figure and determining the corresponding
        // vertex order for each possible front vertex.
        var vertexPermutation = [0, 1, 2, 3, 4, 5, 6, 7, 1, 4, 5, 0, 3, 7, 2, 6, 2, 6, 0, 5, 7, 3, 1, 4, 3, 0, 6, 4, 1, 2, 7, 5, 4, 3, 7, 1, 0, 6, 5, 2, 5, 2, 1, 7, 6, 0, 4, 3, 6, 7, 3, 2, 5, 4, 0, 1, 7, 5, 4, 6, 2, 1, 3, 0];
        var vertexIndices = [];
        for (var p = 0; p < 8; ++p) {
            for (var i = 0; i < vertexBaseIndices.length; ++i) {
                var vertexPermutationIndex = vertexCorrectedToUncorrected[p] * 8 + vertexBaseIndices[i];
                vertexIndices.push(vertexUncorrectedToCorrected[vertexPermutation[vertexPermutationIndex]]);
            }
        }
        _this.vertexIndices = new Int32Array(vertexIndices);
        return _this;
    }

    _createClass(SliceViewShaderBuffers, null, [{
        key: 'get',
        value: function get(gl) {
            return gl.memoize.get('SliceViewShaderBuffers', () => new SliceViewShaderBuffers(gl));
        }
    }]);

    return SliceViewShaderBuffers;
}(disposable_1.RefCounted);

;
function findFrontVertexIndex(planeNormal) {
    // Determine which vertex is front.
    var frontVertexIndex = 0;
    for (var axis_i = 0; axis_i < 3; ++axis_i) {
        // If plane normal is negative in axis direction, then choose the vertex
        // with the maximum axis_i-coordinate.
        if (planeNormal[axis_i] < 0) {
            frontVertexIndex += 1 << axis_i;
        }
    }
    return frontVertexIndex;
}
exports.glsl_getPositionWithinChunk = `
vec3 getPositionWithinChunk () {
  return floor(min(vChunkPosition, uChunkDataSize - 1.0));
}
`;
var tempVec3 = geom_1.vec3.create();

var VolumeSliceVertexComputationManager = function (_disposable_1$RefCoun2) {
    _inherits(VolumeSliceVertexComputationManager, _disposable_1$RefCoun2);

    function VolumeSliceVertexComputationManager(gl) {
        _classCallCheck(this, VolumeSliceVertexComputationManager);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(VolumeSliceVertexComputationManager).call(this));

        _this2.data = _this2.registerDisposer(SliceViewShaderBuffers.get(gl));
        return _this2;
    }

    _createClass(VolumeSliceVertexComputationManager, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            var data = this.data;
            // A number in [0, 6) specifying which vertex to compute.
            builder.addAttribute('highp float', 'aVertexIndexFloat');
            // Specifies translation of the current chunk.
            builder.addUniform('highp vec3', 'uTranslation');
            // Matrix by which computed vertices will be transformed.
            builder.addUniform('highp mat4', 'uProjectionMatrix');
            // Slice plane normal.
            builder.addUniform('highp vec3', 'uPlaneNormal');
            // Distance from the origin to the slice plane.
            builder.addUniform('highp float', 'uPlaneDistance');
            // Two-dimensional array of dimensions [6x4], specifying the first and
            // second vertex index for each of the 4 candidate edges to test for each
            // computed vertex.
            builder.addUniform('highp ivec2', 'uVertexIndex', 24);
            // Base vertex positions.
            builder.addUniform('highp vec3', 'uVertexBasePosition', 8);
            builder.addInitializer(shader => {
                shader.gl.uniform3fv(shader.uniform('uVertexBasePosition'), new Float32Array(data.vertexBasePositions));
            });
            // Chunk size in voxels.
            builder.addUniform('highp vec3', 'uChunkDataSize');
            // Size of a voxel in nanometers.
            builder.addUniform('highp vec3', 'uVoxelSize');
            builder.addUniform('highp vec3', 'uLowerClipBound');
            builder.addUniform('highp vec3', 'uUpperClipBound');
            // Position within chunk of vertex, in floating point range [0, chunkDataSize].
            builder.addVarying('highp vec3', 'vChunkPosition');
            builder.setVertexMain(`
vec3 chunkSize = uChunkDataSize * uVoxelSize;
int vertexIndex = int(aVertexIndexFloat);
for (int e = 0; e < 4; ++e) {
  highp ivec2 vidx = uVertexIndex[vertexIndex*4 + e];
  highp vec3 v1 = max(uLowerClipBound, min(uUpperClipBound, chunkSize * uVertexBasePosition[vidx.x] + uTranslation));
  highp vec3 v2 = max(uLowerClipBound, min(uUpperClipBound, chunkSize * uVertexBasePosition[vidx.y] + uTranslation));
  highp vec3 vDir = v2 - v1;
  highp float denom = dot(vDir, uPlaneNormal);
  if (abs(denom) > ${ ORTHOGONAL_EPSILON }) {
    highp float lambda = (uPlaneDistance - dot(v1, uPlaneNormal)) / denom;
    if ((lambda >= -${ LAMBDA_EPSILON }) && (lambda <= (1.0 + ${ LAMBDA_EPSILON }))) {
      lambda = clamp(lambda, 0.0, 1.0);
      highp vec3 position = v1 + lambda * vDir;
      gl_Position = uProjectionMatrix * vec4(position, 1.0);
      vChunkPosition = (position - uTranslation) / uVoxelSize;
      break;
    }
  }
}
`);
            builder.addFragmentCode(exports.glsl_getPositionWithinChunk);
        }
    }, {
        key: 'computeVerticesDebug',
        value: function computeVerticesDebug(uChunkDataSize, uVoxelSize, uPlaneDistance, uPlaneNormal, uTranslation, uProjectionMatrix) {
            var chunkSize = geom_1.vec3.multiply(geom_1.vec3.create(), uChunkDataSize, uVoxelSize);
            var frontVertexIndex = findFrontVertexIndex(uPlaneNormal);
            var uVertexIndex = this.data.vertexIndices.subarray(frontVertexIndex * 48, (frontVertexIndex + 1) * 48);
            var vidx = [0, 0];
            var v = [geom_1.vec3.create(), geom_1.vec3.create()];
            var vStart = geom_1.vec3.create(),
                vDir = geom_1.vec3.create(),
                position = geom_1.vec3.create(),
                gl_Position = geom_1.vec3.create(),
                vChunkPosition = geom_1.vec3.create();
            var vertexBasePositions = new Float32Array(this.data.vertexBasePositions);
            var uVertexBasePosition = i => vertexBasePositions.subarray(i * 3, i * 3 + 3);
            for (var vertexIndex = 0; vertexIndex < 6; ++vertexIndex) {
                for (var e = 0; e < 4; ++e) {
                    for (var j = 0; j < 2; ++j) {
                        vidx[j] = uVertexIndex[2 * (vertexIndex * 4 + e) + j];
                        geom_1.vec3.multiply(v[j], chunkSize, uVertexBasePosition(vidx[j]));
                    }
                    geom_1.vec3.add(vStart, v[0], uTranslation);
                    geom_1.vec3.subtract(vDir, v[1], v[0]);
                    var denom = geom_1.vec3.dot(vDir, uPlaneNormal);
                    if (Math.abs(denom) > ORTHOGONAL_EPSILON) {
                        var lambda = (uPlaneDistance - geom_1.vec3.dot(vStart, uPlaneNormal)) / denom;
                        if (lambda >= -LAMBDA_EPSILON && lambda <= 1.0 + LAMBDA_EPSILON) {
                            lambda = Math.max(0, Math.min(1, lambda));
                            geom_1.vec3.scaleAndAdd(position, vStart, vDir, lambda);
                            geom_1.vec3.transformMat4(gl_Position, geom_1.vec4.fromValues(position[0], position[1], position[2], 1.0), uProjectionMatrix);
                            geom_1.vec3.scale(vChunkPosition, uVertexBasePosition(vidx[0]), 1.0 - lambda);
                            geom_1.vec3.scaleAndAdd(vChunkPosition, vChunkPosition, uVertexBasePosition(vidx[1]), lambda);
                            console.log(`vertex ${ vertexIndex }, e = ${ e }, at ${ gl_Position }, vChunkPosition = ${ vChunkPosition }, edge dir = ${ vDir }, denom = ${ denom }`);
                            break;
                        } else {
                            console.log(`vertex ${ vertexIndex }, e = ${ e }, skipped, deom = ${ denom }, vDir = ${ geom_1.vec3Key(vDir) }, uPlaneNormal = ${ geom_1.vec3Key(uPlaneNormal) }, lambda=${ lambda }`);
                        }
                    } else {
                        console.log(`vertex ${ vertexIndex }, e = ${ e }, skipped, deom = ${ denom }, vDir = ${ geom_1.vec3Key(vDir) }, uPlaneNormal = ${ geom_1.vec3Key(uPlaneNormal) }`);
                    }
                }
            }
        }
    }, {
        key: 'beginSlice',
        value: function beginSlice(gl, shader, dataToDeviceMatrix, sliceView) {
            var planeNormal = sliceView.viewportAxes[2];
            var frontVertexIndex = findFrontVertexIndex(planeNormal);
            gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, dataToDeviceMatrix);
            gl.uniform3fv(shader.uniform('uPlaneNormal'), planeNormal.subarray(0, 3));
            gl.uniform1f(shader.uniform('uPlaneDistance'), sliceView.viewportPlaneDistanceToOrigin);
            var aVertexIndexFloat = shader.attribute('aVertexIndexFloat');
            this.data.outputVertexIndices.bindToVertexAttrib(aVertexIndexFloat, 1);
            gl.uniform2iv(shader.uniform('uVertexIndex'), this.data.vertexIndices.subarray(frontVertexIndex * 48, (frontVertexIndex + 1) * 48));
            if (DEBUG_VERTICES) {
                window['debug_sliceView'] = sliceView;
                window['debug_sliceView_dataToDevice'] = dataToDeviceMatrix;
            }
        }
    }, {
        key: 'endSlice',
        value: function endSlice(gl, shader) {
            var aVertexIndexFloat = shader.attribute('aVertexIndexFloat');
            gl.disableVertexAttribArray(aVertexIndexFloat);
        }
    }, {
        key: 'beginSource',
        value: function beginSource(gl, shader, spec) {
            gl.uniform3fv(shader.uniform('uVoxelSize'), spec.voxelSize);
            gl.uniform3fv(shader.uniform('uLowerClipBound'), geom_1.vec3.add(tempVec3, spec.lowerClipBound, spec.chunkLayout.offset));
            gl.uniform3fv(shader.uniform('uUpperClipBound'), geom_1.vec3.add(tempVec3, spec.upperClipBound, spec.chunkLayout.offset));
            if (DEBUG_VERTICES) {
                window['debug_sliceView_uVoxelSize'] = spec.voxelSize;
            }
        }
    }, {
        key: 'setupChunkDataSize',
        value: function setupChunkDataSize(gl, shader, chunkDataSize) {
            gl.uniform3fv(shader.uniform('uChunkDataSize'), chunkDataSize);
            if (DEBUG_VERTICES) {
                window['debug_sliceView_chunkDataSize'] = chunkDataSize;
            }
        }
    }, {
        key: 'drawChunk',
        value: function drawChunk(gl, shader, chunkPosition) {
            gl.uniform3fv(shader.uniform('uTranslation'), chunkPosition);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 6);
            if (DEBUG_VERTICES) {
                var sliceView = window['debug_sliceView'];
                var chunkDataSize = window['debug_sliceView_chunkDataSize'];
                var voxelSize = window['debug_sliceView_voxelSize'];
                console.log(`Drawing chunk: ${ geom_1.vec3Key(chunkPosition) } of data size ${ geom_1.vec3Key(chunkDataSize) }`);
                var dataToDeviceMatrix = window['debug_sliceView_dataToDevice'];
                this.computeVerticesDebug(chunkDataSize, voxelSize, sliceView.viewportPlaneDistanceToOrigin, sliceView.viewportAxes[2], chunkPosition, dataToDeviceMatrix);
            }
        }
    }], [{
        key: 'get',
        value: function get(gl) {
            return gl.memoize.get('sliceview.VolumeSliceVertexComputationManager', () => new VolumeSliceVertexComputationManager(gl));
        }
    }]);

    return VolumeSliceVertexComputationManager;
}(disposable_1.RefCounted);

;

var RenderLayer = function (_layer_1$RenderLayer) {
    _inherits(RenderLayer, _layer_1$RenderLayer);

    function RenderLayer(chunkManager, multiscaleSourcePromise) {
        _classCallCheck(this, RenderLayer);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(RenderLayer).call(this));

        _this3.chunkManager = chunkManager;
        _this3.sources = null;
        _this3.shader = undefined;
        _this3.shaderUpdated = true;
        _this3.rpcId = null;
        _this3.shaderError = new trackable_value_1.WatchableValue(undefined);
        var gl = _this3.gl;
        _this3.vertexComputationManager = VolumeSliceVertexComputationManager.get(gl);
        Promise.resolve(multiscaleSourcePromise).then(multiscaleSource => {
            var sources = _this3.sources = multiscaleSource.getSources(chunkManager);
            var sourceIds = [];
            for (var alternatives of sources) {
                var alternativeIds = [];
                sourceIds.push(alternativeIds);
                for (var source of alternatives) {
                    alternativeIds.push(source.rpcId);
                }
            }
            var sharedObject = _this3.registerDisposer(new worker_rpc_1.SharedObject());
            sharedObject.RPC_TYPE_ID = base_2.SLICEVIEW_RENDERLAYER_RPC_ID;
            sharedObject.initializeCounterpart(chunkManager.rpc, { 'sources': sourceIds });
            _this3.rpcId = sharedObject.rpcId;
            var spec = _this3.sources[0][0].spec;
            _this3.voxelSize = spec.voxelSize;
            _this3.boundingBox = new geom_1.BoundingBox(geom_1.vec3.add(geom_1.vec3.create(), spec.chunkLayout.offset, spec.lowerClipBound), geom_1.vec3.add(geom_1.vec3.create(), spec.chunkLayout.offset, spec.upperClipBound));
            _this3.setReady(true);
        });
        return _this3;
    }

    _createClass(RenderLayer, [{
        key: 'initializeShader',
        value: function initializeShader() {
            if (!this.shaderUpdated) {
                return;
            }
            this.shaderUpdated = false;
            try {
                var newShader = this.getShader();
                this.disposeShader();
                this.shader = newShader;
                this.shaderError.value = undefined;
            } catch (shaderError) {
                this.shaderError.value = shaderError;
            }
        }
    }, {
        key: 'disposeShader',
        value: function disposeShader() {
            if (this.shader) {
                this.shader.dispose();
                this.shader = undefined;
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            _get(Object.getPrototypeOf(RenderLayer.prototype), 'disposed', this).call(this);
            this.disposeShader();
        }
    }, {
        key: 'getValueAt',
        value: function getValueAt(position) {
            for (var alternatives of this.sources) {
                for (var source of alternatives) {
                    var result = source.getValueAt(position);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        }
    }, {
        key: 'getShaderKey',
        value: function getShaderKey() {
            return '';
        }
    }, {
        key: 'getShader',
        value: function getShader() {
            var key = this.getShaderKey() + '/' + this.chunkFormat.shaderKey;
            return this.gl.memoize.get(key, () => this.buildShader());
        }
    }, {
        key: 'buildShader',
        value: function buildShader() {
            var builder = new shader_1.ShaderBuilder(this.gl);
            this.defineShader(builder);
            return builder.build();
        }
    }, {
        key: 'defineShader',
        value: function defineShader(builder) {
            this.vertexComputationManager.defineShader(builder);
            builder.addFragmentCode(`
void emit(vec4 color) {
  gl_FragData[0] = color;
}
`);
            this.chunkFormat.defineShader(builder);
            builder.addFragmentCode(`
${ exports.GLSL_TYPE_FOR_DATA_TYPE.get(this.dataType) } getDataValue() { return getDataValue(0); }
`);
        }
    }, {
        key: 'beginSlice',
        value: function beginSlice(sliceView) {
            var dataToDevice = sliceView.dataToDevice;

            var gl = this.gl;
            var shader = this.shader;
            shader.bind();
            this.vertexComputationManager.beginSlice(gl, shader, dataToDevice, sliceView);
            return shader;
        }
    }, {
        key: 'endSlice',
        value: function endSlice(shader) {
            var gl = this.gl;
            this.vertexComputationManager.endSlice(gl, shader);
        }
    }, {
        key: 'draw',
        value: function draw(sliceView) {
            var visibleSources = sliceView.visibleLayers.get(this);
            if (visibleSources.length === 0) {
                return;
            }
            this.initializeShader();
            if (this.shader === undefined) {
                return;
            }
            var gl = this.gl;
            var chunkPosition = geom_1.vec3.create();
            var shader = this.beginSlice(sliceView);
            var vertexComputationManager = this.vertexComputationManager;
            // All sources are required to have the same texture format.
            var chunkFormat = this.chunkFormat;
            chunkFormat.beginDrawing(gl, shader);

            var _loop = function (source) {
                var chunkLayout = source.spec.chunkLayout;
                var offset = chunkLayout.offset;

                var chunks = source.chunks;
                var originalChunkSize = chunkLayout.size;
                var chunkDataSize = void 0;
                var visibleChunks = sliceView.visibleChunks.get(chunkLayout);
                if (!visibleChunks) {
                    return 'continue';
                }
                vertexComputationManager.beginSource(gl, shader, source.spec);
                var sourceChunkFormat = source.chunkFormat;
                sourceChunkFormat.beginSource(gl, shader);
                var setChunkDataSize = newChunkDataSize => {
                    chunkDataSize = newChunkDataSize;
                    vertexComputationManager.setupChunkDataSize(gl, shader, chunkDataSize);
                };
                for (var key of visibleChunks) {
                    var chunk = chunks.get(key);
                    if (chunk && chunk.state === base_1.ChunkState.GPU_MEMORY) {
                        var newChunkDataSize = chunk.chunkDataSize;
                        if (newChunkDataSize !== chunkDataSize) {
                            setChunkDataSize(newChunkDataSize);
                        }
                        geom_1.vec3.multiply(chunkPosition, originalChunkSize, chunk.chunkGridPosition);
                        geom_1.vec3.add(chunkPosition, chunkPosition, offset);
                        sourceChunkFormat.bindChunk(gl, shader, chunk);
                        vertexComputationManager.drawChunk(gl, shader, chunkPosition);
                    }
                }
            };

            for (var source of visibleSources) {
                var _ret = _loop(source);

                if (_ret === 'continue') continue;
            }
            chunkFormat.endDrawing(gl, shader);
            this.endSlice(shader);
        }
    }, {
        key: 'gl',
        get: function () {
            return this.chunkManager.chunkQueueManager.gl;
        }
    }, {
        key: 'chunkFormat',
        get: function () {
            return this.sources[0][0].chunkFormat;
        }
    }, {
        key: 'dataType',
        get: function () {
            return this.sources[0][0].spec.dataType;
        }
    }]);

    return RenderLayer;
}(layer_1.RenderLayer);

exports.RenderLayer = RenderLayer;
;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var signals_1 = __webpack_require__(34);

var WatchableValue = function () {
    function WatchableValue(value_) {
        _classCallCheck(this, WatchableValue);

        this.value_ = value_;
        this.changed = new signals_1.Signal();
    }

    _createClass(WatchableValue, [{
        key: "value",
        get: function () {
            return this.value_;
        },
        set: function (newValue) {
            if (newValue !== this.value_) {
                this.value_ = newValue;
                this.changed.dispatch();
            }
        }
    }]);

    return WatchableValue;
}();

exports.WatchableValue = WatchableValue;
;

var TrackableValue = function (_WatchableValue) {
    _inherits(TrackableValue, _WatchableValue);

    function TrackableValue(value, validator) {
        var defaultValue = arguments.length <= 2 || arguments[2] === undefined ? value : arguments[2];

        _classCallCheck(this, TrackableValue);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TrackableValue).call(this, value));

        _this.validator = validator;
        _this.defaultValue = defaultValue;
        return _this;
    }

    _createClass(TrackableValue, [{
        key: "toJSON",
        value: function toJSON() {
            var value_ = this.value_;

            if (value_ === this.defaultValue) {
                return undefined;
            }
            return this.value_;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.value = this.defaultValue;
        }
    }, {
        key: "restoreState",
        value: function restoreState(x) {
            if (x !== undefined) {
                var validator = this.validator;

                try {
                    this.value = validator(x);
                    return;
                } catch (ignoredError) {}
            }
            this.value = this.defaultValue;
        }
    }]);

    return TrackableValue;
}(WatchableValue);

exports.TrackableValue = TrackableValue;
;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var buffer_1 = __webpack_require__(38);
var texture_1 = __webpack_require__(69);
var trivial_shaders_1 = __webpack_require__(40);

var OffscreenFramebuffer = function (_disposable_1$RefCoun) {
    _inherits(OffscreenFramebuffer, _disposable_1$RefCoun);

    function OffscreenFramebuffer(gl) {
        var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var _ref$numDataBuffers = _ref.numDataBuffers;
        var numDataBuffers = _ref$numDataBuffers === undefined ? 1 : _ref$numDataBuffers;
        var _ref$depthBuffer = _ref.depthBuffer;
        var depthBuffer = _ref$depthBuffer === undefined ? false : _ref$depthBuffer;
        var _ref$stencilBuffer = _ref.stencilBuffer;
        var stencilBuffer = _ref$stencilBuffer === undefined ? false : _ref$stencilBuffer;

        _classCallCheck(this, OffscreenFramebuffer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(OffscreenFramebuffer).call(this));

        _this.gl = gl;
        _this.width = Number.NaN;
        _this.height = Number.NaN;
        _this.framebuffer = _this.gl.createFramebuffer();
        _this.depthBuffer = null;
        _this.dataTextures = new Array();
        _this.attachmentVerified = false;
        _this.tempPixel = new Uint8Array(4);
        _this.fullAttachmentList = new Array();
        _this.singleAttachmentList = [_this.gl.WEBGL_draw_buffers.COLOR_ATTACHMENT0_WEBGL];
        var dataTextures = _this.dataTextures;
        var fullAttachmentList = _this.fullAttachmentList;

        for (var i = 0; i < numDataBuffers; ++i) {
            dataTextures[i] = gl.createTexture();
            fullAttachmentList[i] = gl.WEBGL_draw_buffers.COLOR_ATTACHMENT0_WEBGL + i;
        }
        if (depthBuffer || stencilBuffer) {
            _this.depthBuffer = gl.createRenderbuffer();
        }
        _this.useStencilBuffer = stencilBuffer;
        return _this;
    }

    _createClass(OffscreenFramebuffer, [{
        key: 'disposed',
        value: function disposed() {
            var gl = this.gl;
            var depthBuffer = this.depthBuffer;

            gl.deleteFramebuffer(this.framebuffer);
            if (depthBuffer != null) {
                gl.deleteRenderbuffer(depthBuffer);
            }
            for (var dataTexture of this.dataTextures) {
                gl.deleteTexture(dataTexture);
            }
        }
    }, {
        key: 'resize',
        value: function resize(width, height) {
            if (this.hasSize(width, height)) {
                return;
            }
            this.width = width;
            this.height = height;
            var gl = this.gl;
            var useStencilBuffer = this.useStencilBuffer;
            var depthBuffer = this.depthBuffer;

            for (var dataTexture of this.dataTextures) {
                texture_1.resizeTexture(gl, dataTexture, width, height);
            }
            if (depthBuffer) {
                gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, useStencilBuffer ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT16, width, height);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            }
        }
    }, {
        key: 'hasSize',
        value: function hasSize(width, height) {
            return this.width === width && this.height === height;
        }
    }, {
        key: 'bind',
        value: function bind(width, height) {
            this.resize(width, height);
            var gl = this.gl;
            var useStencilBuffer = this.useStencilBuffer;
            var depthBuffer = this.depthBuffer;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            if (depthBuffer) {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, useStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
            }
            this.dataTextures.forEach((dataTexture, i) => {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.WEBGL_draw_buffers.COLOR_ATTACHMENT0_WEBGL + i, gl.TEXTURE_2D, dataTexture,
                /*level=*/0);
            });
            gl.WEBGL_draw_buffers.drawBuffersWEBGL(this.fullAttachmentList);
            this.verifyAttachment();
            gl.viewport(0, 0, width, height);
        }
    }, {
        key: 'unbind',
        value: function unbind() {
            var gl = this.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    }, {
        key: 'bindSingle',
        value: function bindSingle(textureIndex) {
            var gl = this.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.dataTextures[textureIndex],
            /*level=*/0);
            gl.WEBGL_draw_buffers.drawBuffersWEBGL(this.singleAttachmentList);
        }
    }, {
        key: 'readPixel',
        value: function readPixel(textureIndex, glWindowX, glWindowY) {
            var gl = this.gl;
            var tempPixel = this.tempPixel;

            try {
                this.bindSingle(textureIndex);
                gl.readPixels(glWindowX, glWindowY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, tempPixel);
            } finally {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            return tempPixel;
        }
        /**
         * Calls readPixel, but interprets the RGBA result as a little-endian uint32 value.
         */

    }, {
        key: 'readPixelAsUint32',
        value: function readPixelAsUint32(textureIndex, glWindowX, glWindowY) {
            var result = this.readPixel(textureIndex, glWindowX, glWindowY);
            return result[0] + (result[1] << 8) + (result[2] << 16) + (result[3] << 24);
        }
    }, {
        key: 'verifyAttachment',
        value: function verifyAttachment() {
            if (this.attachmentVerified) {
                return;
            }
            var gl = this.gl;

            var framebufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (framebufferStatus !== gl.FRAMEBUFFER_COMPLETE) {
                throw new Error('Framebuffer configuration not supported');
            }
            this.attachmentVerified = true;
        }
    }]);

    return OffscreenFramebuffer;
}(disposable_1.RefCounted);

exports.OffscreenFramebuffer = OffscreenFramebuffer;
;

var OffscreenCopyHelper = function (_disposable_1$RefCoun2) {
    _inherits(OffscreenCopyHelper, _disposable_1$RefCoun2);

    function OffscreenCopyHelper(gl) {
        _classCallCheck(this, OffscreenCopyHelper);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(OffscreenCopyHelper).call(this));

        _this2.gl = gl;
        _this2.copyVertexPositionsBuffer = _this2.registerDisposer(buffer_1.Buffer.fromData(_this2.gl, new Float32Array([-1, -1, 0, 1, -1, +1, 0, 1, +1, +1, 0, 1, +1, -1, 0, 1]), _this2.gl.ARRAY_BUFFER, _this2.gl.STATIC_DRAW));
        _this2.copyTexCoordsBuffer = _this2.registerDisposer(buffer_1.Buffer.fromData(_this2.gl, new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]), _this2.gl.ARRAY_BUFFER, _this2.gl.STATIC_DRAW));
        _this2.trivialTextureShader = _this2.registerDisposer(trivial_shaders_1.trivialTextureShader(_this2.gl));
        return _this2;
    }

    _createClass(OffscreenCopyHelper, [{
        key: 'draw',
        value: function draw(texture) {
            var gl = this.gl;

            var shader = this.trivialTextureShader;
            shader.bind();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(shader.uniform('uSampler'), 0);
            gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, geom_1.identityMat4);
            var aVertexPosition = shader.attribute('aVertexPosition');
            this.copyVertexPositionsBuffer.bindToVertexAttrib(aVertexPosition, 4);
            var aTexCoord = shader.attribute('aTexCoord');
            this.copyTexCoordsBuffer.bindToVertexAttrib(aTexCoord, 2);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            gl.disableVertexAttribArray(aVertexPosition);
            gl.disableVertexAttribArray(aTexCoord);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }], [{
        key: 'get',
        value: function get(gl) {
            return gl.memoize.get('OffscreenCopyHelper', () => {
                return new OffscreenCopyHelper(gl);
            });
        }
    }]);

    return OffscreenCopyHelper;
}(disposable_1.RefCounted);

exports.OffscreenCopyHelper = OffscreenCopyHelper;
;

/***/ },
/* 69 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Sets parameters to make a texture suitable for use as a raw array: NEAREST
 * filtering, clamping.
 */

function setRawTextureParameters(gl) {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    // Prevents s-coordinate wrapping (repeating).  Repeating not
    // permitted for non-power-of-2 textures.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    // Prevents t-coordinate wrapping (repeating).  Repeating not
    // permitted for non-power-of-2 textures.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}
exports.setRawTextureParameters = setRawTextureParameters;
function resizeTexture(gl, texture, width, height) {
    var format = arguments.length <= 4 || arguments[4] === undefined ? gl.RGBA : arguments[4];
    var dataType = arguments.length <= 5 || arguments[5] === undefined ? gl.UNSIGNED_BYTE : arguments[5];

    gl.activeTexture(gl.TEXTURE0 + gl.tempTextureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    setRawTextureParameters(gl);
    gl.texImage2D(gl.TEXTURE_2D, 0,
    /*internalformat=*/format,
    /*width=*/width,
    /*height=*/height,
    /*border=*/0,
    /*format=*/format, dataType, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
}
exports.resizeTexture = resizeTexture;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var disposable_1 = __webpack_require__(23);
var signals_1 = __webpack_require__(34);

var TrackableBoolean = function () {
    function TrackableBoolean(value_, defaultValue) {
        _classCallCheck(this, TrackableBoolean);

        this.value_ = value_;
        this.defaultValue = defaultValue;
        this.changed = new signals_1.Signal();
    }

    _createClass(TrackableBoolean, [{
        key: 'toggle',
        value: function toggle() {
            this.value = !this.value;
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            var value_ = this.value_;

            if (value_ === this.defaultValue) {
                return undefined;
            }
            return this.value_;
        }
    }, {
        key: 'restoreState',
        value: function restoreState(x) {
            if (x === true || x === false) {
                this.value = x;
                return;
            }
            this.value = this.defaultValue;
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.value = this.defaultValue;
        }
    }, {
        key: 'value',
        get: function () {
            return this.value_;
        },
        set: function (newValue) {
            if (newValue !== this.value_) {
                this.value_ = newValue;
                this.changed.dispatch();
            }
        }
    }]);

    return TrackableBoolean;
}();

exports.TrackableBoolean = TrackableBoolean;
;

var TrackableBooleanCheckbox = function (_disposable_1$RefCoun) {
    _inherits(TrackableBooleanCheckbox, _disposable_1$RefCoun);

    function TrackableBooleanCheckbox(model) {
        _classCallCheck(this, TrackableBooleanCheckbox);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TrackableBooleanCheckbox).call(this));

        _this.model = model;
        _this.element = document.createElement('input');
        var element = _this.element;

        element.type = 'checkbox';
        _this.registerSignalBinding(model.changed.add(_this.updateCheckbox, _this));
        _this.updateCheckbox();
        _this.registerEventListener(element, 'change', function (e) {
            model.value = this.checked;
        });
        return _this;
    }

    _createClass(TrackableBooleanCheckbox, [{
        key: 'updateCheckbox',
        value: function updateCheckbox() {
            this.element.checked = this.model.value;
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            var element = this.element;
            var parentElement = element.parentElement;

            if (parentElement) {
                parentElement.removeChild(element);
            }
            _get(Object.getPrototypeOf(TrackableBooleanCheckbox.prototype), 'disposed', this).call(this);
        }
    }]);

    return TrackableBooleanCheckbox;
}(disposable_1.RefCounted);

exports.TrackableBooleanCheckbox = TrackableBooleanCheckbox;
;

var ElementVisibilityFromTrackableBoolean = function (_disposable_1$RefCoun2) {
    _inherits(ElementVisibilityFromTrackableBoolean, _disposable_1$RefCoun2);

    function ElementVisibilityFromTrackableBoolean(model, element) {
        _classCallCheck(this, ElementVisibilityFromTrackableBoolean);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ElementVisibilityFromTrackableBoolean).call(this));

        _this2.model = model;
        _this2.element = element;
        _this2.updateVisibility();
        _this2.registerSignalBinding(model.changed.add(() => {
            _this2.updateVisibility();
        }));
        return _this2;
    }

    _createClass(ElementVisibilityFromTrackableBoolean, [{
        key: 'updateVisibility',
        value: function updateVisibility() {
            this.element.style.display = this.model.value ? '' : 'none';
        }
    }]);

    return ElementVisibilityFromTrackableBoolean;
}(disposable_1.RefCounted);

exports.ElementVisibilityFromTrackableBoolean = ElementVisibilityFromTrackableBoolean;
;

/***/ },
/* 71 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function startRelativeMouseDrag(initialEvent, handler) {
    var document = initialEvent.view.document;

    var prevScreenX = initialEvent.screenX,
        prevScreenY = initialEvent.screenY;
    var mouseMoveHandler = e => {
        var deltaX = prevScreenX - e.screenX;
        var deltaY = prevScreenY - e.screenY;
        prevScreenX = e.screenX;
        prevScreenY = e.screenY;
        handler(e, deltaX, deltaY);
    };
    var button = initialEvent.button;
    var mouseUpHandler = e => {
        if (e.button === button) {
            document.removeEventListener('mousemove', mouseMoveHandler, true);
            document.removeEventListener('mouseup', mouseUpHandler, false);
        }
    };
    document.addEventListener('mousemove', mouseMoveHandler, true);
    document.addEventListener('mouseup', mouseUpHandler, false);
}
exports.startRelativeMouseDrag = startRelativeMouseDrag;

/***/ },
/* 72 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * GLSL function for converting a float in [0,1) to 32-bit little endian fixed point representation
 * (encoded as a vector of four floats in [0,1]).  This is fast but may not be completely accurate.
 * For a slower function that handles the full floating point finite range, use glsl_packFloat.
 */

exports.glsl_packFloat01ToFixedPoint = `
vec4 packFloat01ToFixedPoint(const float value) {
  const vec4 shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
  const vec4 mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
  vec4 result = fract(value * shift);
  result -= result.xxyz * mask;
  return result * 256.0 / 255.0;
}
`;
function unpackFloat01FromFixedPoint(data) {
  return (data[3] + data[2] * (1.0 / 256.0) + data[1] * (1.0 / 65536.0) + data[0] * (1.0 / 16777216.0)) / 256.0;
}
exports.unpackFloat01FromFixedPoint = unpackFloat01FromFixedPoint;
// Hue, saturation, and value are in [0, 1] range.
exports.glsl_hsvToRgb = `
vec3 hueToRgb(float hue) {
  float hue6 = hue * 6.0;
  float r = abs(hue6 - 3.0) - 1.0;
  float g = 2.0 - abs(hue6 - 2.0);
  float b = 2.0 - abs(hue6 - 4.0);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 hsvToRgb(vec3 c) {
  vec3 hueRgb = hueToRgb(c.x);
  return c.z * ((hueRgb - 1.0) * c.y + 1.0);
}
`;
exports.glsl_uint64 = `
struct uint64_t {
  vec4 low, high;
};
uint64_t toUint64(uint64_t x) { return x; }
`;
exports.glsl_uint8 = [exports.glsl_uint64, `
struct uint8_t {
  float value;
};
float toRaw(uint8_t x) { return x.value * 255.0; }
float toNormalized(uint8_t x) { return x.value; }
uint64_t toUint64(uint8_t x) {
  uint64_t result;
  result.low = vec4(x.value, 0.0, 0.0, 0.0);
  result.high = vec4(0.0, 0.0, 0.0, 0.0);
  return result;
}
`];
exports.glsl_float = `
float toRaw(float x) { return x; }
float toNormalized(float x) { return x; }
`;
exports.glsl_uint16 = [exports.glsl_uint64, `
struct uint16_t {
  vec2 value;
};
float toRaw(uint16_t x) { return x.value.x * 255.0 + x.value.y * 65280.0; }
float toNormalized(uint16_t x) { return toRaw(x) / 65535.0; }
uint64_t toUint64(uint16_t x) {
  uint64_t result;
  result.low = vec4(x.value, 0.0, 0.0);
  result.high = vec4(0.0, 0.0, 0.0, 0.0);
  return result;
}
`];
exports.glsl_uint32 = [exports.glsl_uint64, `
struct uint32_t {
  vec4 value;
};
uint64_t toUint64(uint32_t x) {
  uint64_t result;
  result.low = x.value;
  result.high = vec4(0.0, 0.0, 0.0, 0.0);
  return result;
}
`];
exports.glsl_getSubscriptsFromNormalized = `
vec3 getSubscriptsFromNormalized(vec3 normalizedPosition, vec3 size) {
  return floor(min(normalizedPosition * size, size - 1.0));
}
`;
exports.glsl_getFortranOrderIndex = `
float getFortranOrderIndex(vec3 subscripts, vec3 size) {
  return subscripts.x + size.x * (subscripts.y + size.y * subscripts.z);
}
`;
exports.glsl_getFortranOrderIndexFromNormalized = [exports.glsl_getSubscriptsFromNormalized, exports.glsl_getFortranOrderIndex, `
float getFortranOrderIndexFromNormalized(vec3 normalizedPosition, vec3 size) {
  return getFortranOrderIndex(getSubscriptsFromNormalized(normalizedPosition, size), size);
}
`];
exports.glsl_imod = `
float imod(float x, float y) {
  return x - y * floor(x / y);
}
`;
// Chrome 49 on NVIDIA Quadro K600 gives inexact results when using the built-in dot function.
exports.glsl_exactDot = `
float exactDot(vec4 a, vec4 b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
float exactDot(vec3 a, vec3 b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
`;
function fract(x) {
  return x - Math.floor(x);
}
exports.fract = fract;
function step(edge, x) {
  return x < edge ? 0 : 1;
}
exports.step = step;
function mod(x, y) {
  return x % y;
}
exports.mod = mod;
function exp2(x) {
  return Math.pow(2, x);
}
exports.exp2 = exp2;
/* WebGL 1.0 does not provide a convenient way to directly output float values from fragment
 * shaders; only 4-channel uint8 values (represented as floats in the range [0,1]) are supported.
 * Obtaining float values is particularly useful for debugging and unit testing.  This GLSL function
 * encodes a floating point value into a vector of 4 floats in the range [0,1] such that the
 * corresponding uint8 representation is the little endian IEEE 754 32-bit floating point format.
 *
 * Infinity and NaN values are not supported.  This function is not particularly efficient; it is
 * intended to be used only for debugging and testing.
 *
 * The GLSL function packFloatIntoVec4 is based on code posted to StackOverflow by user hrehfeld at
 * http://stackoverflow.com/a/14729074 and user Arjan at http://stackoverflow.com/a/11158534
 * licensed under CC BY-SA 3.0 ( http://creativecommons.org/licenses/by-sa/3.0/ ).
 */
exports.glsl_packFloat = `
vec4 packFloatIntoVec4(float f) {
  float magnitude = abs(f); 
  if (magnitude == 0.0) {
     return vec4(0,0,0,0);
  }
  float sign =  step(0.0, -f);
  float exponent = floor(log2(magnitude)); 
  float mantissa = magnitude / exp2(exponent); 
  // Denormalized values if all exponent bits are zero
  if (mantissa < 1.0) {
     exponent -= 1.0;
  }

  exponent +=  127.0;

  vec4 result;
  result[3] = 128.0 * sign + floor(exponent / 2.0);
  result[2] = 128.0 * mod(exponent, 2.0) +  mod(floor(mantissa * float(128.0)),128.0);
  result[1] = floor( mod(floor(mantissa* exp2(float(23.0 - 8.0))), exp2(8.0)));
  result[0] = floor( exp2(23.0)* mod(mantissa, exp2(-15.0)));
  return result / 255.0;
}
`;
exports.glsl_debugFunctions = [exports.glsl_packFloat];
function encodeBytesToFloat32(x) {
  var xBytes = new Uint8Array(x.buffer, x.byteOffset, x.byteLength);
  var length = xBytes.length;
  var result = new Float32Array(length);
  for (var i = 0; i < length; ++i) {
    result[i] = xBytes[i] / 255;
  }
  return result;
}
exports.encodeBytesToFloat32 = encodeBytesToFloat32;
function setVec4FromUint32(out, x) {
  for (var j = 0; j < 4; ++j) {
    out[j] = (x >> j * 8 & 0xFF) / 255.0;
  }
  return out;
}
exports.setVec4FromUint32 = setVec4FromUint32;
function getUint32FromVec4(v) {
  return v[0] * 255 + v[1] * 255 * 256 + v[2] * 255 * 256 * 256 + v[3] * 255 * 256 * 256 * 256;
}
exports.getUint32FromVec4 = getUint32FromVec4;

/***/ },
/* 73 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 74 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var base_1 = __webpack_require__(76);
var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var uint64_1 = __webpack_require__(52);
var use_count_1 = __webpack_require__(53);
var worker_rpc_1 = __webpack_require__(22);
var signals_1 = __webpack_require__(34);

var Uint64MapEntry = function () {
    function Uint64MapEntry(key, value) {
        _classCallCheck(this, Uint64MapEntry);

        this.key = key;
        this.value = value;
    }

    _createClass(Uint64MapEntry, [{
        key: 'toString',
        value: function toString() {
            return `${ this.key }→${ this.value }`;
        }
    }]);

    return Uint64MapEntry;
}();

exports.Uint64MapEntry = Uint64MapEntry;
;

var SegmentSelectionState = function (_disposable_1$RefCoun) {
    _inherits(SegmentSelectionState, _disposable_1$RefCoun);

    function SegmentSelectionState() {
        _classCallCheck(this, SegmentSelectionState);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SegmentSelectionState).call(this, ...args));

        _this.selectedSegment = new uint64_1.Uint64();
        _this.hasSelectedSegment = false;
        _this.changed = new signals_1.Signal();
        return _this;
    }

    _createClass(SegmentSelectionState, [{
        key: 'set',
        value: function set(value) {
            if (value == null) {
                if (this.hasSelectedSegment) {
                    this.hasSelectedSegment = false;
                    this.changed.dispatch();
                }
            } else {
                var existingValue = this.selectedSegment;
                if (!this.hasSelectedSegment || value.low !== existingValue.low || value.high !== existingValue.high) {
                    existingValue.low = value.low;
                    existingValue.high = value.high;
                    this.hasSelectedSegment = true;
                    this.changed.dispatch();
                }
            }
        }
    }, {
        key: 'isSelected',
        value: function isSelected(value) {
            return this.hasSelectedSegment && uint64_1.Uint64.equal(value, this.selectedSegment);
        }
    }, {
        key: 'bindTo',
        value: function bindTo(layerSelectedValues, userLayer) {
            var temp = new uint64_1.Uint64();
            this.registerSignalBinding(layerSelectedValues.changed.add(() => {
                var value = layerSelectedValues.get(userLayer);
                if (typeof value === 'number') {
                    temp.low = value;
                    temp.high = 0;
                    value = temp;
                } else if (value instanceof Uint64MapEntry) {
                    value = value.value;
                }
                this.set(value);
            }));
        }
    }]);

    return SegmentSelectionState;
}(disposable_1.RefCounted);

exports.SegmentSelectionState = SegmentSelectionState;
;
function registerRedrawWhenSegmentationDisplayStateChanged(displayState, renderLayer) {
    var dispatchRedrawNeeded = () => {
        renderLayer.redrawNeeded.dispatch();
    };
    renderLayer.registerSignalBinding(displayState.segmentColorHash.changed.add(dispatchRedrawNeeded));
    renderLayer.registerSignalBinding(displayState.visibleSegments.changed.add(dispatchRedrawNeeded));
    renderLayer.registerSignalBinding(displayState.segmentEquivalences.changed.add(dispatchRedrawNeeded));
    renderLayer.registerSignalBinding(displayState.segmentSelectionState.changed.add(dispatchRedrawNeeded));
}
exports.registerRedrawWhenSegmentationDisplayStateChanged = registerRedrawWhenSegmentationDisplayStateChanged;
/**
 * Temporary value used by getObjectColor.
 */
var tempColor = geom_1.vec3.create();
function getObjectColor(displayState, objectId) {
    var color = tempColor;
    displayState.segmentColorHash.compute(color, objectId);
    if (displayState.segmentSelectionState.isSelected(objectId)) {
        for (var i = 0; i < 3; ++i) {
            color[i] = color[i] * 0.5 + 0.5;
        }
    }
    return color;
}
exports.getObjectColor = getObjectColor;
function forEachSegmentToDraw(displayState, objects, callback) {
    base_1.forEachVisibleSegment(displayState, (objectId, rootObjectId) => {
        var key = base_1.getObjectKey(objectId);
        var segmentData = objects.get(key);
        if (segmentData !== undefined) {
            callback(rootObjectId, objectId, segmentData);
        }
    });
}
exports.forEachSegmentToDraw = forEachSegmentToDraw;

var SegmentationLayerSharedObject = function (_worker_rpc_1$SharedO) {
    _inherits(SegmentationLayerSharedObject, _worker_rpc_1$SharedO);

    function SegmentationLayerSharedObject(chunkManager, displayState) {
        _classCallCheck(this, SegmentationLayerSharedObject);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SegmentationLayerSharedObject).call(this));

        _this2.chunkManager = chunkManager;
        _this2.displayState = displayState;
        _this2.visibilityCount = new use_count_1.UseCount();
        return _this2;
    }

    _createClass(SegmentationLayerSharedObject, [{
        key: 'initializeCounterpartWithChunkManager',
        value: function initializeCounterpartWithChunkManager(options) {
            var displayState = this.displayState;
            var visibilityCount = this.visibilityCount;

            options['chunkManager'] = this.chunkManager.rpcId;
            options['visibleSegments'] = displayState.visibleSegments.rpcId;
            options['segmentEquivalences'] = displayState.segmentEquivalences.rpcId;
            _get(Object.getPrototypeOf(SegmentationLayerSharedObject.prototype), 'initializeCounterpart', this).call(this, this.chunkManager.rpc, options);
            visibilityCount.becameNonZero.add(() => {
                if (this.rpc != null) {
                    this.rpc.invoke(base_1.ON_VISIBILITY_CHANGE_METHOD_ID, { 'id': this.rpcId, 'visible': true });
                }
            });
            visibilityCount.becameZero.add(() => {
                if (this.rpc != null) {
                    this.rpc.invoke(base_1.ON_VISIBILITY_CHANGE_METHOD_ID, { 'id': this.rpcId, 'visible': false });
                }
            });
        }
    }]);

    return SegmentationLayerSharedObject;
}(worker_rpc_1.SharedObject);

exports.SegmentationLayerSharedObject = SegmentationLayerSharedObject;

/***/ },
/* 76 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Returns a string key for identifying a uint64 object id.  This is faster than
 * Uint64.prototype.toString().
 */

function getObjectKey(objectId) {
    return `${ objectId.low },${ objectId.high }`;
}
exports.getObjectKey = getObjectKey;
function forEachVisibleSegment(state, callback) {
    var visibleSegments = state.visibleSegments;
    var segmentEquivalences = state.segmentEquivalences;

    for (var rootObjectId of visibleSegments) {
        // TODO(jbms): Remove this check if logic is added to ensure that it always holds.
        if (!segmentEquivalences.disjointSets.isMinElement(rootObjectId)) {
            continue;
        }
        for (var objectId of segmentEquivalences.setElements(rootObjectId)) {
            callback(objectId, rootObjectId);
        }
    }
}
exports.forEachVisibleSegment = forEachVisibleSegment;
exports.ON_VISIBILITY_CHANGE_METHOD_ID = 'SegmentationLayerSharedObject.onVisibilityChange';

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var base_1 = __webpack_require__(31);
var frontend_1 = __webpack_require__(32);
var perspective_panel_1 = __webpack_require__(36);
var frontend_2 = __webpack_require__(75);
var base_2 = __webpack_require__(78);
var panel_1 = __webpack_require__(79);
var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var json_1 = __webpack_require__(8);
var buffer_1 = __webpack_require__(38);
var shader_1 = __webpack_require__(41);
var shader_lib_1 = __webpack_require__(72);
var signals_1 = __webpack_require__(34);

var SkeletonShaderManager = function () {
    function SkeletonShaderManager() {
        _classCallCheck(this, SkeletonShaderManager);

        this.tempMat = geom_1.mat4.create();
        this.tempPickID = new Float32Array(4);
    }

    _createClass(SkeletonShaderManager, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            builder.addAttribute('highp vec3', 'aVertexPosition');
            builder.addUniform('highp vec3', 'uColor');
            builder.addUniform('highp mat4', 'uProjection');
            builder.addUniform('highp vec4', 'uPickID');
            builder.setVertexMain(`gl_Position = uProjection * vec4(aVertexPosition, 1.0);`);
            builder.setFragmentMain(`emit(vec4(uColor, 1.0), uPickID);`);
        }
    }, {
        key: 'beginLayer',
        value: function beginLayer(gl, shader, renderContext, objectToDataMatrix) {
            var dataToDevice = renderContext.dataToDevice;

            var mat = geom_1.mat4.multiply(this.tempMat, dataToDevice, objectToDataMatrix);
            gl.uniformMatrix4fv(shader.uniform('uProjection'), false, mat);
        }
    }, {
        key: 'getShader',
        value: function getShader(gl, key, emitter) {
            return gl.memoize.get(key, () => {
                var builder = new shader_1.ShaderBuilder(gl);
                builder.require(emitter);
                this.defineShader(builder);
                return builder.build();
            });
        }
    }, {
        key: 'setColor',
        value: function setColor(gl, shader, color) {
            gl.uniform3fv(shader.uniform('uColor'), color);
        }
    }, {
        key: 'drawSkeleton',
        value: function drawSkeleton(gl, shader, skeletonChunk, pickID) {
            gl.uniform4fv(shader.uniform('uPickID'), shader_lib_1.setVec4FromUint32(this.tempPickID, pickID));
            skeletonChunk.vertexBuffer.bindToVertexAttrib(shader.attribute('aVertexPosition'),
            /*components=*/3);
            skeletonChunk.indexBuffer.bind();
            gl.drawElements(gl.LINES, skeletonChunk.numIndices, gl.UNSIGNED_INT, 0);
        }
    }, {
        key: 'endLayer',
        value: function endLayer(gl, shader) {
            gl.disableVertexAttribArray(shader.attribute('aVertexPosition'));
        }
    }]);

    return SkeletonShaderManager;
}();

;

var PerspectiveViewSkeletonLayer = function (_perspective_panel_1$) {
    _inherits(PerspectiveViewSkeletonLayer, _perspective_panel_1$);

    function PerspectiveViewSkeletonLayer(base) {
        _classCallCheck(this, PerspectiveViewSkeletonLayer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PerspectiveViewSkeletonLayer).call(this));

        _this.base = base;
        _this.shader = _this.base.skeletonShaderManager.getShader(_this.gl, 'skeleton/SkeletonShaderManager:PerspectivePanel', perspective_panel_1.perspectivePanelEmit);
        _this.registerDisposer(base);
        _this.registerSignalBinding(base.redrawNeeded.add(() => {
            _this.redrawNeeded.dispatch();
        }));
        _this.setReady(true);
        _this.visibilityCount.addDependency(base.visibilityCount);
        return _this;
    }

    _createClass(PerspectiveViewSkeletonLayer, [{
        key: 'draw',
        value: function draw(renderContext) {
            var pickingOnly = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

            this.base.draw(renderContext, this, this.shader, pickingOnly);
        }
    }, {
        key: 'drawPicking',
        value: function drawPicking(renderContext) {
            this.base.draw(renderContext, this, this.shader, true);
        }
    }, {
        key: 'gl',
        get: function () {
            return this.base.gl;
        }
    }]);

    return PerspectiveViewSkeletonLayer;
}(perspective_panel_1.PerspectiveViewRenderLayer);

exports.PerspectiveViewSkeletonLayer = PerspectiveViewSkeletonLayer;
;

var SliceViewPanelSkeletonLayer = function (_panel_1$SliceViewPan) {
    _inherits(SliceViewPanelSkeletonLayer, _panel_1$SliceViewPan);

    function SliceViewPanelSkeletonLayer(base) {
        _classCallCheck(this, SliceViewPanelSkeletonLayer);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SliceViewPanelSkeletonLayer).call(this));

        _this2.base = base;
        _this2.shader = _this2.base.skeletonShaderManager.getShader(_this2.gl, 'skeleton/SkeletonShaderManager:SliceViewPanel', panel_1.sliceViewPanelEmit);
        _this2.registerDisposer(base);
        _this2.registerSignalBinding(base.redrawNeeded.add(() => {
            _this2.redrawNeeded.dispatch();
        }));
        _this2.setReady(true);
        _this2.visibilityCount.addDependency(base.visibilityCount);
        return _this2;
    }

    _createClass(SliceViewPanelSkeletonLayer, [{
        key: 'draw',
        value: function draw(renderContext) {
            this.base.draw(renderContext, this, this.shader, false, 10);
        }
    }, {
        key: 'gl',
        get: function () {
            return this.base.gl;
        }
    }]);

    return SliceViewPanelSkeletonLayer;
}(panel_1.SliceViewPanelRenderLayer);

exports.SliceViewPanelSkeletonLayer = SliceViewPanelSkeletonLayer;
;

var SkeletonLayer = function (_disposable_1$RefCoun) {
    _inherits(SkeletonLayer, _disposable_1$RefCoun);

    function SkeletonLayer(chunkManager, source, voxelSizeObject, displayState) {
        _classCallCheck(this, SkeletonLayer);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(SkeletonLayer).call(this));

        _this3.chunkManager = chunkManager;
        _this3.source = source;
        _this3.voxelSizeObject = voxelSizeObject;
        _this3.displayState = displayState;
        _this3.tempMat = geom_1.mat4.create();
        _this3.skeletonShaderManager = new SkeletonShaderManager();
        _this3.redrawNeeded = new signals_1.Signal();
        frontend_2.registerRedrawWhenSegmentationDisplayStateChanged(displayState, _this3);
        var sharedObject = _this3.sharedObject = _this3.registerDisposer(new frontend_2.SegmentationLayerSharedObject(chunkManager, displayState));
        sharedObject.RPC_TYPE_ID = base_2.SKELETON_LAYER_RPC_ID;
        sharedObject.initializeCounterpartWithChunkManager({
            'source': source.addCounterpartRef()
        });
        return _this3;
    }

    _createClass(SkeletonLayer, [{
        key: 'draw',
        value: function draw(renderContext, layer, shader) {
            var pickingOnly = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
            var lineWidth = arguments[4];

            if (lineWidth === undefined) {
                lineWidth = pickingOnly ? 5 : 1;
            }
            var gl = this.gl;
            var skeletonShaderManager = this.skeletonShaderManager;
            var source = this.source;

            shader.bind();
            var objectToDataMatrix = this.tempMat;
            geom_1.mat4.identity(objectToDataMatrix);
            if (source.skeletonVertexCoordinatesInVoxels) {
                geom_1.mat4.scale(objectToDataMatrix, objectToDataMatrix, this.voxelSizeObject.size);
            }
            skeletonShaderManager.beginLayer(gl, shader, renderContext, objectToDataMatrix);
            var skeletons = source.chunks;
            var pickIDs = renderContext.pickIDs;
            var displayState = this.displayState;

            gl.lineWidth(lineWidth);
            frontend_2.forEachSegmentToDraw(displayState, skeletons, (rootObjectId, objectId, skeleton) => {
                if (skeleton.state !== base_1.ChunkState.GPU_MEMORY) {
                    return;
                }
                if (!pickingOnly) {
                    skeletonShaderManager.setColor(gl, shader, frontend_2.getObjectColor(displayState, rootObjectId));
                }
                skeletonShaderManager.drawSkeleton(gl, shader, skeleton, pickIDs.register(layer, objectId));
            });
            skeletonShaderManager.endLayer(gl, shader);
        }
    }, {
        key: 'visibilityCount',
        get: function () {
            return this.sharedObject.visibilityCount;
        }
    }, {
        key: 'gl',
        get: function () {
            return this.chunkManager.chunkQueueManager.gl;
        }
    }]);

    return SkeletonLayer;
}(disposable_1.RefCounted);

exports.SkeletonLayer = SkeletonLayer;
;

var SkeletonChunk = function (_frontend_1$Chunk) {
    _inherits(SkeletonChunk, _frontend_1$Chunk);

    function SkeletonChunk(source, x) {
        _classCallCheck(this, SkeletonChunk);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(SkeletonChunk).call(this, source));

        _this4.vertexPositions = x['vertexPositions'];
        var indices = _this4.indices = x['indices'];
        _this4.numIndices = indices.length;
        return _this4;
    }

    _createClass(SkeletonChunk, [{
        key: 'copyToGPU',
        value: function copyToGPU(gl) {
            _get(Object.getPrototypeOf(SkeletonChunk.prototype), 'copyToGPU', this).call(this, gl);
            this.vertexBuffer = buffer_1.Buffer.fromData(gl, this.vertexPositions, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
            this.indexBuffer = buffer_1.Buffer.fromData(gl, this.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);
        }
    }, {
        key: 'freeGPUMemory',
        value: function freeGPUMemory(gl) {
            _get(Object.getPrototypeOf(SkeletonChunk.prototype), 'freeGPUMemory', this).call(this, gl);
            this.vertexBuffer.dispose();
            this.indexBuffer.dispose();
        }
    }]);

    return SkeletonChunk;
}(frontend_1.Chunk);

exports.SkeletonChunk = SkeletonChunk;
;

var SkeletonSource = function (_frontend_1$ChunkSour) {
    _inherits(SkeletonSource, _frontend_1$ChunkSour);

    function SkeletonSource() {
        _classCallCheck(this, SkeletonSource);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SkeletonSource).apply(this, arguments));
    }

    _createClass(SkeletonSource, [{
        key: 'getChunk',
        value: function getChunk(x) {
            return new SkeletonChunk(this, x);
        }
        /**
         * Specifies whether the skeleton vertex coordinates are specified in units of voxels rather than
         * nanometers.
         */

    }, {
        key: 'skeletonVertexCoordinatesInVoxels',
        get: function () {
            return true;
        }
    }]);

    return SkeletonSource;
}(frontend_1.ChunkSource);

exports.SkeletonSource = SkeletonSource;
;

var ParameterizedSkeletonSource = function (_SkeletonSource) {
    _inherits(ParameterizedSkeletonSource, _SkeletonSource);

    function ParameterizedSkeletonSource(chunkManager, parameters) {
        _classCallCheck(this, ParameterizedSkeletonSource);

        var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(ParameterizedSkeletonSource).call(this, chunkManager));

        _this6.parameters = parameters;
        return _this6;
    }

    _createClass(ParameterizedSkeletonSource, [{
        key: 'initializeCounterpart',
        value: function initializeCounterpart(rpc, options) {
            options['parameters'] = this.parameters;
            _get(Object.getPrototypeOf(ParameterizedSkeletonSource.prototype), 'initializeCounterpart', this).call(this, rpc, options);
        }
    }]);

    return ParameterizedSkeletonSource;
}(SkeletonSource);

exports.ParameterizedSkeletonSource = ParameterizedSkeletonSource;
;
/**
 * Defines a SkeletonSource for which all state is encapsulated in an object of type Parameters.
 */
function parameterizedSkeletonSource(parametersConstructor) {
    var newConstructor = function (_ParameterizedSkeleto) {
        _inherits(SpecializedParameterizedSkeletonSource, _ParameterizedSkeleto);

        function SpecializedParameterizedSkeletonSource() {
            _classCallCheck(this, SpecializedParameterizedSkeletonSource);

            return _possibleConstructorReturn(this, Object.getPrototypeOf(SpecializedParameterizedSkeletonSource).apply(this, arguments));
        }

        _createClass(SpecializedParameterizedSkeletonSource, [{
            key: 'toString',
            value: function toString() {
                return parametersConstructor.stringify(this.parameters);
            }
        }], [{
            key: 'get',
            value: function get(chunkManager, parameters) {
                return chunkManager.getChunkSource(this, json_1.stableStringify(parameters), () => new this(chunkManager, parameters));
            }
        }]);

        return SpecializedParameterizedSkeletonSource;
    }(ParameterizedSkeletonSource);
    newConstructor.prototype.RPC_TYPE_ID = parametersConstructor.RPC_ID;
    return newConstructor;
}
exports.parameterizedSkeletonSource = parameterizedSkeletonSource;

/***/ },
/* 78 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

exports.SKELETON_LAYER_RPC_ID = 'skeleton/SkeletonLayer';

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var axes_lines_1 = __webpack_require__(37);
var layer_1 = __webpack_require__(42);
var object_picking_1 = __webpack_require__(54);
var rendered_data_panel_1 = __webpack_require__(55);
var frontend_1 = __webpack_require__(60);
var trackable_boolean_1 = __webpack_require__(70);
var geom_1 = __webpack_require__(9);
var mouse_drag_1 = __webpack_require__(71);
var offscreen_1 = __webpack_require__(68);
var scale_bar_1 = __webpack_require__(80);
(function (OffscreenTextures) {
    OffscreenTextures[OffscreenTextures["COLOR"] = 0] = "COLOR";
    OffscreenTextures[OffscreenTextures["PICK"] = 1] = "PICK";
    OffscreenTextures[OffscreenTextures["NUM_TEXTURES"] = 2] = "NUM_TEXTURES";
})(exports.OffscreenTextures || (exports.OffscreenTextures = {}));
var OffscreenTextures = exports.OffscreenTextures;
function sliceViewPanelEmit(builder) {
    builder.addFragmentExtension('GL_EXT_draw_buffers');
    builder.addFragmentCode(`
void emit(vec4 color, vec4 pickId) {
  gl_FragData[${ OffscreenTextures.COLOR }] = color;
  gl_FragData[${ OffscreenTextures.PICK }] = pickId;
}
`);
}
exports.sliceViewPanelEmit = sliceViewPanelEmit;

var SliceViewPanelRenderLayer = function (_layer_1$VisibilityTr) {
    _inherits(SliceViewPanelRenderLayer, _layer_1$VisibilityTr);

    function SliceViewPanelRenderLayer() {
        _classCallCheck(this, SliceViewPanelRenderLayer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SliceViewPanelRenderLayer).apply(this, arguments));
    }

    _createClass(SliceViewPanelRenderLayer, [{
        key: 'draw',
        value: function draw(renderContext) {
            // Must be overriden by subclass.
        }
    }]);

    return SliceViewPanelRenderLayer;
}(layer_1.VisibilityTrackedRenderLayer);

exports.SliceViewPanelRenderLayer = SliceViewPanelRenderLayer;
;

var SliceViewPanel = function (_rendered_data_panel_) {
    _inherits(SliceViewPanel, _rendered_data_panel_);

    function SliceViewPanel(context, element, sliceView, viewer) {
        _classCallCheck(this, SliceViewPanel);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SliceViewPanel).call(this, context, element, viewer));

        _this2.sliceView = sliceView;
        _this2.axesLineHelper = axes_lines_1.AxesLineHelper.get(_this2.gl);
        _this2.sliceViewRenderHelper = frontend_1.SliceViewRenderHelper.get(_this2.gl, 'SliceViewRenderHelper', sliceViewPanelEmit);
        _this2.colorFactor = geom_1.vec4.fromValues(1, 1, 1, 1);
        _this2.backgroundColor = geom_1.vec4.fromValues(0.5, 0.5, 0.5, 1.0);
        _this2.pickIDs = new object_picking_1.PickIDManager();
        _this2.visibleLayerTracker = layer_1.makeRenderedPanelVisibleLayerTracker(_this2.viewer.layerManager, SliceViewPanelRenderLayer, _this2);
        _this2.offscreenFramebuffer = new offscreen_1.OffscreenFramebuffer(_this2.gl, { numDataBuffers: OffscreenTextures.NUM_TEXTURES });
        _this2.offscreenCopyHelper = offscreen_1.OffscreenCopyHelper.get(_this2.gl);
        _this2.scaleBarWidget = _this2.registerDisposer(new scale_bar_1.ScaleBarWidget());
        _this2.registerDisposer(sliceView);
        _this2.registerSignalBinding(sliceView.viewChanged.add(context.scheduleRedraw, context));
        _this2.registerSignalBinding(viewer.showAxisLines.changed.add(() => {
            _this2.scheduleRedraw();
        }));
        {
            var scaleBar = _this2.scaleBarWidget.element;
            _this2.registerDisposer(new trackable_boolean_1.ElementVisibilityFromTrackableBoolean(viewer.showScaleBar, scaleBar));
            _this2.element.appendChild(scaleBar);
        }
        return _this2;
    }

    _createClass(SliceViewPanel, [{
        key: 'draw',
        value: function draw() {
            var sliceView = this.sliceView;

            if (!sliceView.hasValidViewport) {
                return;
            }
            sliceView.updateRendering();
            var gl = this.gl;
            var width = sliceView.width;
            var height = sliceView.height;
            var dataToDevice = sliceView.dataToDevice;

            this.offscreenFramebuffer.bind(width, height);
            gl.disable(gl.SCISSOR_TEST);
            this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            // Draw axes lines.
            // FIXME: avoid use of temporary matrix
            var mat = geom_1.mat4.create();
            this.sliceViewRenderHelper.draw(sliceView.offscreenFramebuffer.dataTextures[0], geom_1.identityMat4, this.colorFactor, this.backgroundColor, 0, 0, 1, 1);
            var visibleLayers = this.visibleLayerTracker.getVisibleLayers();
            var pickIDs = this.pickIDs;

            pickIDs.clear();
            var renderContext = { dataToDevice: sliceView.dataToDevice, pickIDs: pickIDs };
            for (var renderLayer of visibleLayers) {
                renderLayer.draw(renderContext);
            }
            if (this.viewer.showAxisLines.value) {
                // Construct matrix that maps [-1, +1] x/y range to the full viewport data
                // coordinates.
                geom_1.mat4.copy(mat, dataToDevice);
                for (var i = 0; i < 3; ++i) {
                    mat[12 + i] = 0;
                }
                for (var _i = 0; _i < 4; ++_i) {
                    mat[2 + 4 * _i] = 0;
                }
                var axisLength = Math.min(width, height) / 4 * 1.5;
                var pixelSize = sliceView.pixelSize;
                for (var _i2 = 0; _i2 < 12; ++_i2) {
                    // pixelSize is nm / pixel
                    //
                    mat[_i2] *= axisLength * pixelSize;
                }
                gl.WEBGL_draw_buffers.drawBuffersWEBGL([gl.WEBGL_draw_buffers.COLOR_ATTACHMENT0_WEBGL]);
                this.axesLineHelper.draw(mat);
            }
            this.offscreenFramebuffer.unbind();
            // Draw the texture over the whole viewport.
            this.setGLViewport();
            this.offscreenCopyHelper.draw(this.offscreenFramebuffer.dataTextures[OffscreenTextures.COLOR]);
            // Update the scale bar if needed.
            {
                var scaleBarWidget = this.scaleBarWidget;
                var dimensions = scaleBarWidget.dimensions;

                dimensions.targetLengthInPixels = Math.min(width / 4, 100);
                dimensions.nanometersPerPixel = sliceView.pixelSize;
                scaleBarWidget.update();
            }
        }
    }, {
        key: 'onResize',
        value: function onResize() {
            this.sliceView.setViewportSize(this.element.clientWidth, this.element.clientHeight);
        }
    }, {
        key: 'updateMouseState',
        value: function updateMouseState(mouseState) {
            mouseState.pickedRenderLayer = null;
            var sliceView = this.sliceView;
            if (!sliceView.hasValidViewport) {
                return false;
            }
            var width = sliceView.width;
            var height = sliceView.height;
            var offscreenFramebuffer = this.offscreenFramebuffer;

            if (!offscreenFramebuffer.hasSize(width, height)) {
                return false;
            }
            var out = mouseState.position;
            var glWindowX = this.mouseX;
            var y = this.mouseY;
            geom_1.vec3.set(out, glWindowX - width / 2, y - height / 2, 0);
            geom_1.vec3.transformMat4(out, out, sliceView.viewportToData);
            var glWindowY = height - y;
            this.pickIDs.setMouseState(mouseState, offscreenFramebuffer.readPixelAsUint32(OffscreenTextures.PICK, glWindowX, glWindowY));
            return true;
        }
    }, {
        key: 'onMousedown',
        value: function onMousedown(e) {
            var _this3 = this;

            if (e.target !== this.element) {
                return;
            }
            _get(Object.getPrototypeOf(SliceViewPanel.prototype), 'onMousedown', this).call(this, e);
            if (!this.sliceView.hasValidViewport) {
                return;
            }
            if (e.button === 0) {
                var mouseState = this.viewer.mouseState;

                if (mouseState.updateUnconditionally()) {
                    (function () {
                        var initialPosition = geom_1.vec3.clone(_this3.viewer.mouseState.position);
                        mouse_drag_1.startRelativeMouseDrag(e, (event, deltaX, deltaY) => {
                            var position = _this3.viewer.navigationState.position;

                            if (event.shiftKey) {
                                var viewportAxes = _this3.sliceView.viewportAxes;

                                _this3.viewer.navigationState.pose.rotateAbsolute(viewportAxes[1], deltaX / 4.0 * Math.PI / 180.0, initialPosition);
                                _this3.viewer.navigationState.pose.rotateAbsolute(viewportAxes[0], deltaY / 4.0 * Math.PI / 180.0, initialPosition);
                            } else {
                                var pos = position.spatialCoordinates;
                                geom_1.vec3.set(pos, deltaX, deltaY, 0);
                                geom_1.vec3.transformMat4(pos, pos, _this3.sliceView.viewportToData);
                                position.changed.dispatch();
                            }
                        });
                    })();
                }
            }
        }
        /**
         * Zooms by the specified factor, maintaining the data position that projects to the current mouse
         * position.
         */

    }, {
        key: 'zoomByMouse',
        value: function zoomByMouse(factor) {
            var navigationState = this.navigationState;

            if (!navigationState.valid) {
                return;
            }
            var sliceView = this.sliceView;
            var width = sliceView.width;
            var height = sliceView.height;
            var mouseX = this.mouseX;
            var mouseY = this.mouseY;

            mouseX -= width / 2;
            mouseY -= height / 2;
            var oldZoom = this.navigationState.zoomFactor.value;
            // oldPosition + (mouseX * viewportAxes[0] + mouseY * viewportAxes[1]) * oldZoom
            //     === newPosition + (mouseX * viewportAxes[0] + mouseY * viewportAxes[1]) * newZoom
            // Therefore, we compute newPosition by:
            // newPosition = oldPosition + (viewportAxes[0] * mouseX +
            //                              viewportAxes[1] * mouseY) * (oldZoom - newZoom).
            navigationState.zoomBy(factor);
            var newZoom = navigationState.zoomFactor.value;
            var spatialCoordinates = navigationState.position.spatialCoordinates;

            geom_1.vec3.scaleAndAdd(spatialCoordinates, spatialCoordinates, sliceView.viewportAxes[0], mouseX * (oldZoom - newZoom));
            geom_1.vec3.scaleAndAdd(spatialCoordinates, spatialCoordinates, sliceView.viewportAxes[1], mouseY * (oldZoom - newZoom));
            navigationState.position.changed.dispatch();
        }
    }, {
        key: 'navigationState',
        get: function () {
            return this.sliceView.navigationState;
        }
    }]);

    return SliceViewPanel;
}(rendered_data_panel_1.RenderedDataPanel);

exports.SliceViewPanel = SliceViewPanel;
;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Facility for drawing a scale bar to indicate pixel size in physical length
 * units.
 *
 * The physical length with which the scale bar is labeled will be of the form:
 *
 *   significand * 10^exponent
 *
 * Any exponent may be used, but the significand in the range [1, 10] will be
 * equal to one of a
 * discrete set of allowed significand values, in order to ensure that the scale
 * bar is easy to
 * understand.
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var disposable_1 = __webpack_require__(23);
var dom_1 = __webpack_require__(7);
__webpack_require__(81);
/**
 * Default set of allowed significand values.  1 is implicitly part of the set.
 */
var DEFAULT_ALLOWED_SIGNIFICANDS = [1.5, 2, 3, 5, 7.5, 10];
var ALLOWED_UNITS = [{ unit: 'km', lengthInNanometers: 1e12 }, { unit: 'm', lengthInNanometers: 1e9 }, { unit: 'mm', lengthInNanometers: 1e6 }, { unit: 'µm', lengthInNanometers: 1e3 }, { unit: 'nm', lengthInNanometers: 1 }, { unit: 'pm', lengthInNanometers: 1e-3 }];

var ScaleBarDimensions = function () {
    function ScaleBarDimensions() {
        _classCallCheck(this, ScaleBarDimensions);

        /**
         * Allowed significand values.  1 is not included, but is always considered
         * part of the set.
         */
        this.allowedSignificands = DEFAULT_ALLOWED_SIGNIFICANDS;
        this.prevNanometersPerPixel = 0;
        this.prevTargetLengthInPixels = 0;
    }
    /**
     * Updates physicalLength, physicalUnit, and lengthInPixels to be the optimal
     * values corresponding
     * to targetLengthInPixels and nanometersPerPixel.
     *
     * @returns true if the scale bar has changed, false if it is unchanged.
     */


    _createClass(ScaleBarDimensions, [{
        key: 'update',
        value: function update() {
            var nanometersPerPixel = this.nanometersPerPixel;
            var targetLengthInPixels = this.targetLengthInPixels;

            if (this.prevNanometersPerPixel === nanometersPerPixel && this.prevTargetLengthInPixels === targetLengthInPixels) {
                return false;
            }
            this.prevNanometersPerPixel = nanometersPerPixel;
            this.prevTargetLengthInPixels = targetLengthInPixels;
            var targetNanometers = targetLengthInPixels * nanometersPerPixel;
            var exponent = Math.floor(Math.log(targetNanometers) / Math.LN10);
            var tenToThePowerExponent = Math.pow(10, exponent);
            var targetSignificand = targetNanometers / tenToThePowerExponent;
            // Determine significand value in this.allowedSignificands that is closest
            // to targetSignificand.
            var bestSignificand = 1;
            var allowedSignificands = this.allowedSignificands;

            for (var allowedSignificand of this.allowedSignificands) {
                if (Math.abs(allowedSignificand - targetSignificand) < Math.abs(bestSignificand - targetSignificand)) {
                    bestSignificand = allowedSignificand;
                } else {
                    // If distance did not decrease, then it can only increase from here.
                    break;
                }
            }
            var physicalNanometers = bestSignificand * tenToThePowerExponent;
            var numAllowedUnits = ALLOWED_UNITS.length;
            var unit = ALLOWED_UNITS[numAllowedUnits - 1];
            for (var i = 0; i < numAllowedUnits; ++i) {
                var allowedUnit = ALLOWED_UNITS[i];
                if (physicalNanometers >= allowedUnit.lengthInNanometers) {
                    unit = allowedUnit;
                    break;
                }
            }
            this.lengthInPixels = Math.round(physicalNanometers / nanometersPerPixel);
            this.physicalUnit = unit.unit;
            this.physicalLength = physicalNanometers / unit.lengthInNanometers;
            return true;
        }
    }]);

    return ScaleBarDimensions;
}();

exports.ScaleBarDimensions = ScaleBarDimensions;
;

var ScaleBarWidget = function (_disposable_1$RefCoun) {
    _inherits(ScaleBarWidget, _disposable_1$RefCoun);

    function ScaleBarWidget() {
        var dimensions = arguments.length <= 0 || arguments[0] === undefined ? new ScaleBarDimensions() : arguments[0];

        _classCallCheck(this, ScaleBarWidget);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ScaleBarWidget).call(this));

        _this.dimensions = dimensions;
        _this.element = document.createElement('div');
        _this.textNode = document.createTextNode('');
        _this.barElement = document.createElement('div');
        var element = _this.element;
        var textNode = _this.textNode;
        var barElement = _this.barElement;

        element.className = 'scale-bar-container';
        element.appendChild(textNode);
        element.appendChild(barElement);
        barElement.className = 'scale-bar';
        return _this;
    }

    _createClass(ScaleBarWidget, [{
        key: 'update',
        value: function update() {
            var dimensions = this.dimensions;

            if (dimensions.update()) {
                this.textNode.textContent = `${ dimensions.physicalLength } ${ dimensions.physicalUnit }`;
                this.barElement.style.width = `${ dimensions.lengthInPixels }px`;
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            dom_1.removeFromParent(this.element);
        }
    }]);

    return ScaleBarWidget;
}(disposable_1.RefCounted);

exports.ScaleBarWidget = ScaleBarWidget;
;

/***/ },
/* 81 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var factory_1 = __webpack_require__(28);
var base_1 = __webpack_require__(83);
var base_2 = __webpack_require__(61);
var frontend_1 = __webpack_require__(60);
var completion_1 = __webpack_require__(29);
var geom_1 = __webpack_require__(9);
var http_request_1 = __webpack_require__(25);
var json_1 = __webpack_require__(8);
var promise_1 = __webpack_require__(20);
var serverVolumeTypes = new Map();
serverVolumeTypes.set('image', base_2.VolumeType.IMAGE);
serverVolumeTypes.set('annotation', base_2.VolumeType.SEGMENTATION);
var VALID_ENCODINGS = new Set(['npz', 'raw', 'jpeg']);
var VolumeChunkSource = frontend_1.defineParameterizedVolumeChunkSource(base_1.VolumeChunkSourceParameters);
function parseScales(datasetObj) {
    json_1.verifyObject(datasetObj);
    var voxelSizes = json_1.verifyObjectProperty(datasetObj, 'neariso_voxelres', x => json_1.verifyObjectAsMap(x, json_1.verify3dScale));
    var imageSizes = json_1.verifyObjectProperty(datasetObj, 'neariso_imagesize', x => json_1.verifyObjectAsMap(x, json_1.verify3dDimensions));
    var voxelOffsets = json_1.verifyObjectProperty(datasetObj, 'neariso_offset', x => json_1.verifyObjectAsMap(x, json_1.verify3dVec));
    var resolutions = json_1.verifyObjectProperty(datasetObj, 'resolutions', x => json_1.parseArray(x, json_1.verifyInt));
    return resolutions.map(resolution => {
        var key = '' + resolution;
        var voxelSize = voxelSizes.get(key);
        var imageSize = imageSizes.get(key);
        var voxelOffset = voxelOffsets.get(key);
        if (voxelSize === undefined || imageSize === undefined || voxelOffset === undefined) {
            throw new Error(`Missing neariso_voxelres/neariso_imagesize/neariso_offset for resolution ${ resolution }.`);
        }
        return { key, voxelSize, imageSize, voxelOffset };
    });
}
function getVolumeTypeFromChannelType(channelType) {
    var volumeType = serverVolumeTypes.get(channelType);
    if (volumeType === undefined) {
        volumeType = base_2.VolumeType.UNKNOWN;
    }
    return volumeType;
}
function parseChannelInfo(obj) {
    json_1.verifyObject(obj);
    var channelType = json_1.verifyObjectProperty(obj, 'channel_type', json_1.verifyString);
    return {
        channelType,
        description: json_1.verifyObjectProperty(obj, 'description', json_1.verifyString),
        volumeType: getVolumeTypeFromChannelType(channelType),
        dataType: json_1.verifyObjectProperty(obj, 'datatype', x => json_1.verifyEnumString(x, base_2.DataType))
    };
}
function parseTokenInfo(obj) {
    json_1.verifyObject(obj);
    return {
        channels: json_1.verifyObjectProperty(obj, 'channels', x => json_1.verifyObjectAsMap(x, parseChannelInfo)),
        scales: json_1.verifyObjectProperty(obj, 'dataset', parseScales)
    };
}

var MultiscaleVolumeChunkSource = function () {
    function MultiscaleVolumeChunkSource(baseUrls, key, tokenInfo, channel, parameters) {
        _classCallCheck(this, MultiscaleVolumeChunkSource);

        this.baseUrls = baseUrls;
        this.key = key;
        this.tokenInfo = tokenInfo;
        this.parameters = parameters;
        if (channel === undefined) {
            var channelNames = Array.from(tokenInfo.channels.keys());
            if (channelNames.length !== 1) {
                throw new Error(`Dataset contains multiple channels: ${ JSON.stringify(channelNames) }`);
            }
            channel = channelNames[0];
        }
        var channelInfo = tokenInfo.channels.get(channel);
        if (channelInfo === undefined) {
            throw new Error(`Specified channel ${ JSON.stringify(channel) } is not one of the supported channels ${ JSON.stringify(Array.from(tokenInfo.channels.keys())) }`);
        }
        this.channel = channel;
        this.channelInfo = channelInfo;
        this.scales = tokenInfo.scales;
        var encoding = json_1.verifyOptionalString(parameters['encoding']);
        if (encoding === undefined) {
            encoding = this.volumeType === base_2.VolumeType.IMAGE ? 'jpeg' : 'npz';
        } else {
            if (!VALID_ENCODINGS.has(encoding)) {
                throw new Error(`Invalid encoding: ${ JSON.stringify(encoding) }.`);
            }
        }
        this.encoding = encoding;
    }

    _createClass(MultiscaleVolumeChunkSource, [{
        key: 'getSources',
        value: function getSources(chunkManager) {
            return this.scales.map(scaleInfo => {
                var voxelOffset = scaleInfo.voxelOffset;
                var voxelSize = scaleInfo.voxelSize;

                var baseVoxelOffset = geom_1.vec3.create();
                for (var i = 0; i < 3; ++i) {
                    baseVoxelOffset[i] = Math.ceil(voxelOffset[i]);
                }
                return base_2.VolumeChunkSpecification.getDefaults({
                    numChannels: this.numChannels,
                    volumeType: this.volumeType,
                    dataType: this.dataType, voxelSize,
                    chunkLayoutOffset: geom_1.vec3.multiply(geom_1.vec3.create(), voxelOffset, voxelSize),
                    baseVoxelOffset,
                    upperVoxelBound: scaleInfo.imageSize
                }).map(spec => VolumeChunkSource.get(chunkManager, spec, {
                    baseUrls: this.baseUrls,
                    key: this.key,
                    channel: this.channel,
                    resolution: scaleInfo.key,
                    encoding: this.encoding
                }));
            });
        }
        /**
         * Meshes are not supported.
         */

    }, {
        key: 'getMeshSource',
        value: function getMeshSource(chunkManager) {
            return null;
        }
    }, {
        key: 'dataType',
        get: function () {
            return this.channelInfo.dataType;
        }
    }, {
        key: 'numChannels',
        get: function () {
            return 1;
        }
    }, {
        key: 'volumeType',
        get: function () {
            return this.channelInfo.volumeType;
        }
    }]);

    return MultiscaleVolumeChunkSource;
}();

exports.MultiscaleVolumeChunkSource = MultiscaleVolumeChunkSource;
;
var pathPattern = /^([^\/?]+)(?:\/([^\/?]+))?(?:\?(.*))?$/;
var existingTokenResponses = new Map();
function getTokenInfo(hostnames, token) {
    var fullKey = JSON.stringify({ 'hostnames': hostnames, 'token': token });
    var result = existingTokenResponses.get(fullKey);
    if (result !== undefined) {
        return result;
    }
    var promise = http_request_1.sendHttpRequest(http_request_1.openShardedHttpRequest(hostnames, `/ocp/ca/${ token }/info/`), 'json').then(parseTokenInfo);
    existingTokenResponses.set(fullKey, promise);
    return promise;
}
exports.getTokenInfo = getTokenInfo;
var existingVolumes = new Map();
function getShardedVolume(hostnames, path) {
    var match = path.match(pathPattern);
    if (match === null) {
        throw new Error(`Invalid volume path ${ JSON.stringify(path) }`);
    }
    // Warning: If additional arguments are added, fullKey should be updated as well.
    var fullKey = json_1.stableStringify({ 'hostnames': hostnames, 'path': path });
    var existingResult = existingVolumes.get(fullKey);
    if (existingResult !== undefined) {
        return existingResult;
    }
    var key = match[1];
    var channel = match[2];
    var parameters = json_1.parseQueryStringParameters(match[3] || '');
    var promise = getTokenInfo(hostnames, key).then(tokenInfo => new MultiscaleVolumeChunkSource(hostnames, key, tokenInfo, channel, parameters));
    existingVolumes.set(fullKey, promise);
    return promise;
}
exports.getShardedVolume = getShardedVolume;
var urlPattern = /^((?:http|https):\/\/[^\/?]+)\/(.*)$/;
function getVolume(path) {
    var match = path.match(urlPattern);
    if (match === null) {
        throw new Error(`Invalid ndstore volume path: ${ JSON.stringify(path) }`);
    }
    return getShardedVolume([match[1]], match[2]);
}
exports.getVolume = getVolume;
var publicTokenPromises = new Map();
function getPublicTokens(hostnames) {
    var key = JSON.stringify(hostnames);
    var result = publicTokenPromises.get(key);
    if (result !== undefined) {
        return result;
    }
    var newResult = http_request_1.sendHttpRequest(http_request_1.openShardedHttpRequest(hostnames, '/ocp/ca/public_tokens/'), 'json').then(value => json_1.parseArray(value, json_1.verifyString));
    publicTokenPromises.set(key, newResult);
    return newResult;
}
exports.getPublicTokens = getPublicTokens;
function tokenAndChannelCompleter(hostnames, path) {
    var channelMatch = path.match(/^(?:([^\/]+)(?:\/([^\/]*))?)?$/);
    if (channelMatch === null) {
        // URL has incorrect format, don't return any results.
        return Promise.reject(null);
    }
    if (channelMatch[2] === undefined) {
        var _ret = function () {
            var keyPrefix = channelMatch[1] || '';
            // Try to complete the token.
            return {
                v: getPublicTokens(hostnames).then(tokens => {
                    return {
                        offset: 0,
                        completions: completion_1.getPrefixMatchesWithDescriptions(keyPrefix, tokens, x => x + '/', x => undefined)
                    };
                })
            };
        }();

        if (typeof _ret === "object") return _ret.v;
    }
    return promise_1.cancellableThen(getTokenInfo(hostnames, channelMatch[1]), tokenInfo => {
        var completions = completion_1.getPrefixMatchesWithDescriptions(channelMatch[2], tokenInfo.channels, x => x[0], x => {
            return `${ x[1].channelType } (${ base_2.DataType[x[1].dataType] })`;
        });
        return { offset: channelMatch[1].length + 1, completions };
    });
}
exports.tokenAndChannelCompleter = tokenAndChannelCompleter;
function volumeCompleter(url) {
    var match = url.match(urlPattern);
    if (match === null) {
        // We don't yet have a full hostname.
        return Promise.reject(null);
    }
    var hostnames = [match[1]];
    var path = match[2];
    return promise_1.cancellableThen(tokenAndChannelCompleter(hostnames, path), completions => completion_1.applyCompletionOffset(match[1].length + 1, completions));
}
exports.volumeCompleter = volumeCompleter;
factory_1.registerDataSourceFactory('ndstore', {
    description: 'NDstore',
    volumeCompleter: volumeCompleter,
    getVolume: getVolume
});

/***/ },
/* 83 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VolumeChunkSourceParameters = function () {
    function VolumeChunkSourceParameters() {
        _classCallCheck(this, VolumeChunkSourceParameters);
    }

    _createClass(VolumeChunkSourceParameters, null, [{
        key: "stringify",
        value: function stringify(parameters) {
            return `ndstore:volume:${ parameters.baseUrls[0] }/${ parameters.key }/${ parameters.channel }/${ parameters.resolution }/${ parameters.encoding }`;
        }
    }]);

    return VolumeChunkSourceParameters;
}();

VolumeChunkSourceParameters.RPC_ID = 'ndstore/VolumeChunkSource';
exports.VolumeChunkSourceParameters = VolumeChunkSourceParameters;
;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var base_1 = __webpack_require__(85);
var factory_1 = __webpack_require__(28);
var frontend_1 = __webpack_require__(77);
var base_2 = __webpack_require__(61);
var frontend_2 = __webpack_require__(60);
var status_1 = __webpack_require__(4);
var completion_1 = __webpack_require__(29);
var geom_1 = __webpack_require__(9);
var http_request_1 = __webpack_require__(25);
var json_1 = __webpack_require__(8);
var serverDataTypes = new Map();
serverDataTypes.set('uint8', base_2.DataType.UINT8);
serverDataTypes.set('uint32', base_2.DataType.UINT32);
serverDataTypes.set('uint64', base_2.DataType.UINT64);

var DataInstanceBaseInfo = function () {
    function DataInstanceBaseInfo(obj) {
        _classCallCheck(this, DataInstanceBaseInfo);

        this.obj = obj;
        json_1.verifyObject(obj);
        json_1.verifyObjectProperty(obj, 'TypeName', json_1.verifyString);
    }

    _createClass(DataInstanceBaseInfo, [{
        key: 'typeName',
        get: function () {
            return this.obj['TypeName'];
        }
    }]);

    return DataInstanceBaseInfo;
}();

exports.DataInstanceBaseInfo = DataInstanceBaseInfo;
;

var DataInstanceInfo = function DataInstanceInfo(obj, name, base) {
    _classCallCheck(this, DataInstanceInfo);

    this.obj = obj;
    this.name = name;
    this.base = base;
};

exports.DataInstanceInfo = DataInstanceInfo;
;
var DVIDVolumeChunkSource = frontend_2.defineParameterizedVolumeChunkSource(base_1.VolumeChunkSourceParameters);
var SkeletonSource = frontend_1.parameterizedSkeletonSource(base_1.SkeletonSourceParameters);

var VolumeDataInstanceInfo = function (_DataInstanceInfo) {
    _inherits(VolumeDataInstanceInfo, _DataInstanceInfo);

    function VolumeDataInstanceInfo(obj, name, base, volumeType, instanceNames) {
        _classCallCheck(this, VolumeDataInstanceInfo);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(VolumeDataInstanceInfo).call(this, obj, name, base));

        _this.volumeType = volumeType;
        var extended = json_1.verifyObjectProperty(obj, 'Extended', json_1.verifyObject);
        var extendedValues = json_1.verifyObjectProperty(extended, 'Values', x => json_1.parseArray(x, json_1.verifyObject));
        if (extendedValues.length < 1) {
            throw new Error('Expected Extended.Values property to have length >= 1, but received: ${JSON.stringify(extendedValues)}.');
        }
        _this.numLevels = 1;
        // dvid does not have explicit datatype support for multiscale but
        // by convention different levels are specified with unique
        // instances where levels are distinguished by the suffix '_LEVELNUM'
        var instSet = new Set(instanceNames);
        while (instSet.has(name + '_' + _this.numLevels.toString())) {
            _this.numLevels += 1;
        }
        _this.dataType = json_1.verifyObjectProperty(extendedValues[0], 'DataType', x => json_1.verifyMapKey(x, serverDataTypes));
        _this.lowerVoxelBound = json_1.verifyObjectProperty(extended, 'MinPoint', x => json_1.parseIntVec(geom_1.vec3.create(), x));
        _this.upperVoxelBound = json_1.verifyObjectProperty(extended, 'MaxPoint', x => json_1.parseIntVec(geom_1.vec3.create(), x));
        _this.voxelSize = json_1.verifyObjectProperty(extended, 'VoxelSize', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyFinitePositiveFloat));
        _this.numChannels = 1;
        return _this;
    }

    _createClass(VolumeDataInstanceInfo, [{
        key: 'getSources',
        value: function getSources(chunkManager, parameters) {
            var _this2 = this;

            var sources = [];

            var _loop = function (level) {
                var voxelSize = geom_1.vec3.scale(geom_1.vec3.create(), _this2.voxelSize, Math.pow(2, level));
                var lowerVoxelBound = geom_1.vec3.create();
                var upperVoxelBound = geom_1.vec3.create();
                for (var i = 0; i < 3; ++i) {
                    lowerVoxelBound[i] = Math.floor(_this2.lowerVoxelBound[i] * (_this2.voxelSize[i] / voxelSize[i]));
                    upperVoxelBound[i] = Math.ceil(_this2.upperVoxelBound[i] * (_this2.voxelSize[i] / voxelSize[i]));
                }
                var dataInstanceKey = parameters.dataInstanceKey;
                if (level > 0) {
                    dataInstanceKey += '_' + level.toString();
                }
                var volParameters = {
                    'baseUrls': parameters.baseUrls,
                    'nodeKey': parameters.nodeKey,
                    'dataInstanceKey': dataInstanceKey,
                    'volumeType': _this2.volumeType
                };
                var alternatives = base_2.VolumeChunkSpecification.getDefaults({
                    voxelSize: voxelSize,
                    dataType: _this2.dataType,
                    numChannels: _this2.numChannels,
                    chunkLayoutOffset: geom_1.vec3.multiply(geom_1.vec3.create(), lowerVoxelBound, voxelSize),
                    baseVoxelOffset: lowerVoxelBound,
                    upperVoxelBound: geom_1.vec3.subtract(geom_1.vec3.create(), upperVoxelBound, lowerVoxelBound),
                    volumeType: _this2.volumeType
                }).map(spec => {
                    return DVIDVolumeChunkSource.get(chunkManager, spec, volParameters);
                });
                sources.push(alternatives);
            };

            for (var level = 0; level < this.numLevels; ++level) {
                _loop(level);
            }
            return sources;
        }
    }]);

    return VolumeDataInstanceInfo;
}(DataInstanceInfo);

exports.VolumeDataInstanceInfo = VolumeDataInstanceInfo;
;

var TileLevelInfo = function TileLevelInfo(obj) {
    _classCallCheck(this, TileLevelInfo);

    json_1.verifyObject(obj);
    this.resolution = json_1.verifyObjectProperty(obj, 'Resolution', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyFinitePositiveFloat));
    this.tileSize = json_1.verifyObjectProperty(obj, 'TileSize', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyPositiveInt));
};

exports.TileLevelInfo = TileLevelInfo;
;
/**
 * Dimensions for which tiles are computed.
 *
 * DVID does not indicate which dimensions are available but it
 * provides blank tiles if the dimension asked for is not there.
 */
var TILE_DIMS = [[0, 1], [0, 2], [1, 2]];
var TileChunkSource = frontend_2.defineParameterizedVolumeChunkSource(base_1.TileChunkSourceParameters);

var TileDataInstanceInfo = function (_DataInstanceInfo2) {
    _inherits(TileDataInstanceInfo, _DataInstanceInfo2);

    function TileDataInstanceInfo(obj, name, base) {
        _classCallCheck(this, TileDataInstanceInfo);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(TileDataInstanceInfo).call(this, obj, name, base));

        var extended = json_1.verifyObjectProperty(obj, 'Extended', json_1.verifyObject);
        _this3.levels = json_1.verifyObjectProperty(extended, 'Levels', x => json_1.verifyObjectAsMap(x, y => new TileLevelInfo(y)));
        var baseLevel = _this3.levels.get('0');
        if (baseLevel === undefined) {
            throw new Error(`Level 0 is not defined.`);
        }
        _this3.voxelSize = baseLevel.resolution;
        var minTileCoord = json_1.verifyObjectProperty(extended, 'MinTileCoord', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyInt));
        var maxTileCoord = json_1.verifyObjectProperty(extended, 'MaxTileCoord', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyInt));
        _this3.lowerVoxelBound = geom_1.vec3.multiply(geom_1.vec3.create(), baseLevel.tileSize, minTileCoord);
        _this3.upperVoxelBound = geom_1.vec3.multiply(geom_1.vec3.create(), baseLevel.tileSize, maxTileCoord);
        var encodingNumber = json_1.verifyObjectProperty(extended, 'Encoding', x => x);
        switch (encodingNumber) {
            case 2:
                _this3.encoding = base_1.TileEncoding.JPEG;
                break;
            default:
                throw new Error(`Unsupported tile encoding: ${ JSON.stringify(encodingNumber) }.`);
        }
        return _this3;
    }

    _createClass(TileDataInstanceInfo, [{
        key: 'getSources',
        value: function getSources(chunkManager, parameters) {
            var _this4 = this;

            var sources = [];
            var numChannels = this.numChannels;
            var dataType = this.dataType;
            var encoding = this.encoding;

            var _loop2 = function (_ref) {
                _ref2 = _slicedToArray(_ref, 2);
                var level = _ref2[0];
                var levelInfo = _ref2[1];

                var alternatives = TILE_DIMS.map(dims => {
                    var voxelSize = geom_1.vec3.clone(_this4.voxelSize);
                    var chunkDataSize = geom_1.vec3.fromValues(1, 1, 1);
                    // tiles are always NxMx1
                    for (var i = 0; i < 2; ++i) {
                        voxelSize[dims[i]] = levelInfo.resolution[dims[i]];
                        chunkDataSize[dims[i]] = levelInfo.tileSize[dims[i]];
                    }
                    var lowerVoxelBound = geom_1.vec3.create(),
                        upperVoxelBound = geom_1.vec3.create();
                    for (var _i = 0; _i < 3; ++_i) {
                        lowerVoxelBound[_i] = Math.floor(_this4.lowerVoxelBound[_i] * (_this4.voxelSize[_i] / voxelSize[_i]));
                        upperVoxelBound[_i] = Math.ceil(_this4.upperVoxelBound[_i] * (_this4.voxelSize[_i] / voxelSize[_i]));
                    }
                    var spec = new base_2.VolumeChunkSpecification({
                        voxelSize,
                        chunkDataSize,
                        numChannels: numChannels,
                        dataType: dataType, lowerVoxelBound, upperVoxelBound
                    });
                    return TileChunkSource.get(chunkManager, spec, {
                        'baseUrls': parameters.baseUrls,
                        'nodeKey': parameters.nodeKey,
                        'dataInstanceKey': parameters.dataInstanceKey,
                        'encoding': encoding,
                        'level': level,
                        'dims': `${ dims[0] }_${ dims[1] }`
                    });
                });
                sources.push(alternatives);
            };

            for (var _ref of this.levels) {
                var _ref2;

                _loop2(_ref);
            }
            return sources;
        }
    }, {
        key: 'dataType',
        get: function () {
            return base_2.DataType.UINT8;
        }
    }, {
        key: 'volumeType',
        get: function () {
            return base_2.VolumeType.IMAGE;
        }
    }, {
        key: 'numChannels',
        get: function () {
            return 1;
        }
    }]);

    return TileDataInstanceInfo;
}(DataInstanceInfo);

exports.TileDataInstanceInfo = TileDataInstanceInfo;
;
function parseDataInstance(obj, name, instanceNames) {
    json_1.verifyObject(obj);
    var baseInfo = json_1.verifyObjectProperty(obj, 'Base', x => new DataInstanceBaseInfo(x));
    switch (baseInfo.typeName) {
        case 'uint8blk':
        case 'grayscale8':
            return new VolumeDataInstanceInfo(obj, name, baseInfo, base_2.VolumeType.IMAGE, instanceNames);
        case 'imagetile':
            return new TileDataInstanceInfo(obj, name, baseInfo);
        case 'labels64':
        case 'labelblk':
            return new VolumeDataInstanceInfo(obj, name, baseInfo, base_2.VolumeType.SEGMENTATION, instanceNames);
        default:
            throw new Error(`DVID data type ${ JSON.stringify(baseInfo.typeName) } is not supported.`);
    }
}
exports.parseDataInstance = parseDataInstance;

var RepositoryInfo = function RepositoryInfo(obj) {
    _classCallCheck(this, RepositoryInfo);

    this.errors = [];
    this.dataInstances = new Map();
    this.vnodes = new Set();
    if (obj instanceof RepositoryInfo) {
        this.alias = obj.alias;
        this.description = obj.description;
        // just copy references
        this.errors = obj.errors;
        this.dataInstances = obj.dataInstances;
        return;
    }
    json_1.verifyObject(obj);
    this.alias = json_1.verifyObjectProperty(obj, 'Alias', json_1.verifyString);
    this.description = json_1.verifyObjectProperty(obj, 'Description', json_1.verifyString);
    var dataInstanceObjs = json_1.verifyObjectProperty(obj, 'DataInstances', json_1.verifyObject);
    var instanceKeys = Object.keys(dataInstanceObjs);
    for (var key of instanceKeys) {
        try {
            this.dataInstances.set(key, parseDataInstance(dataInstanceObjs[key], key, instanceKeys));
        } catch (parseError) {
            var message = `Failed to parse data instance ${ JSON.stringify(key) }: ${ parseError.message }`;
            console.log(message);
            this.errors.push(message);
        }
    }
    var dagObj = json_1.verifyObjectProperty(obj, 'DAG', json_1.verifyObject);
    var nodeObjs = json_1.verifyObjectProperty(dagObj, 'Nodes', json_1.verifyObject);
    for (var _key of Object.keys(nodeObjs)) {
        this.vnodes.add(_key);
    }
};

exports.RepositoryInfo = RepositoryInfo;
;
function parseRepositoriesInfo(obj) {
    try {
        var result = json_1.verifyObjectAsMap(obj, x => new RepositoryInfo(x));
        // make all versions available for viewing
        var allVersions = new Map();
        for (var _ref5 of result) {
            var _ref4 = _slicedToArray(_ref5, 2);

            var key = _ref4[0];
            var info = _ref4[1];

            allVersions.set(key, info);
            for (var key2 of info.vnodes) {
                if (key2 !== key) {
                    // create new repo
                    var rep = new RepositoryInfo(info);
                    allVersions.set(key2, rep);
                }
            }
        }
        for (var _ref8 of allVersions) {
            var _ref7 = _slicedToArray(_ref8, 2);

            var _key2 = _ref7[0];
            var _info = _ref7[1];

            _info.uuid = _key2;
        }
        return allVersions;
    } catch (parseError) {
        throw new Error(`Failed to parse DVID repositories info: ${ parseError.message }`);
    }
}
exports.parseRepositoriesInfo = parseRepositoriesInfo;

var ServerInfo = function () {
    function ServerInfo(obj) {
        _classCallCheck(this, ServerInfo);

        this.repositories = parseRepositoriesInfo(obj);
    }

    _createClass(ServerInfo, [{
        key: 'getNode',
        value: function getNode(nodeKey) {
            // FIXME: Support non-root nodes.
            var matches = [];
            for (var key of this.repositories.keys()) {
                if (key.startsWith(nodeKey)) {
                    matches.push(key);
                }
            }
            if (matches.length !== 1) {
                throw new Error(`Node key ${ JSON.stringify(nodeKey) } matches ${ JSON.stringify(matches) } nodes.`);
            }
            return this.repositories.get(matches[0]);
        }
    }]);

    return ServerInfo;
}();

exports.ServerInfo = ServerInfo;
;
var cachedServerInfo = new Map();
function getServerInfo(baseUrls) {
    var cacheKey = json_1.stableStringify(baseUrls);
    var result = cachedServerInfo.get(cacheKey);
    if (result === undefined) {
        result = http_request_1.sendHttpRequest(http_request_1.openShardedHttpRequest(baseUrls, '/api/repos/info', 'GET'), 'json').then(response => new ServerInfo(response));
        var description = `repository info for DVID server ${ baseUrls[0] }`;
        status_1.StatusMessage.forPromise(result, {
            initialMessage: `Retrieving ${ description }.`,
            delay: true,
            errorPrefix: `Error retrieving ${ description }: `
        });
        cachedServerInfo.set(cacheKey, result);
    }
    return result;
}
exports.getServerInfo = getServerInfo;

var MultiscaleVolumeChunkSource = function () {
    function MultiscaleVolumeChunkSource(baseUrls, nodeKey, dataInstanceKey, info) {
        _classCallCheck(this, MultiscaleVolumeChunkSource);

        this.baseUrls = baseUrls;
        this.nodeKey = nodeKey;
        this.dataInstanceKey = dataInstanceKey;
        this.info = info;
    }

    _createClass(MultiscaleVolumeChunkSource, [{
        key: 'getSources',
        value: function getSources(chunkManager) {
            return this.info.getSources(chunkManager, {
                'baseUrls': this.baseUrls,
                'nodeKey': this.nodeKey,
                'dataInstanceKey': this.dataInstanceKey
            });
        }
        /**
         * Meshes are not supported.
         */

    }, {
        key: 'getMeshSource',
        value: function getMeshSource(chunkManager) {
            return null;
        }
    }, {
        key: 'dataType',
        get: function () {
            return this.info.dataType;
        }
    }, {
        key: 'numChannels',
        get: function () {
            return this.info.numChannels;
        }
    }, {
        key: 'volumeType',
        get: function () {
            return this.info.volumeType;
        }
    }]);

    return MultiscaleVolumeChunkSource;
}();

exports.MultiscaleVolumeChunkSource = MultiscaleVolumeChunkSource;
;
var existingVolumes = new Map();
function getShardedVolume(baseUrls, nodeKey, dataInstanceKey) {
    return getServerInfo(baseUrls).then(serverInfo => {
        var repositoryInfo = serverInfo.getNode(nodeKey);
        if (repositoryInfo === undefined) {
            throw new Error(`Invalid node: ${ JSON.stringify(nodeKey) }.`);
        }
        var dataInstanceInfo = repositoryInfo.dataInstances.get(dataInstanceKey);
        if (!(dataInstanceInfo instanceof VolumeDataInstanceInfo) && !(dataInstanceInfo instanceof TileDataInstanceInfo)) {
            throw new Error(`Invalid data instance ${ dataInstanceKey }.`);
        }
        var cacheKey = json_1.stableStringify({ 'baseUrls': baseUrls, 'nodeKey': repositoryInfo.uuid, 'dataInstanceKey': dataInstanceKey });
        var result = existingVolumes.get(cacheKey);
        if (result === undefined) {
            result = new MultiscaleVolumeChunkSource(baseUrls, repositoryInfo.uuid, dataInstanceKey, dataInstanceInfo);
            existingVolumes.set(cacheKey, result);
        }
        return result;
    });
}
exports.getShardedVolume = getShardedVolume;
var urlPattern = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/]+)$/;
function getVolume(url) {
    var match = url.match(urlPattern);
    if (match === null) {
        throw new Error(`Invalid DVID URL: ${ JSON.stringify(url) }.`);
    }
    return getShardedVolume([match[1]], match[2], match[3]);
}
exports.getVolume = getVolume;
function completeInstanceName(repositoryInfo, prefix) {
    return {
        offset: 0,
        completions: completion_1.getPrefixMatchesWithDescriptions(prefix, repositoryInfo.dataInstances.values(), instance => instance.name, instance => {
            return `${ instance.base.typeName }`;
        })
    };
}
exports.completeInstanceName = completeInstanceName;
function completeNodeAndInstance(serverInfo, prefix) {
    var match = prefix.match(/^(?:([^\/]+)(?:\/([^\/]*))?)?$/);
    if (match === null) {
        throw new Error(`Invalid DVID URL syntax.`);
    }
    if (match[2] === undefined) {
        // Try to complete the node name.
        return {
            offset: 0,
            completions: completion_1.getPrefixMatchesWithDescriptions(prefix, serverInfo.repositories.values(), repository => repository.uuid + '/', repository => `${ repository.alias }: ${ repository.description }`)
        };
    }
    var nodeKey = match[1];
    var repository = serverInfo.getNode(nodeKey);
    return completion_1.applyCompletionOffset(nodeKey.length + 1, completeInstanceName(repository, match[2]));
}
exports.completeNodeAndInstance = completeNodeAndInstance;
function volumeCompleter(url) {
    var curUrlPattern = /^((?:http|https):\/\/[^\/]+)\/(.*)$/;
    var match = url.match(curUrlPattern);
    if (match === null) {
        // We don't yet have a full hostname.
        return Promise.reject(null);
    }
    var baseUrl = match[1];
    var baseUrls = [baseUrl];
    var path = match[2];
    return getServerInfo(baseUrls).then(serverInfo => completion_1.applyCompletionOffset(baseUrl.length + 1, completeNodeAndInstance(serverInfo, path)));
}
exports.volumeCompleter = volumeCompleter;
factory_1.registerDataSourceFactory('dvid', {
    description: 'DVID',
    volumeCompleter: volumeCompleter,
    getVolume: getVolume,
    getSkeletonSource: getSkeletonSourceByUrl
});
function getSkeletonSource(chunkManager, parameters) {
    return SkeletonSource.get(chunkManager, parameters);
}
exports.getSkeletonSource = getSkeletonSource;
// example: http://emdata1:7000/d5053e99753848e599a641925aa2d38f/bodies1104_skeletons/
var skeletonSourcePattern = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/]+_skeletons)$/;
function getSkeletonSourceParameters(url) {
    var match = url.match(skeletonSourcePattern);
    if (match === null) {
        throw new Error(`Invalid DVID skeleton URL: ${ url }`);
    }
    var baseUrls = [match[1]];
    var nodeKey = match[2];
    var dataInstanceKey = match[3];
    return { baseUrls: baseUrls, nodeKey: nodeKey, dataInstanceKey: dataInstanceKey };
}
function getSkeletonSourceByUrl(chunkManager, url) {
    return getSkeletonSource(chunkManager, getSkeletonSourceParameters(url));
}
exports.getSkeletonSourceByUrl = getSkeletonSourceByUrl;

/***/ },
/* 85 */
/***/ function(module, exports) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DVIDSourceParameters = function DVIDSourceParameters() {
    _classCallCheck(this, DVIDSourceParameters);
};

exports.DVIDSourceParameters = DVIDSourceParameters;

var VolumeChunkSourceParameters = function (_DVIDSourceParameters) {
    _inherits(VolumeChunkSourceParameters, _DVIDSourceParameters);

    function VolumeChunkSourceParameters() {
        _classCallCheck(this, VolumeChunkSourceParameters);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(VolumeChunkSourceParameters).apply(this, arguments));
    }

    _createClass(VolumeChunkSourceParameters, null, [{
        key: 'stringify',
        value: function stringify(parameters) {
            return `dvid:volume:${ parameters['baseUrls'][0] }/${ parameters['nodeKey'] }/${ parameters['dataInstanceKey'] }`;
        }
    }]);

    return VolumeChunkSourceParameters;
}(DVIDSourceParameters);

VolumeChunkSourceParameters.RPC_ID = 'dvid/VolumeChunkSource';
exports.VolumeChunkSourceParameters = VolumeChunkSourceParameters;
;
(function (TileEncoding) {
    TileEncoding[TileEncoding["JPEG"] = 0] = "JPEG";
})(exports.TileEncoding || (exports.TileEncoding = {}));
var TileEncoding = exports.TileEncoding;

var TileChunkSourceParameters = function (_DVIDSourceParameters2) {
    _inherits(TileChunkSourceParameters, _DVIDSourceParameters2);

    function TileChunkSourceParameters() {
        _classCallCheck(this, TileChunkSourceParameters);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TileChunkSourceParameters).apply(this, arguments));
    }

    _createClass(TileChunkSourceParameters, null, [{
        key: 'stringify',
        value: function stringify(parameters) {
            return `dvid:volume:${ parameters['baseUrls'][0] }/${ parameters['nodeKey'] }/${ parameters['dataInstanceKey'] }/${ parameters['dims'] }/${ parameters['level'] }/${ TileEncoding[parameters['encoding']] }`;
        }
    }]);

    return TileChunkSourceParameters;
}(DVIDSourceParameters);

TileChunkSourceParameters.RPC_ID = 'dvid/TileChunkSource';
exports.TileChunkSourceParameters = TileChunkSourceParameters;

var SkeletonSourceParameters = function (_DVIDSourceParameters3) {
    _inherits(SkeletonSourceParameters, _DVIDSourceParameters3);

    function SkeletonSourceParameters() {
        _classCallCheck(this, SkeletonSourceParameters);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SkeletonSourceParameters).apply(this, arguments));
    }

    _createClass(SkeletonSourceParameters, null, [{
        key: 'stringify',
        value: function stringify(parameters) {
            return `dvid:skeleton:${ parameters['baseUrls'][0] }/${ parameters['nodeKey'] }/${ parameters['dataInstanceKey'] }`;
        }
    }]);

    return SkeletonSourceParameters;
}(DVIDSourceParameters);

SkeletonSourceParameters.RPC_ID = 'dvid/SkeletonSource';
exports.SkeletonSourceParameters = SkeletonSourceParameters;
;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Convenience interface for accessing openconnecto.me server.
 */

var factory_1 = __webpack_require__(28);
var frontend_1 = __webpack_require__(82);
var HOSTNAMES = ['http://openconnecto.me', 'http://www.openconnecto.me'];
function getVolume(path) {
    return frontend_1.getShardedVolume(HOSTNAMES, path);
}
exports.getVolume = getVolume;
function volumeCompleter(url) {
    return frontend_1.tokenAndChannelCompleter(HOSTNAMES, url);
}
exports.volumeCompleter = volumeCompleter;
factory_1.registerDataSourceFactory('openconnectome', {
    description: 'NDstore server hosted at openconnecto.me',
    getVolume,
    volumeCompleter
});

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var factory_1 = __webpack_require__(28);
var base_1 = __webpack_require__(88);
var frontend_1 = __webpack_require__(30);
var base_2 = __webpack_require__(61);
var frontend_2 = __webpack_require__(60);
var geom_1 = __webpack_require__(9);
var http_request_1 = __webpack_require__(25);
var json_1 = __webpack_require__(8);
var VolumeChunkSource = frontend_2.defineParameterizedVolumeChunkSource(base_1.VolumeChunkSourceParameters);
var MeshSource = frontend_1.defineParameterizedMeshSource(base_1.MeshSourceParameters);

var ScaleInfo = function ScaleInfo(obj) {
    _classCallCheck(this, ScaleInfo);

    json_1.verifyObject(obj);
    this.resolution = json_1.verifyObjectProperty(obj, 'resolution', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyFinitePositiveFloat));
    this.voxelOffset = json_1.verifyObjectProperty(obj, 'voxel_offset', x => json_1.parseIntVec(geom_1.vec3.create(), x)), this.size = json_1.verifyObjectProperty(obj, 'size', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyPositiveInt));
    this.chunkSizes = json_1.verifyObjectProperty(obj, 'chunk_sizes', x => json_1.parseArray(x, y => json_1.parseFixedLengthArray(geom_1.vec3.create(), y, json_1.verifyPositiveInt)));
    if (this.chunkSizes.length === 0) {
        throw new Error('No chunk sizes specified.');
    }
    var encoding = this.encoding = json_1.verifyObjectProperty(obj, 'encoding', x => json_1.verifyEnumString(x, base_1.VolumeChunkEncoding));
    if (encoding === base_1.VolumeChunkEncoding.COMPRESSED_SEGMENTATION) {
        this.compressedSegmentationBlockSize = json_1.verifyObjectProperty(obj, 'compressed_segmentation_block_size', x => json_1.parseFixedLengthArray(geom_1.vec3.create(), x, json_1.verifyPositiveInt));
    }
    this.key = json_1.verifyObjectProperty(obj, 'key', json_1.verifyString);
};

;

var MultiscaleVolumeChunkSource = function () {
    function MultiscaleVolumeChunkSource(baseUrls, path, obj) {
        _classCallCheck(this, MultiscaleVolumeChunkSource);

        this.baseUrls = baseUrls;
        this.path = path;
        this.obj = obj;
        json_1.verifyObject(obj);
        this.dataType = json_1.verifyObjectProperty(obj, 'data_type', x => json_1.verifyEnumString(x, base_2.DataType));
        this.numChannels = json_1.verifyObjectProperty(obj, 'num_channels', json_1.verifyPositiveInt);
        this.volumeType = json_1.verifyObjectProperty(obj, 'type', x => json_1.verifyEnumString(x, base_2.VolumeType));
        this.mesh = json_1.verifyObjectProperty(obj, 'mesh', json_1.verifyOptionalString);
        this.scales = json_1.verifyObjectProperty(obj, 'scales', x => json_1.parseArray(x, y => new ScaleInfo(y)));
    }

    _createClass(MultiscaleVolumeChunkSource, [{
        key: 'getMeshSource',
        value: function getMeshSource(chunkManager) {
            var mesh = this.mesh;

            if (mesh === undefined) {
                return null;
            }
            return getShardedMeshSource(chunkManager, { baseUrls: this.baseUrls, path: `${ this.path }/${ mesh }`, lod: 0 });
        }
    }, {
        key: 'getSources',
        value: function getSources(chunkManager) {
            return this.scales.map(scaleInfo => {
                return base_2.VolumeChunkSpecification.getDefaults({
                    voxelSize: scaleInfo.resolution,
                    dataType: this.dataType,
                    numChannels: this.numChannels,
                    chunkLayoutOffset: geom_1.vec3.multiply(geom_1.vec3.create(), scaleInfo.resolution, scaleInfo.voxelOffset),
                    upperVoxelBound: scaleInfo.size,
                    volumeType: this.volumeType,
                    chunkDataSizes: scaleInfo.chunkSizes,
                    baseVoxelOffset: scaleInfo.voxelOffset,
                    compressedSegmentationBlockSize: scaleInfo.compressedSegmentationBlockSize
                }).map(spec => VolumeChunkSource.get(chunkManager, spec, {
                    'baseUrls': this.baseUrls,
                    'path': `${ this.path }/${ scaleInfo.key }`,
                    'encoding': scaleInfo.encoding
                }));
            });
        }
    }]);

    return MultiscaleVolumeChunkSource;
}();

exports.MultiscaleVolumeChunkSource = MultiscaleVolumeChunkSource;
;
function getShardedMeshSource(chunkManager, parameters) {
    return MeshSource.get(chunkManager, parameters);
}
exports.getShardedMeshSource = getShardedMeshSource;
function getMeshSource(chunkManager, url, lod) {
    var _http_request_1$parse = http_request_1.parseSpecialUrl(url);

    var _http_request_1$parse2 = _slicedToArray(_http_request_1$parse, 2);

    var baseUrls = _http_request_1$parse2[0];
    var path = _http_request_1$parse2[1];

    return getShardedMeshSource(chunkManager, { baseUrls, path, lod });
}
exports.getMeshSource = getMeshSource;
var existingVolumes = new Map();
function getShardedVolume(baseUrls, path) {
    var fullKey = json_1.stableStringify({ 'baseUrls': baseUrls, 'path': path });
    var existingResult = existingVolumes.get(fullKey);
    if (existingResult !== undefined) {
        return existingResult;
    }
    var promise = http_request_1.sendHttpRequest(http_request_1.openShardedHttpRequest(baseUrls, path + '/info'), 'json').then(response => new MultiscaleVolumeChunkSource(baseUrls, path, response));
    existingVolumes.set(fullKey, promise);
    return promise;
}
exports.getShardedVolume = getShardedVolume;
function getVolume(url) {
    var _http_request_1$parse3 = http_request_1.parseSpecialUrl(url);

    var _http_request_1$parse4 = _slicedToArray(_http_request_1$parse3, 2);

    var baseUrls = _http_request_1$parse4[0];
    var path = _http_request_1$parse4[1];

    return getShardedVolume(baseUrls, path);
}
exports.getVolume = getVolume;
factory_1.registerDataSourceFactory('precomputed', {
    description: 'Precomputed file-backed data source',
    getVolume: getVolume,
    getMeshSource: getMeshSource
});

/***/ },
/* 88 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 0] = "RAW";
    VolumeChunkEncoding[VolumeChunkEncoding["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding[VolumeChunkEncoding["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
})(exports.VolumeChunkEncoding || (exports.VolumeChunkEncoding = {}));
var VolumeChunkEncoding = exports.VolumeChunkEncoding;

var VolumeChunkSourceParameters = function () {
    function VolumeChunkSourceParameters() {
        _classCallCheck(this, VolumeChunkSourceParameters);
    }

    _createClass(VolumeChunkSourceParameters, null, [{
        key: "stringify",
        value: function stringify(parameters) {
            return `precomputed:volume:${ parameters.baseUrls[0] }/${ parameters.path }`;
        }
    }]);

    return VolumeChunkSourceParameters;
}();

VolumeChunkSourceParameters.RPC_ID = 'precomputed/VolumeChunkSource';
exports.VolumeChunkSourceParameters = VolumeChunkSourceParameters;
;

var MeshSourceParameters = function () {
    function MeshSourceParameters() {
        _classCallCheck(this, MeshSourceParameters);
    }

    _createClass(MeshSourceParameters, null, [{
        key: "stringify",
        value: function stringify(parameters) {
            return `precomputed:mesh:${ parameters.baseUrls[0] }/${ parameters.path }/${ parameters.lod }`;
        }
    }]);

    return MeshSourceParameters;
}();

MeshSourceParameters.RPC_ID = 'precomputed/MeshSource';
exports.MeshSourceParameters = MeshSourceParameters;
;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var factory_1 = __webpack_require__(28);
var base_1 = __webpack_require__(90);
var frontend_1 = __webpack_require__(30);
var base_2 = __webpack_require__(61);
var frontend_2 = __webpack_require__(60);
var geom_1 = __webpack_require__(9);
var http_request_1 = __webpack_require__(25);
var json_1 = __webpack_require__(8);
var VolumeChunkSource = frontend_2.defineParameterizedVolumeChunkSource(base_1.VolumeChunkSourceParameters);
var MeshSource = frontend_1.defineParameterizedMeshSource(base_1.MeshSourceParameters);
function parseScaleInfo(obj) {
    json_1.verifyObject(obj);
    return {
        key: json_1.verifyObjectProperty(obj, 'key', json_1.verifyString),
        offset: json_1.verifyObjectProperty(obj, 'offset', json_1.verify3dVec),
        sizeInVoxels: json_1.verifyObjectProperty(obj, 'sizeInVoxels', json_1.verify3dDimensions),
        voxelSize: json_1.verifyObjectProperty(obj, 'voxelSize', json_1.verify3dScale),
        chunkDataSize: json_1.verifyObjectProperty(obj, 'chunkDataSize', x => x === undefined ? undefined : json_1.verify3dDimensions(x))
    };
}

var MultiscaleVolumeChunkSource = function () {
    function MultiscaleVolumeChunkSource(baseUrls, key, response) {
        _classCallCheck(this, MultiscaleVolumeChunkSource);

        this.baseUrls = baseUrls;
        this.key = key;
        this.response = response;
        json_1.verifyObject(response);
        this.dataType = json_1.verifyObjectProperty(response, 'dataType', x => json_1.verifyEnumString(x, base_2.DataType));
        this.volumeType = json_1.verifyObjectProperty(response, 'volumeType', x => json_1.verifyEnumString(x, base_2.VolumeType));
        this.numChannels = json_1.verifyObjectProperty(response, 'numChannels', json_1.verifyPositiveInt);
        this.encoding = json_1.verifyObjectProperty(response, 'encoding', x => json_1.verifyEnumString(x, base_1.VolumeChunkEncoding));
        var maxVoxelsPerChunkLog2 = json_1.verifyObjectProperty(response, 'maxVoxelsPerChunkLog2', x => x === undefined ? base_2.DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 : json_1.verifyPositiveInt(x));
        /**
         * Scales used for arbitrary orientation (should be near isotropic).
         *
         * Exactly one of threeDimensionalScales and twoDimensionalScales should be specified.
         */
        var threeDimensionalScales = json_1.verifyObjectProperty(response, 'threeDimensionalScales', x => x === undefined ? undefined : json_1.parseArray(x, parseScaleInfo));
        /**
         * Separate scales used for XY, XZ, YZ slice views, respectively.  The chunks should be flat or
         * nearly flat in Z, Y, X respectively.  The inner arrays must have length 3.
         */
        var twoDimensionalScales = json_1.verifyObjectProperty(response, 'twoDimensionalScales', x => x === undefined ? undefined : json_1.parseArray(x, y => json_1.parseFixedLengthArray(new Array(3), y, parseScaleInfo)));
        if (twoDimensionalScales === undefined === (threeDimensionalScales === undefined)) {
            throw new Error(`Exactly one of "threeDimensionalScales" and "twoDimensionalScales" must be specified.`);
        }
        if (twoDimensionalScales !== undefined) {
            if (twoDimensionalScales.length === 0) {
                throw new Error(`At least one scale must be specified.`);
            }
            this.scales = twoDimensionalScales.map(levelScales => levelScales.map((scale, index) => {
                var voxelSize = scale.voxelSize;
                var sizeInVoxels = scale.sizeInVoxels;

                var flatDimension = 2 - index;
                var _scale$chunkDataSize = scale.chunkDataSize;
                var chunkDataSize = _scale$chunkDataSize === undefined ? base_2.getTwoDimensionalBlockSize({ voxelSize, upperVoxelBound: sizeInVoxels, flatDimension, maxVoxelsPerChunkLog2 }) : _scale$chunkDataSize;

                return {
                    key: scale.key,
                    offset: scale.offset, sizeInVoxels, voxelSize, chunkDataSize
                };
            }));
            if (!geom_1.vec3.equals(this.scales[0][0].voxelSize, this.scales[0][1].voxelSize) || !geom_1.vec3.equals(this.scales[0][0].voxelSize, this.scales[0][2].voxelSize)) {
                throw new Error(`Lowest scale must have uniform voxel size.`);
            }
        }
        if (threeDimensionalScales !== undefined) {
            if (threeDimensionalScales.length === 0) {
                throw new Error(`At least one scale must be specified.`);
            }
            this.scales = threeDimensionalScales.map(scale => {
                var voxelSize = scale.voxelSize;
                var sizeInVoxels = scale.sizeInVoxels;
                var _scale$chunkDataSize2 = scale.chunkDataSize;
                var chunkDataSize = _scale$chunkDataSize2 === undefined ? base_2.getNearIsotropicBlockSize({ voxelSize, upperVoxelBound: sizeInVoxels, maxVoxelsPerChunkLog2 }) : _scale$chunkDataSize2;

                return [{ key: scale.key, offset: scale.offset, sizeInVoxels, voxelSize, chunkDataSize }];
            });
        }
    }

    _createClass(MultiscaleVolumeChunkSource, [{
        key: 'getSources',
        value: function getSources(chunkManager) {
            var numChannels = this.numChannels;
            var dataType = this.dataType;
            var volumeType = this.volumeType;
            var encoding = this.encoding;
            // Clip based on the bounds of the first scale.

            var baseScale = this.scales[0][0];
            var upperClipBound = geom_1.vec3.multiply(geom_1.vec3.create(), baseScale.voxelSize, baseScale.sizeInVoxels);
            return this.scales.map(levelScales => levelScales.map(scaleInfo => {
                var spec = base_2.VolumeChunkSpecification.withDefaultCompression({
                    voxelSize: scaleInfo.voxelSize,
                    dataType,
                    volumeType,
                    numChannels,
                    chunkLayoutOffset: scaleInfo.offset,
                    upperVoxelBound: scaleInfo.sizeInVoxels,
                    upperClipBound: upperClipBound,
                    chunkDataSize: scaleInfo.chunkDataSize
                });
                return VolumeChunkSource.get(chunkManager, spec, { baseUrls: this.baseUrls, key: scaleInfo.key, encoding: encoding });
            }));
        }
    }, {
        key: 'getMeshSource',
        value: function getMeshSource(chunkManager) {
            return MeshSource.get(chunkManager, {
                baseUrls: this.baseUrls,
                key: this.key
            });
        }
    }]);

    return MultiscaleVolumeChunkSource;
}();

exports.MultiscaleVolumeChunkSource = MultiscaleVolumeChunkSource;
;
var existingVolumes = new Map();
function getShardedVolume(baseUrls, key) {
    var cacheKey = json_1.stableStringify({ 'baseUrls': baseUrls, 'key': key });
    var existingResult = existingVolumes.get(key);
    if (existingResult !== undefined) {
        return existingResult;
    }
    var promise = http_request_1.sendHttpRequest(http_request_1.openShardedHttpRequest(baseUrls, `/neuroglancer/info/${ key }`), 'json').then(response => new MultiscaleVolumeChunkSource(baseUrls, key, response));
    existingVolumes.set(cacheKey, promise);
    return promise;
}
exports.getShardedVolume = getShardedVolume;
var urlPattern = /^((?:http|https):\/\/[^\/?]+)\/(.*)$/;
function getVolume(path) {
    var match = path.match(urlPattern);
    if (match === null) {
        throw new Error(`Invalid python volume path: ${ JSON.stringify(path) }`);
    }
    return getShardedVolume([match[1]], match[2]);
}
exports.getVolume = getVolume;
factory_1.registerDataSourceFactory('python', {
    description: 'Python-served volume',
    getVolume: getVolume
});

/***/ },
/* 90 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["JPEG"] = 0] = "JPEG";
    VolumeChunkEncoding[VolumeChunkEncoding["NPZ"] = 1] = "NPZ";
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 2] = "RAW";
})(exports.VolumeChunkEncoding || (exports.VolumeChunkEncoding = {}));
var VolumeChunkEncoding = exports.VolumeChunkEncoding;

var VolumeChunkSourceParameters = function () {
    function VolumeChunkSourceParameters() {
        _classCallCheck(this, VolumeChunkSourceParameters);
    }

    _createClass(VolumeChunkSourceParameters, null, [{
        key: "stringify",
        value: function stringify(parameters) {
            return `python:volume:${ parameters['baseUrls'][0] }/${ parameters['key'] }/${ VolumeChunkEncoding[parameters['encoding']] }`;
        }
    }]);

    return VolumeChunkSourceParameters;
}();

VolumeChunkSourceParameters.RPC_ID = 'python/VolumeChunkSource';
exports.VolumeChunkSourceParameters = VolumeChunkSourceParameters;
;

var MeshSourceParameters = function () {
    function MeshSourceParameters() {
        _classCallCheck(this, MeshSourceParameters);
    }

    _createClass(MeshSourceParameters, null, [{
        key: "stringify",
        value: function stringify(parameters) {
            return `python:mesh:${ parameters['baseUrls'][0] }/${ parameters['key'] }`;
        }
    }]);

    return MeshSourceParameters;
}();

MeshSourceParameters.RPC_ID = 'python/MeshSource';
exports.MeshSourceParameters = MeshSourceParameters;
;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var default_key_bindings_1 = __webpack_require__(92);
var default_viewer_1 = __webpack_require__(93);
window.addEventListener('DOMContentLoaded', () => {
  var viewer = window['viewer'] = default_viewer_1.makeDefaultViewer();
  default_key_bindings_1.makeDefaultKeyBindings(viewer.keyMap);
});

/***/ },
/* 92 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * This binds the default set of viewer key bindings.
 */

function makeDefaultKeyBindings(keyMap) {
    keyMap.bind('arrowleft', 'x-');
    keyMap.bind('arrowright', 'x+');
    keyMap.bind('arrowup', 'y-');
    keyMap.bind('arrowdown', 'y+');
    keyMap.bind('comma', 'z-');
    keyMap.bind('period', 'z+');
    keyMap.bind('keyz', 'snap');
    keyMap.bind('control+equal', 'zoom-in');
    keyMap.bind('control+shift+equal', 'zoom-in');
    keyMap.bind('control+minus', 'zoom-out');
    keyMap.bind('keyr', 'rotate-relative-z-');
    keyMap.bind('keye', 'rotate-relative-z+');
    keyMap.bind('shift+arrowdown', 'rotate-relative-x-');
    keyMap.bind('shift+arrowup', 'rotate-relative-x+');
    keyMap.bind('shift+arrowleft', 'rotate-relative-y-');
    keyMap.bind('shift+arrowright', 'rotate-relative-y+');
    keyMap.bind('keyl', 'recolor');
    keyMap.bind('keyx', 'clear-segments');
    keyMap.bind('keys', 'toggle-show-slices');
    keyMap.bind('keyb', 'toggle-scale-bar');
    keyMap.bind('keya', 'toggle-axis-lines');
    for (var i = 1; i <= 9; ++i) {
        keyMap.bind('digit' + i, 'toggle-layer-' + i);
    }
    keyMap.bind('keyn', 'add-layer');
    keyMap.bind('keyh', 'help');
    keyMap.bind('space', 'toggle-layout');
}
exports.makeDefaultKeyBindings = makeDefaultKeyBindings;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

__webpack_require__(94);
__webpack_require__(95);
var display_context_1 = __webpack_require__(56);
var viewer_1 = __webpack_require__(103);
function makeDefaultViewer() {
  var display = new display_context_1.DisplayContext(document.getElementById('container'));
  return new viewer_1.Viewer(display);
}
exports.makeDefaultViewer = makeDefaultViewer;

/***/ },
/* 94 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

__webpack_require__(96);
__webpack_require__(99);

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var base_1 = __webpack_require__(61);
var frontend_1 = __webpack_require__(60);
var single_texture_chunk_format_1 = __webpack_require__(97);
var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var uint64_1 = __webpack_require__(52);
var one_dimensional_texture_access_1 = __webpack_require__(98);
var shader_lib_1 = __webpack_require__(72);

var TextureLayout = function (_disposable_1$RefCoun) {
    _inherits(TextureLayout, _disposable_1$RefCoun);

    function TextureLayout(gl, chunkDataSize, texelsPerElement, numChannels) {
        _classCallCheck(this, TextureLayout);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextureLayout).call(this));

        _this.chunkDataSize = chunkDataSize;
        var dataPointsPerChannel = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2];
        _this.channelStride = dataPointsPerChannel;
        one_dimensional_texture_access_1.compute3dTextureLayout(_this, gl, texelsPerElement, chunkDataSize[0], chunkDataSize[1], chunkDataSize[2] * numChannels);
        return _this;
    }

    _createClass(TextureLayout, null, [{
        key: 'get',
        value: function get(gl, chunkDataSize, texelsPerElement, numChannels) {
            return gl.memoize.get(`sliceview.UncompressedTextureLayout:${ geom_1.vec3Key(chunkDataSize) },${ texelsPerElement },${ numChannels }`, () => new TextureLayout(gl, chunkDataSize, texelsPerElement, numChannels));
        }
    }]);

    return TextureLayout;
}(disposable_1.RefCounted);

;

var ChunkFormat = function (_single_texture_chunk) {
    _inherits(ChunkFormat, _single_texture_chunk);

    function ChunkFormat(gl, dataType, numChannels, key) {
        _classCallCheck(this, ChunkFormat);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ChunkFormat).call(this, key));

        _this2.dataType = dataType;
        _this2.numChannels = numChannels;
        switch (dataType) {
            case base_1.DataType.UINT8:
                _this2.texelsPerElement = 1;
                _this2.textureFormat = gl.LUMINANCE;
                _this2.texelType = gl.UNSIGNED_BYTE;
                _this2.arrayElementsPerTexel = 1;
                _this2.arrayConstructor = Uint8Array;
                break;
            case base_1.DataType.UINT16:
                _this2.texelsPerElement = 1;
                _this2.textureFormat = gl.LUMINANCE_ALPHA;
                _this2.texelType = gl.UNSIGNED_BYTE;
                _this2.arrayElementsPerTexel = 2;
                _this2.arrayConstructor = Uint8Array;
                break;
            case base_1.DataType.UINT64:
                _this2.texelsPerElement = 2;
                _this2.textureFormat = gl.RGBA;
                _this2.texelType = gl.UNSIGNED_BYTE;
                _this2.arrayElementsPerTexel = 4;
                _this2.arrayConstructor = Uint8Array;
                break;
            case base_1.DataType.UINT32:
                _this2.texelsPerElement = 1;
                _this2.textureFormat = gl.RGBA;
                _this2.texelType = gl.UNSIGNED_BYTE;
                _this2.arrayElementsPerTexel = 4;
                _this2.arrayConstructor = Uint8Array;
                break;
            case base_1.DataType.FLOAT32:
                _this2.texelsPerElement = 1;
                _this2.textureFormat = gl.LUMINANCE;
                _this2.texelType = gl.FLOAT;
                _this2.arrayElementsPerTexel = 1;
                _this2.arrayConstructor = Float32Array;
                break;
            default:
                throw new Error('Unsupported dataType: ' + dataType);
        }
        _this2.textureAccessHelper = new one_dimensional_texture_access_1.OneDimensionalTextureAccessHelper('chunkData', _this2.texelsPerElement);
        return _this2;
    }

    _createClass(ChunkFormat, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            _get(Object.getPrototypeOf(ChunkFormat.prototype), 'defineShader', this).call(this, builder);
            this.textureAccessHelper.defineShader(builder);
            var numChannels = this.numChannels;

            if (numChannels > 1) {
                builder.addUniform('highp float', 'uChannelStride');
                builder.addFragmentCode(`
float getChannelOffset(int channelIndex) {
  return float(channelIndex) * uChannelStride;
}
`);
            } else {
                builder.addFragmentCode(`float getChannelOffset(int channelIndex) { return 0.0; }`);
            }
            builder.addFragmentCode(`
float getIndexIntoChunk (int channelIndex) {
  vec3 chunkDataPosition = getPositionWithinChunk();
  return chunkDataPosition.x + uChunkDataSize.x * (chunkDataPosition.y + uChunkDataSize.y * chunkDataPosition.z) + getChannelOffset(channelIndex);
}
`);
            switch (this.dataType) {
                case base_1.DataType.UINT8:
                    builder.addFragmentCode(shader_lib_1.glsl_uint8);
                    builder.addFragmentCode(`
uint8_t getDataValue (int channelIndex) {
  uint8_t result;
  vec4 temp;
  ${ this.textureAccessHelper.readTextureValue }(uVolumeChunkSampler, getIndexIntoChunk(channelIndex), temp);
  result.value = temp.x;
  return result;
}
`);
                    break;
                case base_1.DataType.FLOAT32:
                    builder.addFragmentCode(shader_lib_1.glsl_float);
                    builder.addFragmentCode(`
float getDataValue (int channelIndex) {
  vec4 temp;
  ${ this.textureAccessHelper.readTextureValue }(uVolumeChunkSampler, getIndexIntoChunk(channelIndex), temp);
  return temp.x;
}
`);
                    break;
                case base_1.DataType.UINT16:
                    builder.addFragmentCode(shader_lib_1.glsl_uint16);
                    builder.addFragmentCode(`
uint16_t getDataValue (int channelIndex) {
  uint16_t result;
  vec4 temp;
  ${ this.textureAccessHelper.readTextureValue }(uVolumeChunkSampler, getIndexIntoChunk(channelIndex), temp);
  result.value = temp.xw;
  return result;
}
`);
                    break;
                case base_1.DataType.UINT32:
                    builder.addFragmentCode(shader_lib_1.glsl_uint32);
                    builder.addFragmentCode(`
uint32_t getDataValue (int channelIndex) {
  uint32_t result;
  ${ this.textureAccessHelper.readTextureValue }(uVolumeChunkSampler, getIndexIntoChunk(channelIndex), result.value);
  return result;
}
`);
                    break;
                case base_1.DataType.UINT64:
                    builder.addFragmentCode(shader_lib_1.glsl_uint64);
                    builder.addFragmentCode(`
uint64_t getDataValue (int channelIndex) {
  uint64_t result;
  ${ this.textureAccessHelper.readTextureValue }(uVolumeChunkSampler, getIndexIntoChunk(channelIndex), result.low, result.high);
  return result;
}
`);
                    break;
            }
        }
        /**
         * Called each time textureLayout changes while drawing chunks.
         */

    }, {
        key: 'setupTextureLayout',
        value: function setupTextureLayout(gl, shader, textureLayout) {
            if (this.numChannels > 1) {
                gl.uniform1f(shader.uniform('uChannelStride'), textureLayout.channelStride);
            }
            this.textureAccessHelper.setupTextureLayout(gl, shader, textureLayout);
        }
    }, {
        key: 'getTextureLayout',
        value: function getTextureLayout(gl, chunkDataSize) {
            return TextureLayout.get(gl, chunkDataSize, this.texelsPerElement, this.numChannels);
        }
    }, {
        key: 'setTextureData',
        value: function setTextureData(gl, textureLayout, data) {
            one_dimensional_texture_access_1.setOneDimensionalTextureData(gl, textureLayout, data, this.arrayElementsPerTexel, this.textureFormat, this.texelType, this.arrayConstructor);
        }
    }], [{
        key: 'get',
        value: function get(gl, dataType, numChannels) {
            var key = `sliceview.UncompressedChunkFormat:${ dataType }:${ numChannels }`;
            return gl.memoize.get(key, () => new ChunkFormat(gl, dataType, numChannels, key));
        }
    }]);

    return ChunkFormat;
}(single_texture_chunk_format_1.SingleTextureChunkFormat);

exports.ChunkFormat = ChunkFormat;
;

var UncompressedVolumeChunk = function (_single_texture_chunk2) {
    _inherits(UncompressedVolumeChunk, _single_texture_chunk2);

    function UncompressedVolumeChunk() {
        _classCallCheck(this, UncompressedVolumeChunk);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(UncompressedVolumeChunk).apply(this, arguments));
    }

    _createClass(UncompressedVolumeChunk, [{
        key: 'setTextureData',
        value: function setTextureData(gl) {
            var source = this.source;
            var chunkFormatHandler = source.chunkFormatHandler;
            var chunkFormat = chunkFormatHandler.chunkFormat;

            var textureLayout = void 0;
            if (this.chunkDataSize === source.spec.chunkDataSize) {
                this.textureLayout = textureLayout = chunkFormatHandler.textureLayout.addRef();
            } else {
                this.textureLayout = textureLayout = chunkFormat.getTextureLayout(gl, this.chunkDataSize);
            }
            this.chunkFormat.setTextureData(gl, textureLayout, this.data);
        }
    }, {
        key: 'getChannelValueAt',
        value: function getChannelValueAt(dataPosition, channel) {
            var chunkFormat = this.chunkFormat;

            var chunkDataSize = this.chunkDataSize;
            var index = dataPosition[0] + chunkDataSize[0] * (dataPosition[1] + chunkDataSize[1] * (dataPosition[2] + chunkDataSize[2] * channel));
            var dataType = chunkFormat.dataType;
            var data = this.data;
            switch (dataType) {
                case base_1.DataType.UINT8:
                case base_1.DataType.FLOAT32:
                case base_1.DataType.UINT16:
                case base_1.DataType.UINT32:
                    return data[index];
                case base_1.DataType.UINT64:
                    {
                        var index2 = index * 2;
                        return new uint64_1.Uint64(data[index2], data[index2 + 1]);
                    }
            }
            throw new Error('Invalid data type: ' + dataType);
        }
    }]);

    return UncompressedVolumeChunk;
}(single_texture_chunk_format_1.SingleTextureVolumeChunk);

exports.UncompressedVolumeChunk = UncompressedVolumeChunk;
;

var UncompressedChunkFormatHandler = function (_disposable_1$RefCoun2) {
    _inherits(UncompressedChunkFormatHandler, _disposable_1$RefCoun2);

    function UncompressedChunkFormatHandler(gl, spec) {
        _classCallCheck(this, UncompressedChunkFormatHandler);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(UncompressedChunkFormatHandler).call(this));

        _this4.chunkFormat = _this4.registerDisposer(ChunkFormat.get(gl, spec.dataType, spec.numChannels));
        _this4.textureLayout = _this4.registerDisposer(_this4.chunkFormat.getTextureLayout(gl, spec.chunkDataSize));
        return _this4;
    }

    _createClass(UncompressedChunkFormatHandler, [{
        key: 'getChunk',
        value: function getChunk(source, x) {
            return new UncompressedVolumeChunk(source, x);
        }
    }]);

    return UncompressedChunkFormatHandler;
}(disposable_1.RefCounted);

exports.UncompressedChunkFormatHandler = UncompressedChunkFormatHandler;
;
frontend_1.registerChunkFormatHandler((gl, spec) => {
    if (spec.compressedSegmentationBlockSize == null) {
        return new UncompressedChunkFormatHandler(gl, spec);
    }
    return null;
});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var frontend_1 = __webpack_require__(60);
var disposable_1 = __webpack_require__(23);
var texture_1 = __webpack_require__(69);
var textureUnitSymbol = Symbol('SingleTextureVolumeChunk.textureUnit');
var textureLayoutSymbol = Symbol('SingleTextureVolumeChunk.textureLayout');

var SingleTextureChunkFormat = function (_disposable_1$RefCoun) {
    _inherits(SingleTextureChunkFormat, _disposable_1$RefCoun);

    function SingleTextureChunkFormat(shaderKey) {
        _classCallCheck(this, SingleTextureChunkFormat);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SingleTextureChunkFormat).call(this));

        _this.shaderKey = shaderKey;
        return _this;
    }

    _createClass(SingleTextureChunkFormat, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            builder.addTextureSampler2D('uVolumeChunkSampler', textureUnitSymbol);
        }
    }, {
        key: 'beginDrawing',
        value: function beginDrawing(gl, shader) {
            var textureUnit = shader.textureUnit(textureUnitSymbol);
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            shader[textureLayoutSymbol] = null;
        }
    }, {
        key: 'endDrawing',
        value: function endDrawing(gl, shader) {
            gl.bindTexture(gl.TEXTURE_2D, null);
            shader[textureLayoutSymbol] = null;
        }
    }, {
        key: 'bindChunk',
        value: function bindChunk(gl, shader, chunk) {
            var textureLayout = chunk.textureLayout;
            var existingTextureLayout = shader[textureLayoutSymbol];
            if (existingTextureLayout !== textureLayout) {
                shader[textureLayoutSymbol] = textureLayout;
                this.setupTextureLayout(gl, shader, textureLayout);
            }
            gl.bindTexture(gl.TEXTURE_2D, chunk.texture);
        }
        /**
         * Does nothing, but may be overridden by subclass.
         */

    }, {
        key: 'beginSource',
        value: function beginSource(gl, shader) {}
    }]);

    return SingleTextureChunkFormat;
}(disposable_1.RefCounted);

exports.SingleTextureChunkFormat = SingleTextureChunkFormat;
;

var SingleTextureVolumeChunk = function (_frontend_1$VolumeChu) {
    _inherits(SingleTextureVolumeChunk, _frontend_1$VolumeChu);

    function SingleTextureVolumeChunk(source, x) {
        _classCallCheck(this, SingleTextureVolumeChunk);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SingleTextureVolumeChunk).call(this, source, x));

        _this2.texture = null;
        _this2.data = x['data'];
        return _this2;
    }

    _createClass(SingleTextureVolumeChunk, [{
        key: 'copyToGPU',
        value: function copyToGPU(gl) {
            _get(Object.getPrototypeOf(SingleTextureVolumeChunk.prototype), 'copyToGPU', this).call(this, gl);
            var texture = this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            texture_1.setRawTextureParameters(gl);
            this.setTextureData(gl);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }, {
        key: 'freeGPUMemory',
        value: function freeGPUMemory(gl) {
            _get(Object.getPrototypeOf(SingleTextureVolumeChunk.prototype), 'freeGPUMemory', this).call(this, gl);
            gl.deleteTexture(this.texture);
            this.texture = null;
            this.textureLayout.dispose();
            this.textureLayout = null;
        }
    }]);

    return SingleTextureVolumeChunk;
}(frontend_1.VolumeChunk);

exports.SingleTextureVolumeChunk = SingleTextureVolumeChunk;
;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * @file
 * Facilities for treating a 2-D WebGL texture as a 1-D array.
 *
 * WebGL 1.0 only supports 2-D textures, and because implementations typically limit the size of
 * each dimension, a large 1-D array has to be fit to a rectangular 2-D texture, which may require
 * padding.
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array_1 = __webpack_require__(63);
/**
 * Computes a texture layout with [width, height] equal to [x, y*z] or [x*y, z] if possible.  This
 * makes 3-d access more likely to be friendly to the texture cache.  If not possible, just uses
 * an arbitrary layout.
 */
function compute3dTextureLayout(layout, gl, texelsPerElement, x, y, z) {
    var maxTextureSize = gl.maxTextureSize;

    var dataWidth = void 0;
    var numElements = x * y * z;
    if (texelsPerElement * x <= maxTextureSize && y * z <= maxTextureSize) {
        // [X, YZ]
        dataWidth = x;
    } else if (texelsPerElement * x * y <= maxTextureSize && z <= maxTextureSize) {
        // [XY, Z]
        dataWidth = x * y;
    } else {
        // Use arbitrary layout.
        dataWidth = Math.ceil(numElements / maxTextureSize);
        if (dataWidth * texelsPerElement > maxTextureSize) {
            throw new Error('Chunk data size exceeds maximum texture size: ' + texelsPerElement + ' * ' + numElements);
        }
    }
    var dataHeight = Math.ceil(numElements / dataWidth);
    layout.textureWidth = dataWidth * texelsPerElement;
    layout.textureHeight = dataHeight;
    layout.textureAccessCoefficients = Float32Array.of(1.0 / dataWidth, 1.0 / (dataWidth * dataHeight));
}
exports.compute3dTextureLayout = compute3dTextureLayout;
function compute1dTextureLayout(layout, gl, texelsPerElement, numElements) {
    var maxTextureSize = gl.maxTextureSize;

    var dataWidth = Math.ceil(numElements / maxTextureSize);
    if (dataWidth * texelsPerElement > maxTextureSize) {
        throw new Error('Number of elements exceeds maximum texture size: ' + texelsPerElement + ' * ' + numElements);
    }
    var dataHeight = Math.ceil(numElements / dataWidth);
    layout.textureWidth = dataWidth * texelsPerElement;
    layout.textureHeight = dataHeight;
    layout.textureAccessCoefficients = Float32Array.of(1.0 / dataWidth, 1.0 / (dataWidth * dataHeight));
}
exports.compute1dTextureLayout = compute1dTextureLayout;
function setOneDimensionalTextureData(gl, textureLayout, data, arrayElementsPerTexel, textureFormat, texelType, arrayConstructor) {
    var requiredSize = textureLayout.textureWidth * textureLayout.textureHeight * arrayElementsPerTexel;
    if (data.constructor !== arrayConstructor) {
        data = new arrayConstructor(data.buffer, data.byteOffset, data.byteLength / arrayConstructor.BYTES_PER_ELEMENT);
    }
    var padded = array_1.maybePadArray(data, requiredSize);
    gl.texImage2D(gl.TEXTURE_2D,
    /*level=*/0, textureFormat,
    /*width=*/textureLayout.textureWidth,
    /*height=*/textureLayout.textureHeight,
    /*border=*/0, textureFormat, texelType, padded);
}
exports.setOneDimensionalTextureData = setOneDimensionalTextureData;

var OneDimensionalTextureAccessHelper = function () {
    function OneDimensionalTextureAccessHelper(key, texelsPerElement) {
        _classCallCheck(this, OneDimensionalTextureAccessHelper);

        this.key = key;
        this.texelsPerElement = texelsPerElement;
        this.uniformName = `uTextureAccessCoefficients_${ this.key }`;
        this.readTextureValue = `readTextureValue_${ this.key }`;
    }

    _createClass(OneDimensionalTextureAccessHelper, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            var texelsPerElement = this.texelsPerElement;
            var uniformName = this.uniformName;

            builder.addUniform('highp vec2', uniformName);
            var fragmentCode = `
void ${ this.readTextureValue }(highp sampler2D sampler, float index`;
            for (var i = 0; i < texelsPerElement; ++i) {
                fragmentCode += `, out vec4 output${ i }`;
            }
            fragmentCode += `) {
  index += ${ 0.5 / this.texelsPerElement };
  vec2 texCoords = vec2(fract(index * ${ uniformName }.x),
                        index * ${ uniformName }.y);
`;
            for (var _i = 0; _i < texelsPerElement; ++_i) {
                fragmentCode += `
  output${ _i } = texture2D(sampler, vec2(texCoords.x + ${ uniformName }.x * ${ (_i / texelsPerElement).toFixed(8) }, texCoords.y));
`;
            }
            fragmentCode += `
}
`;
            builder.addFragmentCode(fragmentCode);
        }
    }, {
        key: 'setupTextureLayout',
        value: function setupTextureLayout(gl, shader, textureLayout) {
            gl.uniform2fv(shader.uniform(this.uniformName), textureLayout.textureAccessCoefficients);
        }
    }]);

    return OneDimensionalTextureAccessHelper;
}();

exports.OneDimensionalTextureAccessHelper = OneDimensionalTextureAccessHelper;
;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var base_1 = __webpack_require__(61);
var decode_uint32_1 = __webpack_require__(100);
var decode_uint64_1 = __webpack_require__(102);
var frontend_1 = __webpack_require__(60);
var renderlayer_1 = __webpack_require__(66);
var single_texture_chunk_format_1 = __webpack_require__(97);
var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var uint64_1 = __webpack_require__(52);
var one_dimensional_texture_access_1 = __webpack_require__(98);
var shader_lib_1 = __webpack_require__(72);

var TextureLayout = function (_disposable_1$RefCoun) {
    _inherits(TextureLayout, _disposable_1$RefCoun);

    function TextureLayout(gl, chunkDataSize, subchunkSize, dataLength) {
        _classCallCheck(this, TextureLayout);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextureLayout).call(this));

        _this.chunkDataSize = chunkDataSize;
        _this.subchunkSize = subchunkSize;
        one_dimensional_texture_access_1.compute1dTextureLayout(_this, gl, /*texelsPerElement=*/1, dataLength);
        var subchunkGridSize = _this.subchunkGridSize = geom_1.vec3.create();
        for (var i = 0; i < 3; ++i) {
            subchunkGridSize[i] = Math.ceil(chunkDataSize[i] / subchunkSize[i]);
        }
        return _this;
    }

    _createClass(TextureLayout, null, [{
        key: 'get',
        value: function get(gl, chunkDataSize, subchunkSize, dataLength) {
            return gl.memoize.get(`sliceview.CompressedSegmentationTextureLayout:${ geom_1.vec3Key(chunkDataSize) },${ geom_1.vec3Key(subchunkSize) },${ dataLength }`, () => new TextureLayout(gl, chunkDataSize, subchunkSize, dataLength));
        }
    }]);

    return TextureLayout;
}(disposable_1.RefCounted);

;

var ChunkFormat = function (_single_texture_chunk) {
    _inherits(ChunkFormat, _single_texture_chunk);

    function ChunkFormat(dataType, subchunkSize, numChannels, key) {
        _classCallCheck(this, ChunkFormat);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ChunkFormat).call(this, key));

        _this2.dataType = dataType;
        _this2.subchunkSize = subchunkSize;
        _this2.numChannels = numChannels;
        _this2.textureAccessHelper = new one_dimensional_texture_access_1.OneDimensionalTextureAccessHelper('chunkData', /*texelsPerElement=*/1);
        return _this2;
    }

    _createClass(ChunkFormat, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            _get(Object.getPrototypeOf(ChunkFormat.prototype), 'defineShader', this).call(this, builder);
            this.textureAccessHelper.defineShader(builder);
            var local = x => 'compressedSegmentationChunkFormat_' + x;
            builder.addUniform('highp vec3', 'uSubchunkGridSize');
            builder.addUniform('highp vec3', 'uSubchunkSize');
            builder.addFragmentCode(shader_lib_1.glsl_getFortranOrderIndexFromNormalized);
            var dataType = this.dataType;

            var glslType = renderlayer_1.GLSL_TYPE_FOR_DATA_TYPE.get(dataType);
            if (dataType === base_1.DataType.UINT64) {
                builder.addFragmentCode(shader_lib_1.glsl_uint64);
            } else {
                builder.addFragmentCode(shader_lib_1.glsl_uint32);
            }
            var fragmentCode = `
vec4 ${ local('readTextureValue') }(float offset) {
  vec4 result;
  ${ this.textureAccessHelper.readTextureValue }(uVolumeChunkSampler, offset, result);
  return result;
}
float ${ local('getChannelOffset') }(int channelIndex) {
  if (channelIndex == 0) {
    return ${ this.numChannels }.0;
  }
  vec4 v = ${ local('readTextureValue') }(float(channelIndex));
  return v.x * 255.0 + v.y * 255.0 * 256.0 + v.z * 255.0 * 256.0 * 256.0;
}
${ glslType } getDataValue (int channelIndex) {
  vec3 chunkPosition = getPositionWithinChunk();

  // TODO: maybe premultiply this and store as uniform.
  vec3 subchunkGridPosition = floor(chunkPosition / uSubchunkSize);
  float subchunkGridOffset = getFortranOrderIndex(subchunkGridPosition, uSubchunkGridSize);

  float channelOffset = ${ local('getChannelOffset') }(channelIndex);

  // TODO: Maybe just combine this offset into subchunkGridStrides.
  float subchunkHeaderOffset = subchunkGridOffset * 2.0 + channelOffset;

  vec4 subchunkHeader0 = ${ local('readTextureValue') }(subchunkHeaderOffset);
  vec4 subchunkHeader1 = ${ local('readTextureValue') }(subchunkHeaderOffset + 1.0);

  float outputValueOffset = dot(subchunkHeader0.xyz, vec3(255, 256 * 255, 256 * 256 * 255)) + channelOffset;
  float encodingBits = subchunkHeader0[3] * 255.0;
  if (encodingBits > 0.0) {
    vec3 subchunkPosition = floor(min(chunkPosition - subchunkGridPosition * uSubchunkSize, uSubchunkSize - 1.0));
    float subchunkOffset = getFortranOrderIndex(subchunkPosition, uSubchunkSize);
    highp float encodedValueBaseOffset = dot(subchunkHeader1.xyz, vec3(255.0, 256.0 * 255.0, 256.0 * 256.0 * 255.0)) + channelOffset;
    highp float encodedValueOffset = floor(encodedValueBaseOffset + subchunkOffset * encodingBits / 32.0);
    vec4 encodedValue = ${ local('readTextureValue') }(encodedValueOffset);
    float wordOffset = mod(subchunkOffset * encodingBits, 32.0);
    // If the value is in the first byte, then 0 <= wordOffset < 8.
    // We need to mod by 2**encodedBits
    float wordShifter = pow(2.0, -wordOffset);
    float encodedValueMod = pow(2.0, encodingBits);
    float encodedValueShifted;
    if (wordOffset < 16.0) {
      encodedValueShifted = dot(encodedValue.xy, vec2(255.0, 255.0 * 256.0));
    } else {
      encodedValueShifted = dot(encodedValue.zw, vec2(255.0 * 256.0 * 256.0, 255.0 * 256.0 * 256.0 * 256.0));
    }
    encodedValueShifted = floor(encodedValueShifted * wordShifter);
    float decodedValue = mod(encodedValueShifted, encodedValueMod);
    outputValueOffset += decodedValue * ${ this.dataType === base_1.DataType.UINT64 ? '2.0' : '1.0' };
  }
  ${ glslType } result;
`;
            if (dataType === base_1.DataType.UINT64) {
                fragmentCode += `
  result.low = ${ local('readTextureValue') }(outputValueOffset);
  result.high = ${ local('readTextureValue') }(outputValueOffset+1.0);
`;
            } else {
                fragmentCode += `
  result.value = ${ local('readTextureValue') }(outputValueOffset);
`;
            }
            fragmentCode += `
  return result;
}
`;
            builder.addFragmentCode(fragmentCode);
        }
        /**
         * Called each time textureLayout changes while drawing chunks.
         */

    }, {
        key: 'setupTextureLayout',
        value: function setupTextureLayout(gl, shader, textureLayout) {
            gl.uniform3fv(shader.uniform('uSubchunkGridSize'), textureLayout.subchunkGridSize);
            this.textureAccessHelper.setupTextureLayout(gl, shader, textureLayout);
        }
    }, {
        key: 'setTextureData',
        value: function setTextureData(gl, textureLayout, data) {
            one_dimensional_texture_access_1.setOneDimensionalTextureData(gl, textureLayout, data, /*arrayElementsPerTexel=*/4, /*textureFormat=*/gl.RGBA,
            /*texelType=*/gl.UNSIGNED_BYTE, Uint8Array);
        }
    }, {
        key: 'getTextureLayout',
        value: function getTextureLayout(gl, chunkDataSize, dataLength) {
            return TextureLayout.get(gl, chunkDataSize, this.subchunkSize, dataLength);
        }
    }, {
        key: 'beginSource',
        value: function beginSource(gl, shader) {
            _get(Object.getPrototypeOf(ChunkFormat.prototype), 'beginSource', this).call(this, gl, shader);
            gl.uniform3fv(shader.uniform('uSubchunkSize'), this.subchunkSize);
        }
    }], [{
        key: 'get',
        value: function get(gl, dataType, subchunkSize, numChannels) {
            var shaderKey = `sliceview.CompressedSegmentationChunkFormat:${ dataType }:${ numChannels }`;
            var cacheKey = `${ shaderKey }:${ geom_1.vec3Key(subchunkSize) }`;
            return gl.memoize.get(cacheKey, () => new ChunkFormat(dataType, subchunkSize, numChannels, shaderKey));
        }
    }]);

    return ChunkFormat;
}(single_texture_chunk_format_1.SingleTextureChunkFormat);

exports.ChunkFormat = ChunkFormat;
;

var CompressedSegmentationVolumeChunk = function (_single_texture_chunk2) {
    _inherits(CompressedSegmentationVolumeChunk, _single_texture_chunk2);

    function CompressedSegmentationVolumeChunk() {
        _classCallCheck(this, CompressedSegmentationVolumeChunk);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(CompressedSegmentationVolumeChunk).apply(this, arguments));
    }

    _createClass(CompressedSegmentationVolumeChunk, [{
        key: 'setTextureData',
        value: function setTextureData(gl) {
            var data = this.data;
            var chunkFormat = this.chunkFormat;

            var textureLayout = this.textureLayout = chunkFormat.getTextureLayout(gl, this.chunkDataSize, data.length);
            chunkFormat.setTextureData(gl, textureLayout, data);
        }
    }, {
        key: 'getChannelValueAt',
        value: function getChannelValueAt(dataPosition, channel) {
            var chunkDataSize = this.chunkDataSize;
            var chunkFormat = this.chunkFormat;
            var data = this.data;

            var offset = data[channel];
            if (chunkFormat.dataType === base_1.DataType.UINT64) {
                var result = new uint64_1.Uint64();
                decode_uint64_1.readSingleChannelValue(result, data, /*baseOffset=*/offset, chunkDataSize, chunkFormat.subchunkSize, dataPosition);
                return result;
            } else {
                return decode_uint32_1.readSingleChannelValue(data, /*baseOffset=*/offset, chunkDataSize, chunkFormat.subchunkSize, dataPosition);
            }
        }
    }]);

    return CompressedSegmentationVolumeChunk;
}(single_texture_chunk_format_1.SingleTextureVolumeChunk);

exports.CompressedSegmentationVolumeChunk = CompressedSegmentationVolumeChunk;
;

var CompressedSegmentationChunkFormatHandler = function (_disposable_1$RefCoun2) {
    _inherits(CompressedSegmentationChunkFormatHandler, _disposable_1$RefCoun2);

    function CompressedSegmentationChunkFormatHandler(gl, spec) {
        _classCallCheck(this, CompressedSegmentationChunkFormatHandler);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(CompressedSegmentationChunkFormatHandler).call(this));

        var dataType = spec.dataType;

        if (dataType !== base_1.DataType.UINT64 && dataType !== base_1.DataType.UINT32) {
            throw new Error(`Unsupported compressed segmentation data type: ${ base_1.DataType[dataType] }`);
        }
        _this4.chunkFormat = _this4.registerDisposer(ChunkFormat.get(gl, spec.dataType, spec.compressedSegmentationBlockSize, spec.numChannels));
        return _this4;
    }

    _createClass(CompressedSegmentationChunkFormatHandler, [{
        key: 'getChunk',
        value: function getChunk(source, x) {
            return new CompressedSegmentationVolumeChunk(source, x);
        }
    }]);

    return CompressedSegmentationChunkFormatHandler;
}(disposable_1.RefCounted);

exports.CompressedSegmentationChunkFormatHandler = CompressedSegmentationChunkFormatHandler;
;
frontend_1.registerChunkFormatHandler((gl, spec) => {
    if (spec.compressedSegmentationBlockSize != null) {
        return new CompressedSegmentationChunkFormatHandler(gl, spec);
    }
    return null;
});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

// DO NOT EDIT.  Generated from
// templates/neuroglancer/sliceview/compressed_segmentation/decode.template.ts.
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * @file
 * Support for decompressing uint64 segment label chunks.
 */

var decode_common_1 = __webpack_require__(101);
/**
 * Reads the single value at the specified dataPosition in a single-channel compressed segmentation.
 *
 * @param baseOffset The base offset into `data' at which the compressed data for this channel
 * starts.
 * @param chunkDataSize A 3-element array specifying the size of the volume,
 * @param blockSize A 3-element array specifying the block size ued for compression.
 * @param dataPosition A 3-element array specifying the position within the volume from which to
 * read.
 *
 * Stores the result in `out'.
 */
function readSingleChannelValue(data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    var outputValueOffset = decode_common_1.decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, 1) + baseOffset;
    return data[outputValueOffset];
}
exports.readSingleChannelValue = readSingleChannelValue;
/**
 * Reads the single value (of a single channel) at the specified dataPosition in a multi-channel
 * compressed segmentation.
 *
 * @param dataPosition A 4-element [x, y, z, channel] array specifying the position to read.
 */
function readValue(data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    return readSingleChannelValue(data, baseOffset + data[dataPosition[3]], chunkDataSize, blockSize, dataPosition);
}
exports.readValue = readValue;
/**
 * Decodes a single channel of a compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannel(out, data, baseOffset, chunkDataSize, blockSize) {
    var expectedLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 1;
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${ out.length } is not equal to expected length ${ expectedLength }.`);
    }
    var vx = chunkDataSize[0];
    var vy = chunkDataSize[1];
    var vz = chunkDataSize[2];
    var dataPosition = [0, 0, 0];
    var outputOffset = 0;
    for (var z = 0; z < vz; ++z) {
        dataPosition[2] = z;
        for (var y = 0; y < vy; ++y) {
            dataPosition[1] = y;
            for (var x = 0; x < vx; ++x) {
                dataPosition[0] = x;
                var outputValueOffset = decode_common_1.decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, 1) + baseOffset;
                out[outputOffset++] = data[outputValueOffset];
            }
        }
    }
    return out;
}
exports.decodeChannel = decodeChannel;
/**
 * Decodes a multi-channel compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannels(out, data, baseOffset, chunkDataSize, blockSize) {
    var channelOutputLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 1;
    var expectedLength = channelOutputLength * chunkDataSize[3];
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${ out.length } is not equal to expected length ${ expectedLength }.`);
    }
    var numChannels = chunkDataSize[3];
    for (var channel = 0; channel < numChannels; ++channel) {
        decodeChannel(out.subarray(channelOutputLength * channel, channelOutputLength * (channel + 1)), data, baseOffset + data[channel], chunkDataSize, blockSize);
    }
    return out;
}
exports.decodeChannels = decodeChannels;

/***/ },
/* 101 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * @file
 * Support for decompressing uint32 and uint64 segment label chunks.
 */
/**
 * Determines the offset of the value at the specified dataPosition in a single-channel compressed
 * segmentation.
 *
 * @param baseOffset The base offset into `data' at which the compressed data for this channel
 * starts.
 * @param chunkDataSize A 3-element array specifying the size of the volume,
 * @param blockSize A 3-element array specifying the block size ued for compression.
 * @param dataPosition A 3-element array specifying the position within the volume from which to
 * read.
 * @returns The offset into `data', relative to baseOffset, at which the value is located.
 */

function decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, uint32sPerElement) {
  var gridOffset = 0,
      subchunkOffset = 0,
      gridStride = 1,
      subchunkStride = 1;
  for (var i = 0; i < 3; ++i) {
    var posValue = dataPosition[i];
    var subchunkSizeValue = blockSize[i];
    var gridSubscript = Math.floor(posValue / subchunkSizeValue);
    var subchunkSubscript = posValue % subchunkSizeValue;
    gridOffset += gridSubscript * gridStride;
    gridStride *= Math.ceil(chunkDataSize[i] / subchunkSizeValue);
    subchunkOffset += subchunkSubscript * subchunkStride;
    subchunkStride *= subchunkSizeValue;
  }
  var subchunkHeaderOffset = baseOffset + gridOffset * 2;
  var subchunkHeader0 = data[subchunkHeaderOffset];
  var subchunkHeader1 = data[subchunkHeaderOffset + 1];
  var outputValueOffset = subchunkHeader0 & 0xFFFFFF;
  var encodingBits = subchunkHeader0 >> 24 & 0xFF;
  if (encodingBits > 0) {
    var encodedValueBaseOffset = baseOffset + subchunkHeader1 & 0xFFFFFF;
    var encodedValueOffset = encodedValueBaseOffset + Math.floor(subchunkOffset * encodingBits / 32.0);
    var encodedValue = data[encodedValueOffset];
    var wordOffset = subchunkOffset * encodingBits % 32;
    var decodedValue = encodedValue >> wordOffset & (1 << encodingBits) - 1;
    outputValueOffset += uint32sPerElement * decodedValue;
  }
  return outputValueOffset;
}
exports.decodeValueOffset = decodeValueOffset;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

// DO NOT EDIT.  Generated from
// templates/neuroglancer/sliceview/compressed_segmentation/decode.template.ts.
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * @file
 * Support for decompressing uint64 segment label chunks.
 */

var decode_common_1 = __webpack_require__(101);
/**
 * Reads the single value at the specified dataPosition in a single-channel compressed segmentation.
 *
 * @param baseOffset The base offset into `data' at which the compressed data for this channel
 * starts.
 * @param chunkDataSize A 3-element array specifying the size of the volume,
 * @param blockSize A 3-element array specifying the block size ued for compression.
 * @param dataPosition A 3-element array specifying the position within the volume from which to
 * read.
 *
 * Stores the result in `out'.
 */
function readSingleChannelValue(out, data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    var outputValueOffset = decode_common_1.decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, 2) + baseOffset;
    out.low = data[outputValueOffset];
    out.high = data[outputValueOffset + 1];
    return out;
}
exports.readSingleChannelValue = readSingleChannelValue;
/**
 * Reads the single value (of a single channel) at the specified dataPosition in a multi-channel
 * compressed segmentation.
 *
 * @param dataPosition A 4-element [x, y, z, channel] array specifying the position to read.
 */
function readValue(out, data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    return readSingleChannelValue(out, data, baseOffset + data[dataPosition[3]], chunkDataSize, blockSize, dataPosition);
}
exports.readValue = readValue;
/**
 * Decodes a single channel of a compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannel(out, data, baseOffset, chunkDataSize, blockSize) {
    var expectedLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 2;
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${ out.length } is not equal to expected length ${ expectedLength }.`);
    }
    var vx = chunkDataSize[0];
    var vy = chunkDataSize[1];
    var vz = chunkDataSize[2];
    var dataPosition = [0, 0, 0];
    var outputOffset = 0;
    for (var z = 0; z < vz; ++z) {
        dataPosition[2] = z;
        for (var y = 0; y < vy; ++y) {
            dataPosition[1] = y;
            for (var x = 0; x < vx; ++x) {
                dataPosition[0] = x;
                var outputValueOffset = decode_common_1.decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, 2) + baseOffset;
                out[outputOffset++] = data[outputValueOffset];
                out[outputOffset++] = data[outputValueOffset + 1];
            }
        }
    }
    return out;
}
exports.decodeChannel = decodeChannel;
/**
 * Decodes a multi-channel compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannels(out, data, baseOffset, chunkDataSize, blockSize) {
    var channelOutputLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 2;
    var expectedLength = channelOutputLength * chunkDataSize[3];
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${ out.length } is not equal to expected length ${ expectedLength }.`);
    }
    var numChannels = chunkDataSize[3];
    for (var channel = 0; channel < numChannels; ++channel) {
        decodeChannel(out.subarray(channelOutputLength * channel, channelOutputLength * (channel + 1)), data, baseOffset + data[channel], chunkDataSize, blockSize);
    }
    return out;
}
exports.decodeChannels = decodeChannels;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debounce = __webpack_require__(43);
var base_1 = __webpack_require__(31);
var frontend_1 = __webpack_require__(32);
var key_bindings_1 = __webpack_require__(104);
var layer_1 = __webpack_require__(42);
var layer_dialog_1 = __webpack_require__(109);
var layer_panel_1 = __webpack_require__(147);
var layer_specification_1 = __webpack_require__(110);
var L = __webpack_require__(150);
var navigation_state_1 = __webpack_require__(151);
var overlay_1 = __webpack_require__(105);
var perspective_panel_1 = __webpack_require__(36);
var position_status_panel_1 = __webpack_require__(152);
var frontend_2 = __webpack_require__(60);
var panel_1 = __webpack_require__(79);
var trackable_boolean_1 = __webpack_require__(70);
var trackable_value_1 = __webpack_require__(67);
var url_hash_state_1 = __webpack_require__(154);
var disposable_1 = __webpack_require__(23);
var dom_1 = __webpack_require__(7);
var geom_1 = __webpack_require__(9);
var keyboard_shortcut_handler_1 = __webpack_require__(106);
var worker_rpc_1 = __webpack_require__(22);
var signals_1 = __webpack_require__(34);
__webpack_require__(155);
__webpack_require__(121);
__webpack_require__(73);

var FourPanelLayout = function (_disposable_1$RefCoun) {
    _inherits(FourPanelLayout, _disposable_1$RefCoun);

    function FourPanelLayout(rootElement, viewer) {
        _classCallCheck(this, FourPanelLayout);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(FourPanelLayout).call(this));

        _this.rootElement = rootElement;
        _this.viewer = viewer;
        var sliceViews = viewer.makeOrthogonalSliceViews();
        var display = viewer.display;

        var perspectiveViewerState = {
            mouseState: viewer.mouseState,
            layerManager: viewer.layerManager,
            navigationState: viewer.perspectiveNavigationState,
            showSliceViews: viewer.showPerspectiveSliceViews,
            showAxisLines: viewer.showAxisLines
        };
        var sliceViewerState = {
            mouseState: viewer.mouseState,
            layerManager: viewer.layerManager,
            navigationState: viewer.navigationState,
            showAxisLines: viewer.showAxisLines,
            showScaleBar: viewer.showScaleBar
        };
        var sliceViewerStateWithoutScaleBar = {
            mouseState: viewer.mouseState,
            layerManager: viewer.layerManager,
            navigationState: viewer.navigationState,
            showAxisLines: viewer.showAxisLines,
            showScaleBar: new trackable_boolean_1.TrackableBoolean(false, false)
        };
        var mainDisplayContents = [L.withFlex(1, L.box('column', [L.withFlex(1, L.box('row', [L.withFlex(1, element => {
            element.className = 'gllayoutcell noselect';
            _this.registerDisposer(new panel_1.SliceViewPanel(display, element, sliceViews[0], sliceViewerState));
        }), L.withFlex(1, element => {
            element.className = 'gllayoutcell noselect';
            _this.registerDisposer(new panel_1.SliceViewPanel(display, element, sliceViews[1], sliceViewerStateWithoutScaleBar));
        })])), L.withFlex(1, L.box('row', [L.withFlex(1, element => {
            element.className = 'gllayoutcell noselect';
            var perspectivePanel = _this.registerDisposer(new perspective_panel_1.PerspectivePanel(display, element, perspectiveViewerState));
            for (var sliceView of sliceViews) {
                perspectivePanel.sliceViews.add(sliceView.addRef());
            }
        }), L.withFlex(1, element => {
            element.className = 'gllayoutcell noselect';
            _this.registerDisposer(new panel_1.SliceViewPanel(display, element, sliceViews[2], sliceViewerStateWithoutScaleBar));
        })]))]))];
        L.box('row', mainDisplayContents)(rootElement);
        display.onResize();
        return _this;
    }

    _createClass(FourPanelLayout, [{
        key: 'disposed',
        value: function disposed() {
            dom_1.removeChildren(this.rootElement);
            _get(Object.getPrototypeOf(FourPanelLayout.prototype), 'disposed', this).call(this);
        }
    }]);

    return FourPanelLayout;
}(disposable_1.RefCounted);

exports.FourPanelLayout = FourPanelLayout;
;

var SinglePanelLayout = function (_disposable_1$RefCoun2) {
    _inherits(SinglePanelLayout, _disposable_1$RefCoun2);

    function SinglePanelLayout(rootElement, viewer) {
        _classCallCheck(this, SinglePanelLayout);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SinglePanelLayout).call(this));

        _this2.rootElement = rootElement;
        _this2.viewer = viewer;
        var sliceView = viewer.makeSliceView();
        var sliceViewerState = {
            mouseState: viewer.mouseState,
            layerManager: viewer.layerManager,
            navigationState: viewer.navigationState,
            showAxisLines: viewer.showAxisLines,
            showScaleBar: viewer.showScaleBar
        };
        L.box('row', [L.withFlex(1, element => {
            _this2.registerDisposer(new panel_1.SliceViewPanel(viewer.display, element, sliceView, sliceViewerState));
        })])(rootElement);
        viewer.display.onResize();
        return _this2;
    }

    _createClass(SinglePanelLayout, [{
        key: 'disposed',
        value: function disposed() {
            dom_1.removeChildren(this.rootElement);
            _get(Object.getPrototypeOf(SinglePanelLayout.prototype), 'disposed', this).call(this);
        }
    }]);

    return SinglePanelLayout;
}(disposable_1.RefCounted);

exports.SinglePanelLayout = SinglePanelLayout;
;
exports.LAYOUTS = [['4panel', (element, viewer) => new FourPanelLayout(element, viewer)], ['xy', (element, viewer) => new SinglePanelLayout(element, viewer)]];
function getLayoutByName(obj) {
    var layout = exports.LAYOUTS.find(x => x[0] === obj);
    if (layout === undefined) {
        throw new Error(`Invalid layout name: ${ JSON.stringify(obj) }.`);
    }
    return layout;
}
exports.getLayoutByName = getLayoutByName;
function validateLayoutName(obj) {
    var layout = getLayoutByName(obj);
    return layout[0];
}
exports.validateLayoutName = validateLayoutName;

var Viewer = function (_disposable_1$RefCoun3) {
    _inherits(Viewer, _disposable_1$RefCoun3);

    function Viewer(display) {
        _classCallCheck(this, Viewer);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(Viewer).call(this));

        _this3.display = display;
        _this3.navigationState = _this3.registerDisposer(new navigation_state_1.NavigationState());
        _this3.perspectiveNavigationState = new navigation_state_1.NavigationState(new navigation_state_1.Pose(_this3.navigationState.position), 1);
        _this3.mouseState = new layer_1.MouseSelectionState();
        _this3.layerManager = _this3.registerDisposer(new layer_1.LayerManager());
        _this3.showAxisLines = new trackable_boolean_1.TrackableBoolean(true, true);
        _this3.showScaleBar = new trackable_boolean_1.TrackableBoolean(true, true);
        _this3.showPerspectiveSliceViews = new trackable_boolean_1.TrackableBoolean(true, true);
        _this3.layerSelectedValues = _this3.registerDisposer(new layer_1.LayerSelectedValues(_this3.layerManager, _this3.mouseState));
        _this3.worker = new worker_rpc_1.RPC(new Worker('chunk_worker.bundle.js'));
        _this3.resetInitiated = new signals_1.Signal();
        _this3.chunkQueueManager = new frontend_1.ChunkQueueManager(_this3.worker, _this3.display.gl, {
            gpuMemory: new base_1.AvailableCapacity(1e6, 1e9),
            systemMemory: new base_1.AvailableCapacity(1e7, 2e9),
            download: new base_1.AvailableCapacity(32, Number.POSITIVE_INFINITY)
        });
        _this3.chunkManager = new frontend_1.ChunkManager(_this3.chunkQueueManager);
        _this3.keyMap = new keyboard_shortcut_handler_1.KeySequenceMap();
        _this3.keyCommands = new Map();
        _this3.layerSpecification = new layer_specification_1.LayerListSpecification(_this3.layerManager, _this3.chunkManager, _this3.worker, _this3.layerSelectedValues, _this3.navigationState.voxelSize);
        _this3.layoutName = new trackable_value_1.TrackableValue(exports.LAYOUTS[0][0], validateLayoutName);
        // Delay hash update after each redraw to try to prevent noticeable lag in Chrome.
        _this3.registerSignalBinding(display.updateStarted.add(_this3.onUpdateDisplay, _this3));
        _this3.registerSignalBinding(display.updateFinished.add(_this3.onUpdateDisplayFinished, _this3));
        // Prevent contextmenu on rightclick, as this inteferes with our use
        // of the right mouse button.
        _this3.registerEventListener(document, 'contextmenu', e => {
            e.preventDefault();
            return false;
        });
        url_hash_state_1.registerTrackable('layers', _this3.layerSpecification);
        url_hash_state_1.registerTrackable('navigation', _this3.navigationState);
        url_hash_state_1.registerTrackable('showAxisLines', _this3.showAxisLines);
        url_hash_state_1.registerTrackable('showScaleBar', _this3.showScaleBar);
        url_hash_state_1.registerTrackable('perspectiveOrientation', _this3.perspectiveNavigationState.pose.orientation);
        url_hash_state_1.registerTrackable('perspectiveZoom', _this3.perspectiveNavigationState.zoomFactor);
        url_hash_state_1.registerTrackable('showSlices', _this3.showPerspectiveSliceViews);
        url_hash_state_1.registerTrackable('layout', _this3.layoutName);
        _this3.registerSignalBinding(_this3.navigationState.changed.add(_this3.handleNavigationStateChanged, _this3));
        _this3.layerManager.initializePosition(_this3.navigationState.position);
        // Debounce this call to ensure that a transient state does not result in the layer dialog being
        // shown.
        _this3.layerManager.layersChanged.add(_this3.registerCancellable(debounce(() => {
            if (_this3.layerManager.managedLayers.length === 0) {
                // No layers, reset state.
                _this3.navigationState.reset();
                _this3.perspectiveNavigationState.pose.orientation.reset();
                _this3.perspectiveNavigationState.zoomFactor.reset();
                _this3.resetInitiated.dispatch();
                if (!overlay_1.overlaysOpen) {
                    new layer_dialog_1.LayerDialog(_this3.layerSpecification);
                }
            }
        })));
        _this3.registerSignalBinding(_this3.chunkQueueManager.visibleChunksChanged.add(() => {
            _this3.layerSelectedValues.handleLayerChange();
        }));
        _this3.chunkQueueManager.visibleChunksChanged.add(display.scheduleRedraw, display);
        _this3.makeUI();
        _this3.registerDisposer(new keyboard_shortcut_handler_1.GlobalKeyboardShortcutHandler(_this3.keyMap, _this3.onKeyCommand.bind(_this3)));
        _this3.layoutName.changed.add(() => {
            if (_this3.dataDisplayLayout !== undefined) {
                var element = _this3.dataDisplayLayout.rootElement;
                _this3.dataDisplayLayout.dispose();
                _this3.createDataDisplayLayout(element);
            }
        });
        var keyCommands = _this3.keyCommands;

        keyCommands.set('toggle-layout', function () {
            this.toggleLayout();
        });
        keyCommands.set('snap', function () {
            this.navigationState.pose.snap();
        });
        keyCommands.set('add-layer', function () {
            this.layerPanel.addLayerMenu();
            return true;
        });
        keyCommands.set('help', _this3.showHelpDialog);

        var _loop = function (i) {
            keyCommands.set('toggle-layer-' + i, function () {
                var layerIndex = i - 1;
                var layers = this.layerManager.managedLayers;
                if (layerIndex < layers.length) {
                    var layer = layers[layerIndex];
                    layer.setVisible(!layer.visible);
                }
            });
        };

        for (var i = 1; i <= 9; ++i) {
            _loop(i);
        }

        var _loop2 = function (command) {
            keyCommands.set(command, function () {
                this.layerManager.invokeAction(command);
            });
        };

        for (var command of ['recolor', 'clear-segments']) {
            _loop2(command);
        }
        keyCommands.set('toggle-axis-lines', function () {
            this.showAxisLines.toggle();
        });
        keyCommands.set('toggle-scale-bar', function () {
            this.showScaleBar.toggle();
        });
        _this3.keyCommands.set('toggle-show-slices', function () {
            this.showPerspectiveSliceViews.toggle();
        });
        // This needs to happen after the global keyboard shortcut handler for the viewer has been
        // registered, so that it has priority.
        if (_this3.layerManager.managedLayers.length === 0) {
            new layer_dialog_1.LayerDialog(_this3.layerSpecification);
        }
        return _this3;
    }

    _createClass(Viewer, [{
        key: 'makeUI',
        value: function makeUI() {
            var display = this.display;

            var gridContainer = document.createElement('div');
            gridContainer.setAttribute('class', 'gllayoutcontainer noselect');
            var container = display.container;

            container.appendChild(gridContainer);
            L.box('column', [L.box('row', [L.withFlex(1, element => new position_status_panel_1.PositionStatusPanel(element, this)), element => {
                var button = document.createElement('button');
                button.className = 'help-button';
                button.textContent = '?';
                button.title = 'Help';
                element.appendChild(button);
                this.registerEventListener(button, 'click', () => {
                    this.showHelpDialog();
                });
            }]), element => {
                this.layerPanel = new layer_panel_1.LayerPanel(element, this.layerSpecification);
            }, L.withFlex(1, element => {
                this.createDataDisplayLayout(element);
            })])(gridContainer);
            this.display.onResize();
        }
    }, {
        key: 'createDataDisplayLayout',
        value: function createDataDisplayLayout(element) {
            var layoutCreator = getLayoutByName(this.layoutName.value)[1];
            this.dataDisplayLayout = layoutCreator(element, this);
        }
    }, {
        key: 'toggleLayout',
        value: function toggleLayout() {
            var existingLayout = getLayoutByName(this.layoutName.value);
            var layoutIndex = exports.LAYOUTS.indexOf(existingLayout);
            var newLayout = exports.LAYOUTS[(layoutIndex + 1) % exports.LAYOUTS.length];
            this.layoutName.value = newLayout[0];
        }
    }, {
        key: 'showHelpDialog',
        value: function showHelpDialog() {
            new key_bindings_1.KeyBindingHelpDialog(this.keyMap);
        }
    }, {
        key: 'onUpdateDisplay',
        value: function onUpdateDisplay() {
            url_hash_state_1.delayHashUpdate();
            this.chunkQueueManager.chunkUpdateDeadline = null;
        }
    }, {
        key: 'onUpdateDisplayFinished',
        value: function onUpdateDisplayFinished() {
            this.mouseState.updateIfStale();
        }
    }, {
        key: 'onKeyCommand',
        value: function onKeyCommand(action) {
            var command = this.keyCommands.get(action);
            if (command && command.call(this)) {
                return true;
            }
            var activePanel = this.display.activePanel;

            if (activePanel) {
                return activePanel.onKeyCommand(action);
            }
            return false;
        }
    }, {
        key: 'makeSliceView',
        value: function makeSliceView(baseToSelf) {
            var navigationState = void 0;
            if (baseToSelf === undefined) {
                navigationState = this.navigationState;
            } else {
                navigationState = new navigation_state_1.NavigationState(new navigation_state_1.Pose(this.navigationState.pose.position, navigation_state_1.OrientationState.makeRelative(this.navigationState.pose.orientation, baseToSelf)), this.navigationState.zoomFactor);
            }
            return new frontend_2.SliceView(this.gl, this.chunkManager, this.layerManager, navigationState);
        }
    }, {
        key: 'makeOrthogonalSliceViews',
        value: function makeOrthogonalSliceViews() {
            var gl = this.gl;
            var layerManager = this.layerManager;

            var sliceViews = new Array();
            var addSliceView = mat => {
                sliceViews.push(this.makeSliceView(mat));
            };
            addSliceView();
            addSliceView(geom_1.quat.rotateX(geom_1.quat.create(), geom_1.quat.create(), Math.PI / 2));
            addSliceView(geom_1.quat.rotateY(geom_1.quat.create(), geom_1.quat.create(), Math.PI / 2));
            // {
            //   let mat = mat4.create();
            //   mat4.identity(mat);
            //   mat4.rotateX(mat, mat, Math.PI / 2);
            //   addSliceView(mat);
            // }
            // {
            //   let mat = mat4.create();
            //   mat4.identity(mat);
            //   mat4.rotateY(mat, mat, Math.PI / 2);
            //   addSliceView(mat);
            // }
            return sliceViews;
        }
    }, {
        key: 'handleNavigationStateChanged',
        value: function handleNavigationStateChanged() {
            var chunkQueueManager = this.chunkQueueManager;

            if (chunkQueueManager.chunkUpdateDeadline === null) {
                chunkQueueManager.chunkUpdateDeadline = Date.now() + 10;
            }
            this.mouseState.stale = true;
        }
    }, {
        key: 'gl',
        get: function () {
            return this.display.gl;
        }
    }]);

    return Viewer;
}(disposable_1.RefCounted);

exports.Viewer = Viewer;
;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var overlay_1 = __webpack_require__(105);
__webpack_require__(108);
function formatKeyName(name) {
    if (name.startsWith('key')) {
        return name.substring(3);
    }
    if (name.startsWith('digit')) {
        return name.substring(5);
    }
    if (name.startsWith('arrow')) {
        return name.substring(5);
    }
    return name;
}
exports.formatKeyName = formatKeyName;
function formatKeyStroke(stroke) {
    var parts = stroke.split('+');
    return parts.map(formatKeyName).join('+');
}
exports.formatKeyStroke = formatKeyStroke;

var KeyBindingHelpDialog = function (_overlay_1$Overlay) {
    _inherits(KeyBindingHelpDialog, _overlay_1$Overlay);

    /**
     * @param keyMap Key map to list.
     */

    function KeyBindingHelpDialog(keyMap) {
        _classCallCheck(this, KeyBindingHelpDialog);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(KeyBindingHelpDialog).call(this));

        var content = _this.content;

        content.classList.add('describe-key-bindings');
        var scroll = document.createElement('div');
        var dl = document.createElement('div');
        dl.className = 'dl';
        for (var _ref3 of keyMap.entries()) {
            var _ref2 = _slicedToArray(_ref3, 2);

            var sequence = _ref2[0];
            var command = _ref2[1];

            var container = document.createElement('div');
            var container2 = document.createElement('div');
            container2.className = 'definition-outer-container';
            container.className = 'definition-container';
            var dt = document.createElement('div');
            dt.className = 'dt';
            dt.textContent = sequence.map(formatKeyStroke).join(' ');
            var dd = document.createElement('div');
            dd.className = 'dd';
            dd.textContent = command;
            container.appendChild(dt);
            container.appendChild(dd);
            dl.appendChild(container2);
            container2.appendChild(container);
        }
        scroll.appendChild(dl);
        content.appendChild(scroll);
        return _this;
    }

    return KeyBindingHelpDialog;
}(overlay_1.Overlay);

exports.KeyBindingHelpDialog = KeyBindingHelpDialog;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var keyboard_shortcut_handler_1 = __webpack_require__(106);
__webpack_require__(107);
exports.overlaysOpen = 0;
var KEY_MAP = new keyboard_shortcut_handler_1.KeySequenceMap();
KEY_MAP.bind('escape', 'close');

var Overlay = function (_disposable_1$RefCoun) {
    _inherits(Overlay, _disposable_1$RefCoun);

    function Overlay() {
        var keySequenceMap = arguments.length <= 0 || arguments[0] === undefined ? KEY_MAP : arguments[0];

        _classCallCheck(this, Overlay);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Overlay).call(this));

        _this.keySequenceMap = keySequenceMap;
        ++exports.overlaysOpen;
        var container = _this.container = document.createElement('div');
        container.className = 'overlay';
        var content = _this.content = document.createElement('div');
        content.className = 'overlay-content';
        container.appendChild(content);
        document.body.appendChild(container);
        _this.keyboardShortcutHandler = _this.registerDisposer(new keyboard_shortcut_handler_1.GlobalKeyboardShortcutHandler(keySequenceMap, _this.commandReceived.bind(_this)));
        return _this;
    }

    _createClass(Overlay, [{
        key: 'commandReceived',
        value: function commandReceived(action) {
            if (action === 'close') {
                this.dispose();
            }
            return false;
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            --exports.overlaysOpen;
            document.body.removeChild(this.container);
            _get(Object.getPrototypeOf(Overlay.prototype), 'disposed', this).call(this);
        }
    }]);

    return Overlay;
}(disposable_1.RefCounted);

exports.Overlay = Overlay;
;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
// This is based on goog/ui/keyboardshortcuthandler.js in the Google Closure library.

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var MAX_KEY_SEQUENCE_DELAY = 1500; // 1.5 sec
var globalKeys = new Set(['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'escape', 'pause']);
var DEFAULT_TEXT_INPUTS = new Set(['color', 'date', 'datetime', 'datetime-local', 'email', 'month', 'number', 'password', 'search', 'tel', 'text', 'time', 'url', 'week']);

var KeyboardShortcutHandler = function (_disposable_1$RefCoun) {
    _inherits(KeyboardShortcutHandler, _disposable_1$RefCoun);

    function KeyboardShortcutHandler(target, keySequenceMap, handler) {
        _classCallCheck(this, KeyboardShortcutHandler);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(KeyboardShortcutHandler).call(this));

        _this.target = target;
        _this.keySequenceMap = keySequenceMap;
        _this.handler = handler;
        _this.modifierShortcutsAreGlobal = true;
        _this.allShortcutsAreGlobal = false;
        _this.allowSpaceKeyOnButtons = false;
        _this.reset();
        _this.registerEventListener(target, 'keydown', _this.handleKeyDown.bind(_this), /*useCapture=*/true);
        return _this;
    }

    _createClass(KeyboardShortcutHandler, [{
        key: 'reset',
        value: function reset() {
            this.currentNode = this.keySequenceMap.root;
            this.lastStrokeTime = Number.NEGATIVE_INFINITY;
        }
    }, {
        key: 'setKeySequenceMap',
        value: function setKeySequenceMap(keySequenceMap) {
            this.keySequenceMap = keySequenceMap;
            this.reset();
        }
    }, {
        key: 'shouldIgnoreEvent',
        value: function shouldIgnoreEvent(key, event) {
            var el = event.target;
            var tagName = el.tagName;

            if (el === this.target) {
                // If the event is directly on the target element, we never ignore it.
                return false;
            }
            var isFormElement = tagName === 'TEXTAREA' || tagName === 'INPUT' || tagName === 'BUTTON' || tagName === 'SELECT';
            var isContentEditable = !isFormElement && (el.isContentEditable || el.ownerDocument && el.ownerDocument.designMode === 'on');
            if (!isFormElement && !isContentEditable) {
                return false;
            }
            // Always allow keys registered as global to be used (typically Esc, the
            // F-keys and other keys that are not typically used to manipulate text).
            if (this.allShortcutsAreGlobal || globalKeys.has(key)) {
                return false;
            }
            if (isContentEditable) {
                // For events originating from an element in editing mode we only let
                // global key codes through.
                return true;
            }
            // Event target is one of (TEXTAREA, INPUT, BUTTON, SELECT).
            // Allow modifier shortcuts, unless we shouldn't.
            if (this.modifierShortcutsAreGlobal && (event.altKey || event.ctrlKey || event.metaKey)) {
                return true;
            }
            // Allow ENTER to be used as shortcut for text inputs.
            if (tagName === 'INPUT' && DEFAULT_TEXT_INPUTS.has(el.type)) {
                return key !== 'enter';
            }
            // Checkboxes, radiobuttons and buttons. Allow all but SPACE as shortcut.
            if (tagName === 'INPUT' || tagName === 'BUTTON') {
                // TODO(gboyer): If more flexibility is needed, create protected helper
                // methods for each case (e.g. button, input, etc).
                if (this.allowSpaceKeyOnButtons) {
                    return false;
                } else {
                    return key === 'space';
                }
            }
            // Don't allow any additional shortcut keys for textareas or selects.
            return true;
        }
    }, {
        key: 'handleKeyDown',
        value: function handleKeyDown(event) {
            var key = getEventKeyName(event);
            if (this.shouldIgnoreEvent(key, event)) {
                return;
            }
            var stroke = getStrokeIdentifier(key, getEventModifierMask(event));
            var root = this.keySequenceMap.root;
            var currentNode = this.currentNode;

            var value = currentNode.get(stroke);
            var now = Date.now();
            if (currentNode !== root && (value === undefined || now > this.lastStrokeTime + MAX_KEY_SEQUENCE_DELAY)) {
                this.currentNode = root;
                value = currentNode.get(stroke);
            }
            if (value === undefined) {
                return;
            }
            if (typeof value === 'string') {
                // Terminal node.
                this.reset();
                if (this.handler(value)) {
                    event.preventDefault();
                }
            } else {
                this.currentNode = value;
                this.lastStrokeTime = now;
                event.preventDefault();
            }
        }
    }]);

    return KeyboardShortcutHandler;
}(disposable_1.RefCounted);

exports.KeyboardShortcutHandler = KeyboardShortcutHandler;
;
function getEventStrokeIdentifier(event) {
    return getStrokeIdentifier(getEventKeyName(event), getEventModifierMask(event));
}
exports.getEventStrokeIdentifier = getEventStrokeIdentifier;
var Modifiers;
(function (Modifiers) {
    Modifiers[Modifiers["CONTROL"] = 1] = "CONTROL";
    Modifiers[Modifiers["ALT"] = 2] = "ALT";
    Modifiers[Modifiers["META"] = 4] = "META";
    Modifiers[Modifiers["SHIFT"] = 8] = "SHIFT";
})(Modifiers || (Modifiers = {}));
function getEventModifierMask(event) {
    return (event.ctrlKey ? 1 /* CONTROL */ : 0) | (event.altKey ? 2 /* ALT */ : 0) | (event.metaKey ? 4 /* META */ : 0) | (event.shiftKey ? 8 /* SHIFT */ : 0);
}
exports.getEventModifierMask = getEventModifierMask;
function getStrokeIdentifier(keyName, modifiers) {
    var identifier = '';
    if (modifiers & 1 /* CONTROL */) {
            identifier += 'control+';
        }
    if (modifiers & 2 /* ALT */) {
            identifier += 'alt+';
        }
    if (modifiers & 4 /* META */) {
            identifier += 'meta+';
        }
    if (modifiers & 8 /* SHIFT */) {
            identifier += 'shift+';
        }
    identifier += keyName;
    return identifier;
}
exports.getStrokeIdentifier = getStrokeIdentifier;
function getEventKeyName(event) {
    return event.code.toLowerCase();
}
exports.getEventKeyName = getEventKeyName;
function parseKeyStroke(strokeIdentifier) {
    strokeIdentifier = strokeIdentifier.toLowerCase().replace(' ', '');
    var parts = strokeIdentifier.split('+');
    var keyName = void 0;
    var modifiers = 0;
    for (var part of parts) {
        switch (part) {
            case 'control':
                modifiers |= 1 /* CONTROL */;
                break;
            case 'alt':
                modifiers |= 2 /* ALT */;
                break;
            case 'meta':
                modifiers |= 4 /* META */;
                break;
            case 'shift':
                modifiers |= 8 /* SHIFT */;
                break;
            default:
                if (keyName === undefined) {
                    keyName = part;
                } else {
                    keyName = null;
                }
        }
    }
    if (keyName == null) {
        throw new Error(`Invalid stroke ${ JSON.stringify(strokeIdentifier) }`);
    }
    return getStrokeIdentifier(keyName, modifiers);
}
exports.parseKeyStroke = parseKeyStroke;
function parseKeySequence(sequence) {
    if (typeof sequence === 'string') {
        var s = sequence;
        s = s.replace(/[ +]*\+[ +]*/g, '+').replace(/[ ]+/g, ' ').toLowerCase();
        sequence = s.split(' ');
    }
    var parts = sequence.map(parseKeyStroke);
    if (parts.length === 0) {
        throw new Error('Key sequence must not be empty');
    }
    return parts;
}
exports.parseKeySequence = parseKeySequence;
function formatKeySequence(sequence) {
    return JSON.stringify(sequence.join(' '));
}
exports.formatKeySequence = formatKeySequence;
function* keySequenceMapEntries(map) {
    var prefix = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

    for (var _ref3 of map) {
        var _ref2 = _slicedToArray(_ref3, 2);

        var key = _ref2[0];
        var value = _ref2[1];

        var newPrefix = [...prefix, key];
        if (typeof value === 'string') {
            yield [newPrefix, value];
        } else {
            yield* keySequenceMapEntries(value, newPrefix);
        }
    }
}

var KeySequenceMap = function () {
    function KeySequenceMap(bindings) {
        _classCallCheck(this, KeySequenceMap);

        this.root = new Map();
        if (bindings !== undefined) {
            this.bindMultiple(bindings);
        }
    }

    _createClass(KeySequenceMap, [{
        key: 'bind',
        value: function bind(keySequenceSpec, action) {
            var keySequence = parseKeySequence(keySequenceSpec);
            var currentNode = this.root;
            var prefixEnd = keySequence.length - 1;
            for (var i = 0; i < prefixEnd; ++i) {
                var _stroke = keySequence[i];
                var value = currentNode.get(_stroke);
                if (value === undefined) {
                    value = new Map();
                    currentNode.set(_stroke, value);
                }
                if (typeof value === 'string') {
                    throw new Error(`Error binding key sequence ${ formatKeySequence(keySequence) }: prefix ${ formatKeySequence(keySequence.slice(0, i + 1)) } is already bound to action ${ JSON.stringify(value) }`);
                }
                currentNode = value;
            }
            var stroke = keySequence[prefixEnd];
            var existingValue = currentNode.get(stroke);
            if (existingValue !== undefined) {
                throw new Error(`Key sequence ${ formatKeySequence(keySequence) } is already bound to action ${ JSON.stringify(existingValue) }`);
            }
            currentNode.set(stroke, action);
        }
    }, {
        key: 'bindMultiple',
        value: function bindMultiple(bindings) {
            for (var key of Object.keys(bindings)) {
                this.bind(key, bindings[key]);
            }
        }
    }, {
        key: 'entries',
        value: function entries() {
            return keySequenceMapEntries(this.root);
        }
    }]);

    return KeySequenceMap;
}();

exports.KeySequenceMap = KeySequenceMap;
;
var globalKeyboardHandler = void 0;
var globalKeyboardHandlerStack = new Array();
var globalKeyboardState = void 0;
function pushGlobalKeyboardHandler(keySequenceMap, handler, identifier) {
    if (globalKeyboardHandler === undefined) {
        globalKeyboardHandler = new KeyboardShortcutHandler(window, new KeySequenceMap(), () => {
            return false;
        });
    }
    globalKeyboardHandlerStack.push([globalKeyboardHandler.keySequenceMap, globalKeyboardHandler.handler, globalKeyboardState]);
    globalKeyboardHandler.setKeySequenceMap(keySequenceMap);
    globalKeyboardHandler.handler = handler;
    globalKeyboardState = identifier;
}
exports.pushGlobalKeyboardHandler = pushGlobalKeyboardHandler;
function popGlobalKeyboardHandler() {
    var _globalKeyboardHandle = globalKeyboardHandlerStack.pop();

    var _globalKeyboardHandle2 = _slicedToArray(_globalKeyboardHandle, 3);

    var keySequenceMap = _globalKeyboardHandle2[0];
    var handler = _globalKeyboardHandle2[1];
    var identifier = _globalKeyboardHandle2[2];

    globalKeyboardHandler.setKeySequenceMap(keySequenceMap);
    globalKeyboardHandler.handler = handler;
    globalKeyboardState = identifier;
}
exports.popGlobalKeyboardHandler = popGlobalKeyboardHandler;

var GlobalKeyboardShortcutHandler = function (_disposable_1$RefCoun2) {
    _inherits(GlobalKeyboardShortcutHandler, _disposable_1$RefCoun2);

    function GlobalKeyboardShortcutHandler(keySequenceMap, handler) {
        _classCallCheck(this, GlobalKeyboardShortcutHandler);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(GlobalKeyboardShortcutHandler).call(this));

        _this2.keySequenceMap = keySequenceMap;
        _this2.handler = handler;
        pushGlobalKeyboardHandler(keySequenceMap, handler, _this2);
        return _this2;
    }

    _createClass(GlobalKeyboardShortcutHandler, [{
        key: 'disposed',
        value: function disposed() {
            if (globalKeyboardState === this) {
                popGlobalKeyboardHandler();
            } else {
                var index = globalKeyboardHandlerStack.findIndex(stackEntry => stackEntry[2] === this);
                globalKeyboardHandlerStack.splice(index, 1);
            }
            _get(Object.getPrototypeOf(GlobalKeyboardShortcutHandler.prototype), 'disposed', this).call(this);
        }
    }]);

    return GlobalKeyboardShortcutHandler;
}(disposable_1.RefCounted);

exports.GlobalKeyboardShortcutHandler = GlobalKeyboardShortcutHandler;

/***/ },
/* 107 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 108 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var factory_1 = __webpack_require__(28);
var layer_specification_1 = __webpack_require__(110);
var overlay_1 = __webpack_require__(105);
var base_1 = __webpack_require__(61);
var promise_1 = __webpack_require__(20);
var associate_label_1 = __webpack_require__(139);
var autocomplete_1 = __webpack_require__(140);
var hidden_submit_button_1 = __webpack_require__(145);
__webpack_require__(146);

var LayerDialog = function (_overlay_1$Overlay) {
    _inherits(LayerDialog, _overlay_1$Overlay);

    function LayerDialog(manager, existingLayer) {
        _classCallCheck(this, LayerDialog);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LayerDialog).call(this));

        _this.manager = manager;
        _this.existingLayer = existingLayer;
        /**
         * Used for displaying status information.
         */
        _this.statusElement = document.createElement('div');
        _this.submitElement = document.createElement('button');
        _this.namePromptElement = document.createElement('label');
        _this.nameInputElement = document.createElement('input');
        _this.sourceValid = false;
        _this.nameValid = true;
        var dialogElement = _this.content;
        dialogElement.classList.add('add-layer-overlay');
        var sourceCompleter = value => promise_1.cancellableThen(factory_1.volumeCompleter(value), originalResult => ({
            completions: originalResult.completions,
            makeElement: autocomplete_1.makeCompletionElementWithDescription,
            offset: originalResult.offset,
            showSingleResult: true
        }));
        var sourceForm = document.createElement('form');
        sourceForm.className = 'source-form';
        _this.registerEventListener(sourceForm, 'submit', event => {
            event.preventDefault();
            _this.validateSource( /*focusName=*/true);
        });
        var sourcePrompt = document.createElement('label');
        sourcePrompt.textContent = 'Source:';
        var sourceInput = _this.sourceInput = _this.registerDisposer(new autocomplete_1.AutocompleteTextInput({ completer: sourceCompleter, delay: 0 }));
        sourceInput.element.classList.add('add-layer-source');
        sourceInput.inputElement.addEventListener('blur', event => {
            _this.validateSource( /*focusName=*/false);
        });
        _this.submitElement.disabled = true;
        sourceInput.inputChanged.add(() => {
            promise_1.cancelPromise(_this.volumePromise);
            _this.volumePromise = undefined;
            _this.sourceValid = false;
            _this.submitElement.disabled = true;
            _this.statusElement.textContent = '';
        });
        sourceForm.appendChild(sourcePrompt);
        sourceForm.appendChild(sourceInput.element);
        associate_label_1.associateLabelWithElement(sourcePrompt, sourceInput.inputElement);
        var hiddenSourceSubmit = hidden_submit_button_1.makeHiddenSubmitButton();
        sourceForm.appendChild(hiddenSourceSubmit);
        dialogElement.appendChild(sourceForm);
        var statusElement = _this.statusElement;
        var namePromptElement = _this.namePromptElement;
        var nameInputElement = _this.nameInputElement;
        var submitElement = _this.submitElement;

        statusElement.className = 'dialog-status';
        var nameForm = document.createElement('form');
        nameForm.className = 'name-form';
        namePromptElement.textContent = 'Name:';
        nameInputElement.className = 'add-layer-name';
        nameInputElement.autocomplete = 'off';
        nameInputElement.spellcheck = false;
        nameInputElement.type = 'text';
        _this.registerEventListener(nameInputElement, 'input', () => {
            _this.validateName();
        });
        submitElement.type = 'submit';
        associate_label_1.associateLabelWithElement(namePromptElement, nameInputElement);
        nameForm.appendChild(namePromptElement);
        nameForm.appendChild(nameInputElement);
        nameForm.appendChild(submitElement);
        dialogElement.appendChild(nameForm);
        dialogElement.appendChild(statusElement);
        if (existingLayer !== undefined) {
            if (existingLayer.sourceUrl !== undefined) {
                sourceInput.value = existingLayer.sourceUrl;
                _this.validateSource();
            } else {
                _this.sourceValid = true;
            }
            sourceInput.disabled = true;
            nameInputElement.value = existingLayer.name;
            _this.validateName();
            submitElement.textContent = 'Save';
            nameInputElement.focus();
        } else {
            var managedLayers = _this.manager.layerManager.managedLayers;

            if (managedLayers.length > 0) {
                var lastLayer = managedLayers[managedLayers.length - 1];
                if (lastLayer instanceof layer_specification_1.ManagedUserLayerWithSpecification) {
                    var sourceUrl = lastLayer.sourceUrl;

                    if (sourceUrl !== undefined) {
                        var groupIndex = factory_1.findSourceGroup(sourceUrl);
                        sourceInput.value = sourceUrl.substring(0, groupIndex);
                        sourceInput.inputElement.setSelectionRange(0, groupIndex);
                    }
                }
            }
            sourceInput.inputElement.focus();
            submitElement.textContent = 'Add Layer';
        }
        _this.registerEventListener(nameForm, 'submit', event => {
            event.preventDefault();
            _this.submit();
        });
        return _this;
    }

    _createClass(LayerDialog, [{
        key: 'isNameValid',
        value: function isNameValid() {
            var name = this.nameInputElement.value;
            if (name === '') {
                return false;
            }
            var otherLayer = this.manager.layerManager.getLayerByName(name);
            return otherLayer === undefined || otherLayer === this.existingLayer;
        }
    }, {
        key: 'submit',
        value: function submit() {
            if (this.sourceValid && this.isNameValid()) {
                if (this.existingLayer) {
                    this.existingLayer.name = this.nameInputElement.value;
                    this.manager.layerManager.layersChanged.dispatch();
                } else {
                    this.manager.layerManager.addManagedLayer(this.manager.getLayer(this.nameInputElement.value, this.sourceInput.value));
                }
                this.dispose();
            }
        }
    }, {
        key: 'validateName',
        value: function validateName() {
            var nameInputElement = this.nameInputElement;

            var nameValid = this.nameValid = this.isNameValid();
            if (nameValid) {
                nameInputElement.classList.add('valid-input');
                nameInputElement.classList.remove('invalid-input');
            } else {
                nameInputElement.classList.remove('valid-input');
                nameInputElement.classList.add('invalid-input');
            }
            this.validityChanged();
        }
    }, {
        key: 'validityChanged',
        value: function validityChanged() {
            this.submitElement.disabled = !(this.nameValid && this.sourceValid);
        }
    }, {
        key: 'validateSource',
        value: function validateSource() {
            var focusName = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

            var url = this.sourceInput.value;
            if (url === '') {
                return;
            }
            try {
                var baseSuggestedName = factory_1.suggestLayerName(url);
                var nameInputElement = this.nameInputElement;

                if (this.nameInputElement.value === '') {
                    var suggestedName = baseSuggestedName;
                    var suffix = 0;
                    while (this.manager.layerManager.getLayerByName(suggestedName) !== undefined) {
                        suggestedName = baseSuggestedName + ++suffix;
                    }
                    nameInputElement.value = suggestedName;
                    nameInputElement.setSelectionRange(0, suggestedName.length);
                    this.validateName();
                }
                if (focusName) {
                    nameInputElement.focus();
                }
            } catch (error) {
                this.setError(error.message);
                return;
            }
            this.setInfo('Validating volume source...');
            var volumePromise = new Promise(resolve => {
                resolve(factory_1.getVolume(url));
            });
            this.volumePromise = promise_1.cancellableThen(volumePromise, source => {
                this.sourceValid = true;
                this.setInfo(`${ base_1.VolumeType[source.volumeType].toLowerCase() }: ${ source.numChannels }-channel ${ base_1.DataType[source.dataType].toLowerCase() }`);
                this.validityChanged();
            });
            volumePromise.catch(reason => {
                if (reason === promise_1.CANCELLED) {
                    return;
                }
                this.setError(reason.message);
            });
        }
    }, {
        key: 'setInfo',
        value: function setInfo(message) {
            this.statusElement.className = 'dialog-status dialog-status-info';
            this.statusElement.textContent = message;
        }
    }, {
        key: 'setError',
        value: function setError(message) {
            this.statusElement.className = 'dialog-status dialog-status-error';
            this.statusElement.textContent = message;
        }
    }]);

    return LayerDialog;
}(overlay_1.Overlay);

exports.LayerDialog = LayerDialog;
;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var factory_1 = __webpack_require__(28);
var image_user_layer_1 = __webpack_require__(111);
var layer_1 = __webpack_require__(42);
var segmentation_user_layer_1 = __webpack_require__(124);
var base_1 = __webpack_require__(61);
var status_1 = __webpack_require__(4);
var disposable_1 = __webpack_require__(23);
var json_1 = __webpack_require__(8);
var signals_1 = __webpack_require__(34);
function getVolumeWithStatusMessage(x) {
    return status_1.StatusMessage.forPromise(new Promise(function (resolve) {
        resolve(factory_1.getVolume(x));
    }), {
        initialMessage: `Retrieving metadata for volume ${ x }.`,
        delay: true,
        errorPrefix: `Error retrieving metadata for volume ${ x }: `
    });
}
exports.getVolumeWithStatusMessage = getVolumeWithStatusMessage;

var ManagedUserLayerWithSpecification = function (_layer_1$ManagedUserL) {
    _inherits(ManagedUserLayerWithSpecification, _layer_1$ManagedUserL);

    function ManagedUserLayerWithSpecification(name, initialSpecification, manager) {
        _classCallCheck(this, ManagedUserLayerWithSpecification);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ManagedUserLayerWithSpecification).call(this, name));

        _this.initialSpecification = initialSpecification;
        _this.manager = manager;
        return _this;
    }

    _createClass(ManagedUserLayerWithSpecification, [{
        key: 'toJSON',
        value: function toJSON() {
            var userLayer = this.layer;
            if (!userLayer) {
                return this.initialSpecification;
            }
            var layerSpec = userLayer.toJSON();
            if (!this.visible) {
                layerSpec['visible'] = false;
            }
            return layerSpec;
        }
    }]);

    return ManagedUserLayerWithSpecification;
}(layer_1.ManagedUserLayer);

exports.ManagedUserLayerWithSpecification = ManagedUserLayerWithSpecification;
;

var LayerListSpecification = function (_disposable_1$RefCoun) {
    _inherits(LayerListSpecification, _disposable_1$RefCoun);

    function LayerListSpecification(layerManager, chunkManager, worker, layerSelectedValues, voxelSize) {
        _classCallCheck(this, LayerListSpecification);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(LayerListSpecification).call(this));

        _this2.layerManager = layerManager;
        _this2.chunkManager = chunkManager;
        _this2.worker = worker;
        _this2.layerSelectedValues = layerSelectedValues;
        _this2.voxelSize = voxelSize;
        _this2.changed = new signals_1.Signal();
        _this2.registerSignalBinding(layerManager.layersChanged.add(_this2.changed.dispatch, _this2.changed));
        _this2.registerSignalBinding(layerManager.specificationChanged.add(_this2.changed.dispatch, _this2.changed));
        return _this2;
    }

    _createClass(LayerListSpecification, [{
        key: 'reset',
        value: function reset() {
            this.layerManager.clear();
        }
    }, {
        key: 'restoreState',
        value: function restoreState(x) {
            json_1.verifyObject(x);
            this.layerManager.clear();
            for (var key of Object.keys(x)) {
                this.layerManager.addManagedLayer(this.getLayer(key, x[key]));
            }
        }
    }, {
        key: 'getLayer',
        value: function getLayer(name, spec) {
            var managedLayer = new ManagedUserLayerWithSpecification(name, spec, this);
            if (typeof spec === 'string') {
                spec = { 'source': spec };
            }
            json_1.verifyObject(spec);
            var layerType = json_1.verifyObjectProperty(spec, 'type', json_1.verifyOptionalString);
            managedLayer.visible = json_1.verifyObjectProperty(spec, 'visible', x => {
                if (x === undefined || x === true) {
                    return true;
                }
                if (x === false) {
                    return false;
                }
                throw new Error(`Expected boolean, but received: ${ JSON.stringify(x) }.`);
            });
            var sourceUrl = managedLayer.sourceUrl = json_1.verifyObjectProperty(spec, 'source', json_1.verifyOptionalString);
            if (layerType === undefined) {
                if (sourceUrl === undefined) {
                    throw new Error(`Either layer 'type' or 'source' URL must be specified.`);
                }
                var volumeSourcePromise = getVolumeWithStatusMessage(sourceUrl);
                volumeSourcePromise.then(source => {
                    if (this.layerManager.managedLayers.indexOf(managedLayer) === -1) {
                        // Layer was removed before promise became ready.
                        return;
                    }
                    switch (source.volumeType) {
                        case base_1.VolumeType.IMAGE:
                            {
                                var userLayer = new image_user_layer_1.ImageUserLayer(this, spec);
                                managedLayer.layer = userLayer;
                            }
                            break;
                        case base_1.VolumeType.SEGMENTATION:
                            {
                                var _userLayer = new segmentation_user_layer_1.SegmentationUserLayer(this, spec);
                                managedLayer.layer = _userLayer;
                            }
                            break;
                        default:
                            throw new Error('Unsupported source type.');
                    }
                });
            } else {
                if (layerType === 'image') {
                    managedLayer.layer = new image_user_layer_1.ImageUserLayer(this, spec);
                } else if (layerType === 'segmentation') {
                    managedLayer.layer = new segmentation_user_layer_1.SegmentationUserLayer(this, spec);
                } else {
                    throw new Error('Layer type not specified.');
                }
            }
            return managedLayer;
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            var result = {};
            var numResults = 0;
            for (var managedLayer of this.layerManager.managedLayers) {
                result[managedLayer.name] = managedLayer.toJSON();
                ++numResults;
            }
            if (numResults === 0) {
                return undefined;
            }
            return result;
        }
    }]);

    return LayerListSpecification;
}(disposable_1.RefCounted);

exports.LayerListSpecification = LayerListSpecification;
;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

__webpack_require__(112);
var CodeMirror = __webpack_require__(113);
var debounce = __webpack_require__(43);
var layer_1 = __webpack_require__(42);
var layer_specification_1 = __webpack_require__(110);
var overlay_1 = __webpack_require__(105);
var image_renderlayer_1 = __webpack_require__(114);
var renderlayer_1 = __webpack_require__(66);
var disposable_1 = __webpack_require__(23);
var dom_1 = __webpack_require__(7);
var range_1 = __webpack_require__(116);
__webpack_require__(118);
__webpack_require__(119);
__webpack_require__(120);
__webpack_require__(121);
__webpack_require__(122);
__webpack_require__(123)(CodeMirror);
/**
 * Time in milliseconds during which the input field must not be modified before the shader is
 * recompiled.
 */
var SHADER_UPDATE_DELAY = 500;

var ImageUserLayer = function (_layer_1$UserLayer) {
    _inherits(ImageUserLayer, _layer_1$UserLayer);

    function ImageUserLayer(manager, x) {
        _classCallCheck(this, ImageUserLayer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ImageUserLayer).call(this));

        _this.opacity = renderlayer_1.trackableAlphaValue(0.5);
        _this.fragmentMain = image_renderlayer_1.getTrackableFragmentMain();
        var volumePath = x['source'];
        if (typeof volumePath !== 'string') {
            throw new Error('Invalid image layer specification');
        }
        _this.opacity.restoreState(x['opacity']);
        _this.fragmentMain.restoreState(x['shader']);
        _this.registerSignalBinding(_this.fragmentMain.changed.add(() => {
            _this.specificationChanged.dispatch();
        }));
        _this.volumePath = volumePath;
        var renderLayer = new image_renderlayer_1.ImageRenderLayer(manager.chunkManager, layer_specification_1.getVolumeWithStatusMessage(volumePath), _this.opacity, _this.fragmentMain);
        _this.renderLayer = renderLayer;
        _this.addRenderLayer(renderLayer);
        return _this;
    }

    _createClass(ImageUserLayer, [{
        key: 'toJSON',
        value: function toJSON() {
            var x = { 'type': 'image' };
            x['source'] = this.volumePath;
            x['opacity'] = this.opacity.toJSON();
            x['shader'] = this.fragmentMain.toJSON();
            return x;
        }
    }, {
        key: 'makeDropdown',
        value: function makeDropdown(element) {
            return new ImageDropdown(element, this);
        }
    }]);

    return ImageUserLayer;
}(layer_1.UserLayer);

exports.ImageUserLayer = ImageUserLayer;
;

var ShaderCodeWidget = function (_disposable_1$RefCoun) {
    _inherits(ShaderCodeWidget, _disposable_1$RefCoun);

    function ShaderCodeWidget(layer) {
        _classCallCheck(this, ShaderCodeWidget);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ShaderCodeWidget).call(this));

        _this2.layer = layer;
        _this2.changingValue = false;
        _this2.debouncedValueUpdater = debounce(() => {
            _this2.changingValue = true;
            try {
                _this2.layer.fragmentMain.value = _this2.textEditor.getValue();
            } finally {
                _this2.changingValue = false;
            }
        }, SHADER_UPDATE_DELAY);
        _this2.textEditor = CodeMirror(element => {}, {
            value: _this2.layer.fragmentMain.value,
            mode: 'glsl',
            gutters: ['CodeMirror-lint-markers']
        });
        _this2.textEditor.on('change', () => {
            _this2.setValidState(undefined);
            _this2.debouncedValueUpdater();
        });
        _this2.registerSignalBinding(_this2.layer.fragmentMain.changed.add(() => {
            if (!_this2.changingValue) {
                _this2.textEditor.setValue(_this2.layer.fragmentMain.value);
            }
        }));
        _this2.registerSignalBinding(_this2.layer.renderLayer.shaderError.changed.add(() => {
            _this2.updateErrorState();
        }));
        _this2.updateErrorState();
        return _this2;
    }

    _createClass(ShaderCodeWidget, [{
        key: 'updateErrorState',
        value: function updateErrorState() {
            if (this.layer.renderLayer.shaderUpdated) {
                this.setValidState(undefined);
            }
            var error = this.layer.renderLayer.shaderError.value;
            if (error !== undefined) {
                this.textEditor.setOption('lint', {
                    getAnnotations: () => {
                        if (error.name === 'ShaderCompilationError') {
                            var _ret = function () {
                                var fragmentMainStartLine = error.source.split('\n').indexOf(image_renderlayer_1.FRAGMENT_MAIN_START) + 2;
                                return {
                                    v: error.errorMessages.map(e => {
                                        return {
                                            message: e.message,
                                            severity: 'error',
                                            from: CodeMirror.Pos(e.line === undefined ? 0 : e.line - fragmentMainStartLine)
                                        };
                                    })
                                };
                            }();

                            if (typeof _ret === "object") return _ret.v;
                        } else if (error.name === 'ShaderLinkError') {
                            return [{
                                message: error.log,
                                severity: 'error',
                                from: CodeMirror.Pos(0)
                            }];
                        } else {
                            return [{
                                message: error.message,
                                severity: 'error',
                                from: CodeMirror.Pos(0)
                            }];
                        }
                    }
                });
                this.setValidState(false);
            } else {
                this.textEditor.setOption('lint', undefined);
                this.setValidState(true);
            }
        }
    }, {
        key: 'setValidState',
        value: function setValidState(valid) {
            var element = this.element;

            element.classList.remove('invalid-input');
            element.classList.remove('valid-input');
            if (valid === true) {
                element.classList.add('valid-input');
            } else if (valid === false) {
                element.classList.add('invalid-input');
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            this.debouncedValueUpdater.flush();
            this.debouncedValueUpdater = undefined;
            dom_1.removeFromParent(this.element);
            this.textEditor = undefined;
            _get(Object.getPrototypeOf(ShaderCodeWidget.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'element',
        get: function () {
            return this.textEditor.getWrapperElement();
        }
    }]);

    return ShaderCodeWidget;
}(disposable_1.RefCounted);

;

var ImageDropdown = function (_layer_1$UserLayerDro) {
    _inherits(ImageDropdown, _layer_1$UserLayerDro);

    function ImageDropdown(element, layer) {
        _classCallCheck(this, ImageDropdown);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(ImageDropdown).call(this));

        _this3.element = element;
        _this3.layer = layer;
        _this3.opacityWidget = _this3.registerDisposer(new range_1.RangeWidget(_this3.layer.opacity));
        _this3.codeWidget = _this3.registerDisposer(new ShaderCodeWidget(_this3.layer));
        element.classList.add('image-dropdown');
        var opacityWidget = _this3.opacityWidget;

        var topRow = document.createElement('div');
        topRow.className = 'image-dropdown-top-row';
        opacityWidget.promptElement.textContent = 'Opacity';
        var spacer = document.createElement('div');
        spacer.style.flex = '1';
        var helpLink = document.createElement('a');
        var helpButton = document.createElement('button');
        helpButton.type = 'button';
        helpButton.textContent = '?';
        helpButton.className = 'help-link';
        helpLink.appendChild(helpButton);
        helpLink.title = 'Documentation on image layer rendering';
        helpLink.target = '_blank';
        helpLink.href = 'https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md';
        var maximizeButton = document.createElement('button');
        maximizeButton.innerHTML = '&square;';
        maximizeButton.className = 'maximize-button';
        maximizeButton.title = 'Show larger editor view';
        _this3.registerEventListener(maximizeButton, 'click', () => {
            new ShaderCodeOverlay(_this3.layer);
        });
        topRow.appendChild(_this3.opacityWidget.element);
        topRow.appendChild(spacer);
        topRow.appendChild(maximizeButton);
        topRow.appendChild(helpLink);
        element.appendChild(topRow);
        element.appendChild(_this3.codeWidget.element);
        _this3.codeWidget.textEditor.refresh();
        return _this3;
    }

    _createClass(ImageDropdown, [{
        key: 'onShow',
        value: function onShow() {
            this.codeWidget.textEditor.refresh();
        }
    }]);

    return ImageDropdown;
}(layer_1.UserLayerDropdown);

;

var ShaderCodeOverlay = function (_overlay_1$Overlay) {
    _inherits(ShaderCodeOverlay, _overlay_1$Overlay);

    function ShaderCodeOverlay(layer) {
        _classCallCheck(this, ShaderCodeOverlay);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(ShaderCodeOverlay).call(this));

        _this4.layer = layer;
        _this4.codeWidget = _this4.registerDisposer(new ShaderCodeWidget(_this4.layer));
        _this4.content.classList.add('image-layer-shader-overlay');
        _this4.content.appendChild(_this4.codeWidget.element);
        _this4.codeWidget.textEditor.refresh();
        return _this4;
    }

    return ShaderCodeOverlay;
}(overlay_1.Overlay);

;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(113));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var GUTTER_ID = "CodeMirror-lint-markers";

  function showTooltip(e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));
    document.body.appendChild(tt);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(e, content, node) {
    var tooltip = showTooltip(e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0
  }

  function parseOptions(_cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function makeMarker(labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message-" + severity;
    tip.appendChild(document.createTextNode(ann.message));
    return tip;
  }

  function lintAsync(cm, getAnnotations, passOptions) {
    var state = cm.state.lint
    var id = ++state.waitingFor
    function abort() {
      id = -1
      cm.off("change", abort)
    }
    cm.on("change", abort)
    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort)
      if (state.waitingFor != id) return
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
      updateLinting(cm, annotations)
    }, passOptions, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint, options = state.options;
    var passOptions = options.options || options; // Support deprecated passing of `options` property in options
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations, passOptions)
    } else {
      updateLinting(cm, getAnnotations(cm.getValue(), passOptions, cm));
    }
  }

  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint, options = state.options;

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }

      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
                                                       state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
  }

  function popupTooltips(annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i < annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(e, tooltip, target);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

    var annotations = [];
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(annotations, e);
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      if (state.options.lintOnChange !== false)
        cm.on("change", onChange);
      if (state.options.tooltips != false)
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    if (this.state.lint) startLinting(this);
  });
});


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (true) // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    (this || window).CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) display.input.focus();
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    var cm = this;

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) options.finishInit(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      display.lineDiv.style.textRendering = "auto";
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) this.zeroWidthHack();
        this.checkedZeroWidth = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);
    },
    zeroWidthHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed;
      this.disableVert = new Delayed;
    },
    enableZeroWidthBar: function(bar, delay) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        // To find out whether the scrollbar is still visible, we
        // check whether the element under the pixel in the bottom
        // left corner of the scrollbar box is the scrollbar box
        // itself (when the bar is still visible) or its filler child
        // (when the bar is hidden). If it is still visible, we keep
        // it enabled, if it's hidden, we disable pointer events.
        var box = bar.getBoundingClientRect();
        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
        if (elt != bar) bar.style.pointerEvents = "none";
        else delay.set(1000, maybeDisable);
      }
      delay.set(1000, maybeDisable);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function(emitter, type) {
    if (hasHandler(emitter, type))
      this.events.push(arguments);
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i = 0; i < this.events.length; i++)
      signal.apply(null, this.events[i]);
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                      "px; width: " + dims.gutterTotalWidth + "px");
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // INPUT HANDLING

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) sel = doc.sel;

    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = doc.splitLines(inserted), multiPaste = null
    // When pasing N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
        }
      } else if (textLines.length == sel.ranges.length) {
        multiPaste = map(textLines, function(l) { return [l]; });
      }
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          from = Pos(from.line, from.ch - deleted);
        else if (cm.state.overwrite && !paste) // Handle overwrite
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
          from = to = Pos(from.line, 0)
      }
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      triggerElectric(cm, inserted);

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) return;
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break;
          }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          indented = indentLine(cm, range.head.line, "smart");
      }
      if (indented) signalLater(cm, "electricInput", cm, range.head.line);
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges};
  }

  function disableBrowserMagic(field) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", "false");
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) te.style.width = "1000px";
    else te.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) te.style.border = "1px solid black";
    disableBrowserMagic(te);
    return div;
  }

  TextareaInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) te.style.width = "0px";

      on(te, "input", function() {
        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
        input.poll();
      });

      on(te, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return

        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = {lineWise: false, text: cm.getSelections()};
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.text.join("\n");
            selectInput(te);
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = {lineWise: true, text: ranges.text};
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) e_preventDefault(e);
      });

      on(te, "compositionstart", function() {
        var start = cm.getCursor("from");
        if (input.composing) input.composing.range.clear()
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
        };
      });
      on(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    },

    prepareSelection: function() {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function(typing) {
      if (this.contextMenuPending) return;
      var minimal, selected, cm = this.cm, doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) selectInput(this.textarea);
        if (ie && ie_version >= 9) this.hasSelection = content;
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) this.hasSelection = null;
      }
      this.inaccurateSelection = minimal;
    },

    getField: function() { return this.textarea; },

    supportsTouch: function() { return false; },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function() { this.textarea.blur(); },

    resetPosition: function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function() { this.slowPoll(); },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function() {
      var input = this;
      if (input.pollingFast) return;
      input.polling.set(this.cm.options.pollInterval, function() {
        input.poll();
        if (input.cm.state.focused) input.slowPoll();
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function() {
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (this.contextMenuPending || !cm.state.focused ||
          (hasSelection(input) && !prevInput && !this.composing) ||
          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
        return false;

      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 0x200b && !prevInput) prevInput = "\u200b";
        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      var self = this;
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same,
                       null, self.composing ? "*compose" : null);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
        else self.prevInput = text;

        if (self.composing) {
          self.composing.range.clear();
          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
                                             {className: "CodeMirror-composing"});
        }
      });
      return true;
    },

    ensurePolled: function() {
      if (this.pollingFast && this.poll()) this.pollingFast = false;
    },

    onKeyPress: function() {
      if (ie && ie_version >= 9) this.hasSelection = null;
      this.fastPoll();
    },

    onContextMenu: function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      input.wrapper.style.cssText = "position: absolute"
      var wrapperBox = input.wrapper.getBoundingClientRect()
      te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) +
        "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) window.scrollTo(null, oldScrollY);
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200b" + (selected ? te.value : "");
          te.value = "\u21da"; // Used to catch context-menu undo
          te.value = extval;
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                te.selectionEnd > 0 && input.prevInput == "\u200b")
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else display.input.reset();
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    readOnlyChanged: function(val) {
      if (!val) this.reset();
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.gracePeriod = false;
  }

  ContentEditableInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      disableBrowserMagic(div);

      on(div, "paste", function(e) {
        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);
      })

      on(div, "compositionstart", function(e) {
        var data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        if (!data) return;
        var prim = cm.doc.sel.primary();
        var line = cm.getLine(prim.head.line);
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
        if (found > -1 && found <= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, "compositionupdate", function(e) {
        input.composing.data = e.data;
      });
      on(div, "compositionend", function(e) {
        var ours = input.composing;
        if (!ours) return;
        if (e.data != ours.startData && !/\u200b/.test(e.data))
          ours.data = e.data;
        // Need a small delay to prevent other code (input event,
        // selection polling) from doing damage when fired right after
        // compositionend.
        setTimeout(function() {
          if (!ours.handled)
            input.applyComposition(ours);
          if (input.composing == ours)
            input.composing = null;
        }, 50);
      });

      on(div, "touchstart", function() {
        input.forceCompositionEnd();
      });

      on(div, "input", function() {
        if (input.composing) return;
        if (cm.isReadOnly() || !input.pollContent())
          runInOp(input.cm, function() {regChange(cm);});
      });

      function onCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = {lineWise: false, text: cm.getSelections()};
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = {lineWise: true, text: ranges.text};
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        if (e.clipboardData && !ios) {
          e.preventDefault();
          e.clipboardData.clearData();
          e.clipboardData.setData("text/plain", lastCopied.text.join("\n"));
        } else {
          // Old-fashioned briefly-focus-a-textarea hack
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.text.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
          }, 50);
        }
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function() {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function(info, takeFocus) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus || takeFocus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function() {
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
        return;

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) return;

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = {node: view[0].measure.map[2], offset: 0};
      } else if (!end) { // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
      }

      try { var rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        if (!gecko && this.cm.state.focused) {
          sel.collapse(start.node, start.offset);
          if (!rng.collapsed) sel.addRange(rng);
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) sel.addRange(old);
        else if (gecko) this.startGracePeriod();
      }
      this.rememberSelection();
    },

    startGracePeriod: function() {
      var input = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        input.gracePeriod = false;
        if (input.selectionChanged())
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
      }, 20);
    },

    showMultipleSelections: function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function() {
      var sel = window.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor") this.div.focus();
    },
    blur: function() { this.div.blur(); },
    getField: function() { return this.div; },

    supportsTouch: function() { return true; },

    receivedFocus: function() {
      var input = this;
      if (this.selectionInEditor())
        this.pollSelection();
      else
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function() {
      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(), cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
        });
      }
    },

    pollContent: function() {
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

      var fromIndex;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        var fromLine = lineNo(display.view[0].line);
        var fromNode = display.view[0].node;
      } else {
        var fromLine = lineNo(display.view[fromIndex].line);
        var fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      if (toIndex == display.view.length - 1) {
        var toLine = display.viewTo - 1;
        var toNode = display.lineDiv.lastChild;
      } else {
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
        var toNode = display.view[toIndex + 1].node.previousSibling;
      }

      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else break;
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        ++cutEnd;

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
      newText[0] = newText[0].slice(cutFront);

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function() {
      this.forceCompositionEnd();
    },
    reset: function() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function() {
      if (!this.composing || this.composing.handled) return;
      this.applyComposition(this.composing);
      this.composing.handled = true;
      this.div.blur();
      this.div.focus();
    },
    applyComposition: function(composing) {
      if (this.cm.isReadOnly())
        operation(this.cm, regChange)(this.cm)
      else if (composing.data && composing.data != composing.startData)
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
    },

    setUneditable: function(node) {
      node.contentEditable = "false"
    },

    onKeyPress: function(e) {
      e.preventDefault();
      if (!this.cm.isReadOnly())
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    },

    readOnlyChanged: function(val) {
      this.div.contentEditable = String(val != "nocursor")
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) return null;
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) return null;
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        return locateNodeInLineView(lineView, node, offset);
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) offset = textNode.nodeValue.length;
    }
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) return badPos(found, bad);

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        return badPos(Pos(found.line, found.ch - dist), bad);
      else
        dist += after.textContent.length;
    }
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        return badPos(Pos(found.line, found.ch + dist), bad);
      else
        dist += after.textContent.length;
    }
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator();
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
          text += cmText;
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find()))
            text += getBetween(cm.doc, range.from, range.to).join(lineSep);
          return;
        }
        if (node.getAttribute("contenteditable") == "false") return;
        for (var i = 0; i < node.childNodes.length; i++)
          walk(node.childNodes[i]);
        if (/^(pre|div|p)$/i.test(node.nodeName))
          closing = true;
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) return;
        if (closing) {
          text += lineSep;
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) break;
      from = from.nextSibling;
    }
    return text;
  }

  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel, options);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;
      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) break;
            else {--i; continue;}
          }
        }
        if (!m.atomic) continue;

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff;
          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            return skipAtomicInner(doc, near, pos, dir, mayClear);
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
          far = movePos(doc, far, dir, far.line == pos.line ? line : null);
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));
      else return null;
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);
      else return null;
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  // SELECTION DRAWING

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) continue;
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range.head, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else if (ie && cm.options.lineWrapping) {
          var rects = range(node, start, end).getClientRects();
          if (rects.length)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = nullRect;
        } else {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var outside = ch == from ? fromOutside : toOutside
        var xDiff = x - (ch == from ? fromX : toX);
        // This is a kludge to handle the case where the coordinates
        // are after a line-wrapped line. We should replace it with a
        // more general handling of cursor positions around line
        // breaks. (Issue #4078)
        if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&
            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
          var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right");
          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
            outside = false
            ch++
            xDiff = x - charSize.right
          }
        }
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i].call(null);
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection(op.focus);
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())
    if (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      cm.display.input.reset(op.typing);
    if (takeFocus) ensureFocus(op.cm);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (op.update)
      op.update.finish();
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    };
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) return false;
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) return true;
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) d.activeTouch.moved = true;
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          range = new Range(pos, pos);
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          range = cm.findWordAt(pos);
        else // Triple tap
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function(e){onDragStart(cm, e);},
      drop: operation(cm, onDrop),
      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", bind(onFocus, cm));
    on(inp, "blur", bind(onBlur, cm));
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != CodeMirror.Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      // #3261: make sure, that we're not starting a second selection
      if (cm.state.selectingText)
        cm.state.selectingText(e);
      else if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(function() {display.input.focus();}, 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      else delayBlurEvent(cm);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) setTimeout(bind(ensureFocus, cm), 0);
    else cm.curOp.focus = activeElt();

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
        (cmp(contained.to(), start) > 0 || start.xRel < 0))
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display, startTime = +new Date;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier && +new Date - 200 < startTime)
          extendSelection(cm.doc, start);
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
        else
          display.input.focus();
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    dragEnd.copy = mac ? e.altKey : e.ctrlKey
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          return;

        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove"

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) return;
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = doc.splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return false
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return false
      } else ch = next;
      return true;
    }

    if (unit == "char") {
      moveOnce()
    } else if (unit == "column") {
      moveOnce(true)
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
    if (!cmp(pos, result)) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd].call(null, this);
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("lineSeparator", null, function(cm, val) {
    cm.doc.lineSep = val;
    if (!val) return;
    var newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(function(line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos);
        if (found == -1) break;
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    for (var i = newBreaks.length - 1; i >= 0; i--)
      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
  });
  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
    }
    cm.display.input.readOnlyChanged(val)
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true, dragDropChanged);
  option("allowDropFileTypes", null);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function(cm) {cm.replaceSelection("\n", "start")},
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var state = getStateBefore(cm, lineNo(line));
      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
      line.stateAfter = state;
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol()) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        builder.content.className = "cm-tab-wrap-hack";
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(old) {
    var out = " ";
    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
    out += " ";
    return out;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = (css ? css + ";" : "") + m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)
          if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]

        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
          if (collapsed.to == pos) collapsed = false;
        }
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.extend = false;

    if (typeof text == "string") text = this.splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || this.lineSeparator());
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function(line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + sepSize;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;},

    splitLines: function(str) {
      if (this.lineSep) return str.split(this.lineSep);
      return splitLinesAuto(str);
    },
    lineSeparator: function() { return this.lineSep || "\n"; }
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var noHandlers = []
  function getHandlers(emitter, type, copy) {
    var arr = emitter._handlers && emitter._handlers[type]
    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers
    else return arr || noHandlers
  }

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var handlers = getHandlers(emitter, type, false)
      for (var i = 0; i < handlers.length; ++i)
        if (handlers[i] == f) { handlers.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type, true)
    if (!handlers.length) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type, false)
    if (!arr.length) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  var contains = CodeMirror.contains = function(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      child = child.parentNode;
    if (parent.contains)
      return parent.contains(child);
    do {
      if (child.nodeType == 11) child = child.host;
      if (child == parent) return true;
    } while (child = child.parentNode);
  };

  function activeElt() {
    var activeElement = document.activeElement;
    while (activeElement && activeElement.root && activeElement.root.activeElement)
      activeElement = activeElement.root.activeElement;
    return activeElement;
  }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = CodeMirror.keyNames = {
    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level == 2)
        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "5.16.0";

  return CodeMirror;
});


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var renderlayer_1 = __webpack_require__(66);
var trackable_value_1 = __webpack_require__(67);
var json_1 = __webpack_require__(8);
exports.FRAGMENT_MAIN_START = '//NEUROGLANCER_IMAGE_RENDERLAYER_FRAGMENT_MAIN_START';
var DEFAULT_FRAGMENT_MAIN = `void main() {
  emitGrayscale(toNormalized(getDataValue()));
}
`;
var glsl_COLORMAPS = __webpack_require__(115);
function getTrackableFragmentMain() {
    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_FRAGMENT_MAIN : arguments[0];

    return new trackable_value_1.TrackableValue(value, json_1.verifyString);
}
exports.getTrackableFragmentMain = getTrackableFragmentMain;

var ImageRenderLayer = function (_renderlayer_1$Render) {
    _inherits(ImageRenderLayer, _renderlayer_1$Render);

    function ImageRenderLayer(chunkManager, multiscaleSourcePromise) {
        var opacity = arguments.length <= 2 || arguments[2] === undefined ? renderlayer_1.trackableAlphaValue(0.5) : arguments[2];
        var fragmentMain = arguments.length <= 3 || arguments[3] === undefined ? getTrackableFragmentMain() : arguments[3];

        _classCallCheck(this, ImageRenderLayer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ImageRenderLayer).call(this, chunkManager, multiscaleSourcePromise));

        _this.opacity = opacity;
        _this.fragmentMain = fragmentMain;
        _this.registerSignalBinding(opacity.changed.add(() => {
            _this.redrawNeeded.dispatch();
        }));
        _this.registerSignalBinding(fragmentMain.changed.add(() => {
            _this.shaderUpdated = true;
            _this.redrawNeeded.dispatch();
        }));
        return _this;
    }

    _createClass(ImageRenderLayer, [{
        key: 'getShaderKey',
        value: function getShaderKey() {
            return `sliceview.ImageRenderLayer:${ JSON.stringify(this.fragmentMain.value) }`;
        }
    }, {
        key: 'defineShader',
        value: function defineShader(builder) {
            _get(Object.getPrototypeOf(ImageRenderLayer.prototype), 'defineShader', this).call(this, builder);
            builder.addUniform('highp float', 'uOpacity');
            builder.addFragmentCode(`
void emitRGBA(vec4 rgba) {
  emit(vec4(rgba.rgb, rgba.a * uOpacity));
}
void emitRGB(vec3 rgb) {
  emit(vec4(rgb, uOpacity));
}
void emitGrayscale(float value) {
  emit(vec4(value, value, value, uOpacity));
}
void emitTransparent() {
  emit(vec4(0.0, 0.0, 0.0, 0.0));
}
`);
            builder.addFragmentCode(glsl_COLORMAPS);
            builder.setFragmentMainFunction(exports.FRAGMENT_MAIN_START + '\n' + this.fragmentMain.value);
        }
    }, {
        key: 'beginSlice',
        value: function beginSlice(sliceView) {
            var shader = _get(Object.getPrototypeOf(ImageRenderLayer.prototype), 'beginSlice', this).call(this, sliceView);
            var gl = this.gl;

            gl.uniform1f(shader.uniform('uOpacity'), this.opacity.value);
            return shader;
        }
    }]);

    return ImageRenderLayer;
}(renderlayer_1.RenderLayer);

exports.ImageRenderLayer = ImageRenderLayer;
;

/***/ },
/* 115 */
/***/ function(module, exports) {

module.exports = "/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvec3 colormapJet(float x) {\n  vec3 result;\n  result.r = x < 0.89 ? ((x - 0.35) / 0.31) : (1.0 - (x - 0.89) / 0.11 * 0.5);\n  result.g = x < 0.64 ? ((x - 0.125) * 4.0) : (1.0 - (x - 0.64) / 0.27);\n  result.b = x < 0.34 ? (0.5 + x * 0.5 / 0.11) : (1.0 - (x - 0.34) / 0.31);\n  return clamp(result, 0.0, 1.0);\n}\n"

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var dom_1 = __webpack_require__(7);
__webpack_require__(117);

var RangeWidget = function (_disposable_1$RefCoun) {
    _inherits(RangeWidget, _disposable_1$RefCoun);

    function RangeWidget(value) {
        var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var _ref$min = _ref.min;
        var min = _ref$min === undefined ? 0 : _ref$min;
        var _ref$max = _ref.max;
        var max = _ref$max === undefined ? 1 : _ref$max;
        var _ref$step = _ref.step;
        var step = _ref$step === undefined ? 0.01 : _ref$step;

        _classCallCheck(this, RangeWidget);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RangeWidget).call(this));

        _this.value = value;
        _this.element = document.createElement('label');
        _this.promptElement = document.createElement('span');
        _this.inputElement = document.createElement('input');
        var element = _this.element;
        var promptElement = _this.promptElement;
        var inputElement = _this.inputElement;

        element.className = 'range-slider';
        promptElement.className = 'range-prompt';
        inputElement.type = 'range';
        inputElement.min = '' + min;
        inputElement.max = '' + max;
        inputElement.step = '' + step;
        inputElement.valueAsNumber = _this.value.value;
        element.appendChild(promptElement);
        element.appendChild(inputElement);
        var inputValueChanged = () => {
            _this.value.value = _this.inputElement.valueAsNumber;
        };
        _this.registerEventListener(inputElement, 'change', inputValueChanged);
        _this.registerEventListener(inputElement, 'input', inputValueChanged);
        _this.registerEventListener(inputElement, 'wheel', event => {
            var deltaY = event.deltaY;

            if (deltaY > 0) {
                _this.inputElement.stepUp();
                inputValueChanged();
            } else if (deltaY < 0) {
                _this.inputElement.stepDown();
                inputValueChanged();
            }
        });
        value.changed.add(() => {
            _this.inputElement.valueAsNumber = _this.value.value;
        });
        return _this;
    }

    _createClass(RangeWidget, [{
        key: 'disposed',
        value: function disposed() {
            dom_1.removeFromParent(this.element);
            _get(Object.getPrototypeOf(RangeWidget.prototype), 'disposed', this).call(this);
        }
    }]);

    return RangeWidget;
}(disposable_1.RefCounted);

exports.RangeWidget = RangeWidget;
;

/***/ },
/* 117 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 118 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 119 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 120 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 121 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 122 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 123 */
/***/ function(module, exports) {

module.exports = function(CodeMirror) {
  CodeMirror.defineMode("glsl", function(config, parserConfig) {
    var indentUnit = config.indentUnit,
        keywords = parserConfig.keywords || words(glslKeywords),
        builtins = parserConfig.builtins || words(glslBuiltins),
        blockKeywords = parserConfig.blockKeywords || words("case do else for if switch while struct"),
        atoms = parserConfig.atoms || words("null"),
        hooks = parserConfig.hooks || {},
        multiLineStrings = parserConfig.multiLineStrings;
    var isOperatorChar = /[+\-*&%=<>!?|\/]/;

    var curPunc;

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        curPunc = ch;
        return "bracket";
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (ch == "#") {
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        return "comment";
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      stream.eatWhile(/[\w\$_]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) {
        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
        return "keyword";
      }
      if (builtins.propertyIsEnumerable(cur)) {
        return "builtin";
      }
      if (atoms.propertyIsEnumerable(cur)) return "atom";
      return "word";
    }

    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) {end = true; break;}
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = tokenBase;
        return "string";
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }

    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      return state.context = new Context(state.indented, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    // Interface

    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },

      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment" || style == "meta") return style;
        if (ctx.align == null) ctx.align = true;

        if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
          pushContext(state, stream.column(), "statement");
        state.startOfLine = false;
        return style;
      },

      indent: function(state, textAfter) {
        if (state.tokenize != tokenBase && state.tokenize != null) return 0;
        var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
        if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
        else if (ctx.align) return ctx.column + (closing ? 0 : 1);
        else return ctx.indented + (closing ? 0 : indentUnit);
      },

      electricChars: "{}"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var glslKeywords = "attribute const uniform varying break continue " +
    "do for while if else in out inout float int void bool true false " +
    "lowp mediump highp precision invariant discard return mat2 mat3 " +
    "mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D " +
    "samplerCube struct gl_FragCoord gl_FragColor";
  var glslBuiltins = "radians degrees sin cos tan asin acos atan pow " +
    "exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod " +
    "min max clamp mix step smoothstep length distance dot cross " +
    "normalize faceforward reflect refract matrixCompMult lessThan " +
    "lessThanEqual greaterThan greaterThanEqual equal notEqual any all " +
    "not dFdx dFdy fwidth texture2D texture2DProj texture2DLod " +
    "texture2DProjLod textureCube textureCubeLod require export";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    stream.skipToEnd();
    return "meta";
  }

  ;(function() {
    // C#-style strings where "" escapes a quote.
    function tokenAtString(stream, state) {
      var next;
      while ((next = stream.next()) != null) {
        if (next == '"' && !stream.eat('"')) {
          state.tokenize = null;
          break;
        }
      }
      return "string";
    }

    CodeMirror.defineMIME("text/x-glsl", {
      name: "glsl",
      keywords: words(glslKeywords),
      builtins: words(glslBuiltins),
      blockKeywords: words("case do else for if switch while struct"),
      atoms: words("null"),
      hooks: {"#": cppHook}
    });
  }());
}


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var factory_1 = __webpack_require__(28);
var layer_1 = __webpack_require__(42);
var layer_specification_1 = __webpack_require__(110);
var frontend_1 = __webpack_require__(30);
var segment_color_1 = __webpack_require__(125);
var frontend_2 = __webpack_require__(75);
var shared_disjoint_sets_1 = __webpack_require__(130);
var frontend_3 = __webpack_require__(77);
var renderlayer_1 = __webpack_require__(66);
var segmentation_renderlayer_1 = __webpack_require__(132);
var uint64_set_1 = __webpack_require__(133);
var json_1 = __webpack_require__(8);
var uint64_1 = __webpack_require__(52);
var range_1 = __webpack_require__(116);
var segment_set_widget_1 = __webpack_require__(134);
var uint64_entry_widget_1 = __webpack_require__(136);
__webpack_require__(138);

var SegmentationUserLayer = function (_layer_1$UserLayer) {
    _inherits(SegmentationUserLayer, _layer_1$UserLayer);

    function SegmentationUserLayer(manager, x) {
        _classCallCheck(this, SegmentationUserLayer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SegmentationUserLayer).call(this, []));

        _this.manager = manager;
        _this.segmentColorHash = segment_color_1.SegmentColorHash.getDefault();
        _this.segmentSelectionState = new frontend_2.SegmentSelectionState();
        _this.selectedAlpha = renderlayer_1.trackableAlphaValue(0.5);
        _this.notSelectedAlpha = renderlayer_1.trackableAlphaValue(0);
        _this.visibleSegments = uint64_set_1.Uint64Set.makeWithCounterpart(_this.manager.worker);
        _this.segmentEquivalences = shared_disjoint_sets_1.SharedDisjointUint64Sets.makeWithCounterpart(_this.manager.worker);
        _this.wasDisposed = false;
        _this.visibleSegments.changed.add(() => {
            _this.specificationChanged.dispatch();
        });
        _this.segmentEquivalences.changed.add(() => {
            _this.specificationChanged.dispatch();
        });
        _this.segmentSelectionState.bindTo(manager.layerSelectedValues, _this);
        _this.selectedAlpha.changed.add(() => {
            _this.specificationChanged.dispatch();
        });
        _this.notSelectedAlpha.changed.add(() => {
            _this.specificationChanged.dispatch();
        });
        _this.selectedAlpha.restoreState(x['selectedAlpha']);
        _this.notSelectedAlpha.restoreState(x['notSelectedAlpha']);
        var volumePath = _this.volumePath = json_1.verifyOptionalString(x['source']);
        var meshPath = _this.meshPath = json_1.verifyOptionalString(x['mesh']);
        var skeletonsPath = _this.skeletonsPath = json_1.verifyOptionalString(x['skeletons']);
        if (volumePath !== undefined) {
            var volumePromise = layer_specification_1.getVolumeWithStatusMessage(volumePath);
            volumePromise.then(volume => {
                if (!_this.wasDisposed) {
                    if (!_this.meshLayer) {
                        var meshSource = volume.getMeshSource(_this.manager.chunkManager);
                        if (meshSource != null) {
                            _this.addMesh(meshSource);
                        }
                    }
                }
            });
            _this.addRenderLayer(new segmentation_renderlayer_1.SegmentationRenderLayer(manager.chunkManager, volumePromise, _this, _this.selectedAlpha, _this.notSelectedAlpha));
        }
        if (meshPath !== undefined) {
            var meshLod = x['meshLod'];
            if (typeof meshLod !== 'number') {
                meshLod = undefined;
            }
            _this.meshLod = meshLod;
            _this.addMesh(factory_1.getMeshSource(manager.chunkManager, meshPath, meshLod));
        }
        if (skeletonsPath !== undefined) {
            var base = new frontend_3.SkeletonLayer(manager.chunkManager, factory_1.getSkeletonSource(manager.chunkManager, skeletonsPath), manager.voxelSize, _this);
            _this.addRenderLayer(new frontend_3.PerspectiveViewSkeletonLayer(base));
            _this.addRenderLayer(new frontend_3.SliceViewPanelSkeletonLayer(base));
        }
        json_1.verifyObjectProperty(x, 'equivalences', y => {
            _this.segmentEquivalences.restoreState(y);
        });
        json_1.verifyObjectProperty(x, 'segments', y => {
            if (y !== undefined) {
                (function () {
                    var visibleSegments = _this.visibleSegments;
                    var segmentEquivalences = _this.segmentEquivalences;

                    json_1.parseArray(y, value => {
                        var id = uint64_1.Uint64.parseString(String(value), 10);
                        visibleSegments.add(segmentEquivalences.get(id));
                    });
                })();
            }
        });
        return _this;
    }

    _createClass(SegmentationUserLayer, [{
        key: 'disposed',
        value: function disposed() {
            _get(Object.getPrototypeOf(SegmentationUserLayer.prototype), 'disposed', this).call(this);
            this.wasDisposed = true;
        }
    }, {
        key: 'addMesh',
        value: function addMesh(meshSource) {
            this.meshLayer = new frontend_1.MeshLayer(this.manager.chunkManager, meshSource, this);
            this.addRenderLayer(this.meshLayer);
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            var x = { 'type': 'segmentation' };
            x['source'] = this.volumePath;
            x['mesh'] = this.meshPath;
            x['meshLod'] = this.meshLod;
            x['skeletons'] = this.skeletonsPath;
            x['selectedAlpha'] = this.selectedAlpha.toJSON();
            x['notSelectedAlpha'] = this.notSelectedAlpha.toJSON();
            var visibleSegments = this.visibleSegments;

            if (visibleSegments.size > 0) {
                x['segments'] = visibleSegments.toJSON();
            }
            var segmentEquivalences = this.segmentEquivalences;

            if (segmentEquivalences.size > 0) {
                x['equivalences'] = segmentEquivalences.toJSON();
            }
            return x;
        }
    }, {
        key: 'transformPickedValue',
        value: function transformPickedValue(value) {
            if (value == null) {
                return value;
            }
            var segmentEquivalences = this.segmentEquivalences;

            if (segmentEquivalences.size === 0) {
                return value;
            }
            if (typeof value === 'number') {
                value = new uint64_1.Uint64(value, 0);
            }
            var mappedValue = segmentEquivalences.get(value);
            if (uint64_1.Uint64.equal(mappedValue, value)) {
                return value;
            }
            return new frontend_2.Uint64MapEntry(value, mappedValue);
        }
    }, {
        key: 'makeDropdown',
        value: function makeDropdown(element) {
            return new SegmentationDropdown(element, this);
        }
    }, {
        key: 'handleAction',
        value: function handleAction(action) {
            switch (action) {
                case 'recolor':
                    {
                        this.segmentColorHash.randomize();
                        break;
                    }
                case 'clear-segments':
                    {
                        this.visibleSegments.clear();
                        break;
                    }
                case 'select':
                    {
                        var segmentSelectionState = this.segmentSelectionState;

                        if (segmentSelectionState.hasSelectedSegment) {
                            var segment = segmentSelectionState.selectedSegment;
                            var visibleSegments = this.visibleSegments;

                            if (visibleSegments.has(segment)) {
                                visibleSegments.delete(segment);
                            } else {
                                visibleSegments.add(segment);
                            }
                        }
                        break;
                    }
            }
        }
    }]);

    return SegmentationUserLayer;
}(layer_1.UserLayer);

exports.SegmentationUserLayer = SegmentationUserLayer;
;

var SegmentationDropdown = function (_layer_1$UserLayerDro) {
    _inherits(SegmentationDropdown, _layer_1$UserLayerDro);

    function SegmentationDropdown(element, layer) {
        _classCallCheck(this, SegmentationDropdown);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SegmentationDropdown).call(this));

        _this2.element = element;
        _this2.layer = layer;
        _this2.visibleSegmentWidget = _this2.registerDisposer(new segment_set_widget_1.SegmentSetWidget(_this2.layer));
        _this2.addSegmentWidget = _this2.registerDisposer(new uint64_entry_widget_1.Uint64EntryWidget());
        _this2.selectedAlphaWidget = _this2.registerDisposer(new range_1.RangeWidget(_this2.layer.selectedAlpha));
        _this2.notSelectedAlphaWidget = _this2.registerDisposer(new range_1.RangeWidget(_this2.layer.notSelectedAlpha));
        element.classList.add('segmentation-dropdown');
        var selectedAlphaWidget = _this2.selectedAlphaWidget;
        var notSelectedAlphaWidget = _this2.notSelectedAlphaWidget;

        selectedAlphaWidget.promptElement.textContent = 'Opacity (on)';
        notSelectedAlphaWidget.promptElement.textContent = 'Opacity (off)';
        element.appendChild(_this2.selectedAlphaWidget.element);
        element.appendChild(_this2.notSelectedAlphaWidget.element);
        _this2.addSegmentWidget.element.classList.add('add-segment');
        _this2.addSegmentWidget.element.title = 'Add segment ID';
        element.appendChild(_this2.registerDisposer(_this2.addSegmentWidget).element);
        _this2.registerSignalBinding(_this2.addSegmentWidget.valueEntered.add(value => {
            _this2.layer.visibleSegments.add(value);
        }));
        element.appendChild(_this2.registerDisposer(_this2.visibleSegmentWidget).element);
        return _this2;
    }

    return SegmentationDropdown;
}(layer_1.UserLayerDropdown);

;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var hash_function_1 = __webpack_require__(126);
var shader_1 = __webpack_require__(127);
var colorspace_1 = __webpack_require__(129);
var shader_lib_1 = __webpack_require__(72);
var signals_1 = __webpack_require__(34);
var NUM_COMPONENTS = 2;

var SegmentColorShaderManager = function () {
    function SegmentColorShaderManager(prefix) {
        _classCallCheck(this, SegmentColorShaderManager);

        this.prefix = prefix;
        this.aName = this.prefix + '_a';
        this.bName = this.prefix + '_b';
    }

    _createClass(SegmentColorShaderManager, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            var aName = this.aName;
            var bName = this.bName;

            builder.addUniform('highp vec4', aName, 2 * NUM_COMPONENTS);
            builder.addUniform('highp float', bName, 2 * NUM_COMPONENTS);
            builder.addFragmentCode(shader_lib_1.glsl_uint64);
            builder.addFragmentCode(shader_1.glsl_hashFunction);
            builder.addFragmentCode(shader_lib_1.glsl_hsvToRgb);
            var s = `
vec3 ${ this.prefix }(uint64_t x) {
  vec${ NUM_COMPONENTS } v;
  float primeModulus = float(${ hash_function_1.PRIME_MODULUS });
`;
            for (var i = 0; i < NUM_COMPONENTS; ++i) {
                var bIndex = 2 * i;
                var aIndex = 2 * i;
                s += `
  v[${ i }] = computeHash(x, ${ aName }[${ aIndex }], ${ aName }[${ aIndex + 1 }], ${ bName }[${ bIndex }], ${ bName }[${ bIndex + 1 }], primeModulus, 1.0 / 256.0);
`;
            }
            s += `
  vec3 hsv = vec3(v.x, 0.5 + v.y * 0.5, 1.0);
  return hsvToRgb(hsv);
}
`;
            builder.addFragmentCode(s);
        }
    }, {
        key: 'enable',
        value: function enable(gl, shader, segmentColorHash) {
            gl.uniform4fv(shader.uniform(this.aName), segmentColorHash.a_);
            gl.uniform1fv(shader.uniform(this.bName), segmentColorHash.b_);
        }
    }]);

    return SegmentColorShaderManager;
}();

exports.SegmentColorShaderManager = SegmentColorShaderManager;
;
function fract(x) {
    return x - Math.floor(x);
}
var tempOutput = new Float32Array(NUM_COMPONENTS);
var tempColor = new Float32Array(3);

var SegmentColorHash = function () {
    function SegmentColorHash(hashFunctions) {
        _classCallCheck(this, SegmentColorHash);

        this.a_ = new Float32Array(4 * 2 * NUM_COMPONENTS);
        this.b_ = new Float32Array(2 * NUM_COMPONENTS);
        this.changed = new signals_1.Signal();
        if (hashFunctions == null) {
            this.hashFunctions = new Array(NUM_COMPONENTS);
            this.randomize_();
        } else {
            this.hashFunctions = hashFunctions;
        }
        this.computeGPUCoefficients_();
    }

    _createClass(SegmentColorHash, [{
        key: 'compute',
        value: function compute(out, x) {
            var low = x.low;
            var high = x.high;
            var hashFunctions = this.hashFunctions;

            for (var i = 0; i < 2; ++i) {
                tempOutput[i] = fract(hashFunctions[i].compute(low, high) / 256.0);
            }
            colorspace_1.hsvToRgb(out, tempOutput[0], 0.5 + 0.5 * tempOutput[1], 1.0);
            return out;
        }
    }, {
        key: 'computeCssColor',
        value: function computeCssColor(x) {
            this.compute(tempColor, x);
            return `rgb(${ tempColor[0] * 100 }%,${ tempColor[1] * 100 }%,${ tempColor[2] * 100 }%)`;
        }
    }, {
        key: 'debugCompute',
        value: function debugCompute(out, x) {
            function mod(a, b) {
                return a % b;
            }
            var low = x.low;
            var high = x.high;

            var b = this.b_;
            var modulus = hash_function_1.PRIME_MODULUS;
            for (var i = 0; i < 2; ++i) {
                var bIndex = 2 * i;
                var aIndex = 2 * i;
                var sums = new Float32Array(2);
                for (var j = 0; j < 4; ++j) {
                    sums[0] += this.a_[aIndex * 4 + j] * (low >> j * 8 & 0xFF);
                    sums[1] += this.a_[(aIndex + 1) * 4 + j] * (high >> j * 8 & 0xFF);
                }
                var dotResult = mod(sums[0] + sums[1], modulus);
                var dotResult2 = mod(dotResult * dotResult, modulus);
                var y = mod(dotResult2 * b[bIndex + 1], modulus);
                var modResult = mod(b[bIndex] + dotResult + y, modulus);
                console.log(`b = ${ b[bIndex] }, sums=${ sums[0] } ${ sums[1] }, dotResult=${ dotResult }, prod = ${ dotResult * dotResult } dotResult2=${ dotResult2 }, y=${ y }, modResult=${ modResult }`);
                out[i] = fract(modResult * (1.0 / 256.0));
            }
            return out;
        }
    }, {
        key: 'randomize_',
        value: function randomize_() {
            for (var i = 0; i < 2; ++i) {
                this.hashFunctions[i] = hash_function_1.HashFunction.generate();
            }
        }
    }, {
        key: 'randomize',
        value: function randomize() {
            this.randomize_();
            this.computeGPUCoefficients_();
            this.changed.dispatch();
        }
    }, {
        key: 'toString',
        value: function toString() {
            return `new SegmentColorHash([${ this.hashFunctions }])`;
        }
    }, {
        key: 'computeGPUCoefficients_',
        value: function computeGPUCoefficients_() {
            var hashFunctions = this.hashFunctions;
            var a = this.a_;
            var b = this.b_;
            var aScalar = 1.0;
            var bScalar = 1.0;
            for (var i = 0; i < NUM_COMPONENTS; ++i) {
                var h = hashFunctions[i];
                var bIndex = 2 * i;
                var aIndex = 4 * (2 * i);
                b[bIndex] = h.b * bScalar;
                b[bIndex + 1] = h.c * bScalar;
                for (var j = 0; j < 4; ++j) {
                    a[aIndex + j] = h.a0[j] * aScalar;
                    a[aIndex + 4 + j] = h.a1[j] * aScalar;
                }
            }
        }
    }], [{
        key: 'getDefault',
        value: function getDefault() {
            return new SegmentColorHash([new hash_function_1.HashFunction(Float32Array.of(609, 2364, 3749, 2289), Float32Array.of(2840, 1186, 3660, 1833), 1718, 1109), new hash_function_1.HashFunction(Float32Array.of(3466, 3835, 3345, 2040), Float32Array.of(3382, 901, 18, 3444), 1534, 1432)]);
        }
    }]);

    return SegmentColorHash;
}();

exports.SegmentColorHash = SegmentColorHash;
;

/***/ },
/* 126 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

exports.PRIME_MODULUS = 4093;

var HashFunction = function () {
    function HashFunction(a0, a1, b, c) {
        _classCallCheck(this, HashFunction);

        this.a0 = a0;
        this.a1 = a1;
        this.b = b;
        this.c = c;
    }

    _createClass(HashFunction, [{
        key: "computeDotProduct",
        value: function computeDotProduct(low, high) {
            var a0 = this.a0;
            var a1 = this.a1;

            var a0DotLow = a0[0] * (low & 0xFF) + a0[1] * (low >> 8 & 0xFF) + a0[2] * (low >> 16 & 0xFF) + a0[3] * (low >> 24 & 0xFF);
            var a1DotHigh = a1[0] * (high & 0xFF) + a1[1] * (high >> 8 & 0xFF) + a1[2] * (high >> 16 & 0xFF) + a1[3] * (high >> 24 & 0xFF);
            return a0DotLow + a1DotHigh;
        }
    }, {
        key: "compute",
        value: function compute(low, high) {
            var b = this.b;
            var c = this.c;

            var x = this.computeDotProduct(low, high);
            var x2 = x * x % exports.PRIME_MODULUS;
            var result = (x + x2 * c + b) % exports.PRIME_MODULUS;
            return result;
        }
    }, {
        key: "toString",
        value: function toString() {
            return `new HashFunction(Float32Array.of(${ this.a0 }), Float32Array.of(${ this.a1 }), ${ this.b }, ${ this.c })`;
        }
    }], [{
        key: "generate",
        value: function generate() {
            function genCoeff() {
                return Math.floor(Math.random() * exports.PRIME_MODULUS);
            }
            function genVector() {
                return Float32Array.of(genCoeff(), genCoeff(), genCoeff(), genCoeff());
            }
            return new HashFunction(genVector(), genVector(), genCoeff(), genCoeff());
        }
    }]);

    return HashFunction;
}();

exports.HashFunction = HashFunction;
;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hash_function_1 = __webpack_require__(126);
var hash_table_1 = __webpack_require__(128);
var disposable_1 = __webpack_require__(23);
var shader_lib_1 = __webpack_require__(72);
var texture_1 = __webpack_require__(69);
exports.glsl_hashFunction = [shader_lib_1.glsl_uint64, shader_lib_1.glsl_exactDot, shader_lib_1.glsl_imod, `
float computeHash(uint64_t x, vec4 a0, vec4 a1, float b, float c, float modulus, float scalar) {
  x.low *= 255.0;
  x.high *= 255.0;
  float dotResult = imod(exactDot(a0, x.low) + exactDot(a1, x.high), modulus);
  float dotResult2 = imod(dotResult * dotResult, modulus);
  float y = imod(dotResult2 * c, modulus);
  float modResult = imod(dotResult + y + b, modulus);
  return fract(modResult * scalar);
}
`];

var GPUHashTable = function (_disposable_1$RefCoun) {
    _inherits(GPUHashTable, _disposable_1$RefCoun);

    function GPUHashTable(gl, hashTable) {
        _classCallCheck(this, GPUHashTable);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GPUHashTable).call(this));

        _this.gl = gl;
        _this.hashTable = hashTable;
        _this.hashFunctions = null;
        _this.generation = -1;
        _this.texture = null;
        var numAlternatives = hashTable.hashFunctions.length;
        _this.a = new Float32Array(4 * (numAlternatives * 4));
        _this.b = new Float32Array(numAlternatives * 4 + 5);
        // createTexture should never actually return null.
        _this.texture = gl.createTexture();
        return _this;
    }

    _createClass(GPUHashTable, [{
        key: 'computeCoefficients',
        value: function computeCoefficients() {
            var hashTable = this.hashTable;

            var hashFunctions = hashTable.hashFunctions;
            if (this.hashFunctions === hashFunctions) {
                return;
            }
            this.hashFunctions = hashFunctions;
            var a = this.a;
            var b = this.b;

            var numAlternatives = hashFunctions.length;
            var width = hashTable.width;
            var height = hashTable.height;

            var scalar = [1.0 / width, 1.0 / height];
            for (var i = 0; i < 2; ++i) {
                b[numAlternatives * 4 + i] = hash_function_1.PRIME_MODULUS;
                b[numAlternatives * 4 + 3 + i] = scalar[i];
            }
            b[numAlternatives * 4 + 2] = 1 / (hashTable.entryStride * width);
            for (var alt = 0; alt < numAlternatives; ++alt) {
                var curFunctions = hashFunctions[alt];
                for (var _i = 0; _i < 2; ++_i) {
                    var h = curFunctions[_i];
                    var bIndex = alt * 4 + 2 * _i;
                    var aIndex = 4 * (alt * 4 + 2 * _i);
                    // Add 0.5 to b to give maximum margin of error.
                    //
                    // For the x coordinate (i == 0), since each position is used to address entryStride texels
                    // (for the low and high uint32 key values, and possibly associated entry values), we only
                    // add 0.5 / entryStride.
                    b[bIndex] = h.b + (_i === 0 ? 0.5 / hashTable.entryStride : 0.5);
                    b[bIndex + 1] = h.c;
                    for (var j = 0; j < 4; ++j) {
                        a[aIndex + j] = h.a0[j];
                        a[aIndex + 4 + j] = h.a1[j];
                    }
                }
            }
        }
    }, {
        key: 'copyToGPU',
        value: function copyToGPU() {
            this.computeCoefficients();
            var hashTable = this.hashTable;
            var generation = hashTable.generation;

            if (this.generation === generation) {
                return;
            }
            this.generation = generation;
            var width = hashTable.width;
            var height = hashTable.height;
            var gl = this.gl;
            var texture = this.texture;

            gl.activeTexture(gl.TEXTURE0 + gl.tempTextureUnit);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            texture_1.setRawTextureParameters(gl);
            var format = gl.RGBA;
            hashTable.tableWithMungedEmptyKey(table => {
                gl.texImage2D(gl.TEXTURE_2D,
                /*level=*/0, format,
                /*width=*/width * hashTable.entryStride,
                /*height=*/height,
                /*border=*/0, format, gl.UNSIGNED_BYTE, new Uint8Array(table.buffer));
            });
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            var gl = this.gl;

            gl.deleteTexture(this.texture);
            this.texture = null;
            this.gl = undefined;
            this.hashTable = undefined;
            this.hashFunctions = null;
            _get(Object.getPrototypeOf(GPUHashTable.prototype), 'disposed', this).call(this);
        }
    }], [{
        key: 'get',
        value: function get(gl, hashTable) {
            return gl.memoize.get(hashTable, () => new this(gl, hashTable));
        }
    }]);

    return GPUHashTable;
}(disposable_1.RefCounted);

exports.GPUHashTable = GPUHashTable;
;

var HashSetShaderManager = function () {
    function HashSetShaderManager(prefix) {
        var numAlternatives = arguments.length <= 1 || arguments[1] === undefined ? hash_table_1.NUM_ALTERNATIVES : arguments[1];

        _classCallCheck(this, HashSetShaderManager);

        this.prefix = prefix;
        this.numAlternatives = numAlternatives;
        this.textureUnitSymbol = Symbol.for(`gpuhashtable:${ this.prefix }`);
        this.aName = this.prefix + '_a';
        this.bName = this.prefix + '_b';
        this.samplerName = this.prefix + '_sampler';
    }

    _createClass(HashSetShaderManager, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            var aName = this.aName;
            var bName = this.bName;
            var samplerName = this.samplerName;
            var numAlternatives = this.numAlternatives;

            builder.addUniform('highp vec4', aName, numAlternatives * 4);
            builder.addUniform('highp float', bName, numAlternatives * 4 + 5);
            builder.addTextureSampler2D(samplerName, this.textureUnitSymbol);
            builder.addFragmentCode(exports.glsl_hashFunction);
            var s = '';
            for (var alt = 0; alt < numAlternatives; ++alt) {
                for (var i = 0; i < 2; ++i) {
                    var bIndex = alt * 4 + 2 * i;
                    var aIndex = alt * 4 + 2 * i;
                    s += `
float ${ this.prefix }_computeHash_${ alt }_${ i }(uint64_t x) {
  float primeModulus = ${ bName }[${ numAlternatives * 4 + i }];
  float scalar = ${ bName }[${ numAlternatives * 4 + 3 + i }];
  return computeHash(x, ${ aName }[${ aIndex }], ${ aName }[${ aIndex + 1 }], ${ bName }[${ bIndex }], ${ bName }[${ bIndex + 1 }], primeModulus, scalar);
}
`;
                }
                s += `
vec2 ${ this.prefix }_computeHash_${ alt }(uint64_t x) {
  vec2 v;
  v[0] = ${ this.prefix }_computeHash_${ alt }_0(x);
  v[1] = ${ this.prefix }_computeHash_${ alt }_1(x);
  return v;
}
`;
            }
            s += `
bool ${ this.hasFunctionName }(uint64_t x) {
  float highOffset = ${ bName }[${ numAlternatives * 4 + 2 }];
`;
            for (var _alt = 0; _alt < numAlternatives; ++_alt) {
                s += `
  {
    vec2 v = ${ this.prefix }_computeHash_${ _alt }(x);
    vec4 lowResult = texture2D(${ samplerName }, v);
    vec4 highResult = texture2D(${ samplerName }, vec2(v.x + highOffset, v.y));
    if (lowResult == x.low && highResult == x.high) {
      return true;
    }
  }
`;
            }
            s += `
  return false;
}
`;
            builder.addFragmentCode(s);
        }
    }, {
        key: 'enable',
        value: function enable(gl, shader, hashTable) {
            hashTable.copyToGPU();
            var textureUnit = shader.textureUnit(this.textureUnitSymbol);
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            gl.bindTexture(gl.TEXTURE_2D, hashTable.texture);
            gl.uniform4fv(shader.uniform(this.aName), hashTable.a);
            gl.uniform1fv(shader.uniform(this.bName), hashTable.b);
        }
    }, {
        key: 'disable',
        value: function disable(gl, shader) {
            var textureUnit = shader.textureUnit(this.textureUnitSymbol);
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }, {
        key: 'hasFunctionName',
        get: function () {
            return `${ this.prefix }_has`;
        }
    }]);

    return HashSetShaderManager;
}();

exports.HashSetShaderManager = HashSetShaderManager;
;

var HashMapShaderManager = function (_HashSetShaderManager) {
    _inherits(HashMapShaderManager, _HashSetShaderManager);

    function HashMapShaderManager() {
        _classCallCheck(this, HashMapShaderManager);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(HashMapShaderManager).apply(this, arguments));
    }

    _createClass(HashMapShaderManager, [{
        key: 'defineShader',
        value: function defineShader(builder) {
            _get(Object.getPrototypeOf(HashMapShaderManager.prototype), 'defineShader', this).call(this, builder);
            var bName = this.bName;
            var samplerName = this.samplerName;
            var numAlternatives = this.numAlternatives;

            var s = `
bool ${ this.getFunctionName }(uint64_t x, out uint64_t value) {
  float highOffset = ${ bName }[${ numAlternatives * 4 + 2 }];
`;
            for (var alt = 0; alt < numAlternatives; ++alt) {
                s += `
  {
    vec2 v = ${ this.prefix }_computeHash_${ alt }(x);
    vec4 lowResult = texture2D(${ samplerName }, v);
    vec4 highResult = texture2D(${ samplerName }, vec2(v.x + highOffset, v.y));
    if (lowResult == x.low && highResult == x.high) {
      value.low = texture2D(${ samplerName }, vec2(v.x + 2.0 * highOffset, v.y));
      value.high = texture2D(${ samplerName }, vec2(v.x + 3.0 * highOffset, v.y));
      return true;
    }
  }
`;
            }
            s += `
  return false;
}
`;
            builder.addFragmentCode(s);
        }
    }, {
        key: 'getFunctionName',
        get: function () {
            return `${ this.prefix }_get`;
        }
    }]);

    return HashMapShaderManager;
}(HashSetShaderManager);

exports.HashMapShaderManager = HashMapShaderManager;
;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var hash_function_1 = __webpack_require__(126);
var uint64_1 = __webpack_require__(52);
exports.NUM_ALTERNATIVES = 3;
var DEFAULT_LOAD_FACTOR = 0.9;
var DEBUG = false;
// Key that needs to be inserted.  Temporary variables used during insert.  These can safely be
// global because control never leaves functions defined in this module while these are in use.
var pendingLow = 0,
    pendingHigh = 0,
    backupPendingLow = 0,
    backupPendingHigh = 0;

var HashTableBase = function () {
    function HashTableBase() {
        var hashFunctions = arguments.length <= 0 || arguments[0] === undefined ? HashTableBase.generateHashFunctions(exports.NUM_ALTERNATIVES) : arguments[0];

        _classCallCheck(this, HashTableBase);

        this.loadFactor = DEFAULT_LOAD_FACTOR;
        this.size = 0;
        this.growFactor = 1.2;
        this.maxHeight = 8192;
        this.emptyLow = 4294967295;
        this.emptyHigh = 4294967295;
        this.maxRehashAttempts = 5;
        this.maxAttempts = 5;
        this.maxWidth = 4096 / this.entryStride;
        this.generation = 0;
        this.mungedEmptyKey = -1;
        this.hashFunctions = hashFunctions;
        this.allocate(4, 1);
    }

    _createClass(HashTableBase, [{
        key: 'updateHashFunctions',
        value: function updateHashFunctions(numHashes) {
            this.hashFunctions = HashTableBase.generateHashFunctions(numHashes);
            this.mungedEmptyKey = -1;
        }
        /**
         * Invokes callback with a modified version of the hash table data array.
         *
         * Replaces all slots that appear to be valid entries for (emptyLow, emptyHigh), i.e. slots that
         * contain (emptyLow, emptyHigh) and to which (emptyLow, emptyHigh) hashes, with (mungedEmptyKey,
         * mungedEmptyKey).
         *
         * mungedEmptyKey is chosen to be a 32-bit value with the property that the 64-bit value
         * (mungedEmptyKey, mungedEmptyKey) does not hash to any of the same slots as (emptyLow,
         * emptyHigh).
         *
         * This allows the modified data array to be used for lookups without special casing the empty
         * key.
         */

    }, {
        key: 'tableWithMungedEmptyKey',
        value: function tableWithMungedEmptyKey(callback) {
            var numHashes = this.hashFunctions.length;
            var emptySlots = new Array(numHashes);
            for (var i = 0; i < numHashes; ++i) {
                emptySlots[i] = this.getHash(i, this.emptyLow, this.emptyHigh);
            }
            var mungedEmptyKey = this.mungedEmptyKey;

            if (mungedEmptyKey === -1) {
                chooseMungedEmptyKey: while (true) {
                    mungedEmptyKey = Math.random() * 0x1000000 >>> 0;
                    for (var _i = 0; _i < numHashes; ++_i) {
                        var h = this.getHash(_i, mungedEmptyKey, mungedEmptyKey);
                        for (var j = 0; j < numHashes; ++j) {
                            if (emptySlots[j] === h) {
                                continue chooseMungedEmptyKey;
                            }
                        }
                    }
                    this.mungedEmptyKey = mungedEmptyKey;
                    break;
                }
            }
            var table = this.table;
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;

            for (var _i2 = 0; _i2 < numHashes; ++_i2) {
                var _h = emptySlots[_i2];
                if (table[_h] === emptyLow && table[_h + 1] === emptyHigh) {
                    table[_h] = mungedEmptyKey;
                    table[_h + 1] = mungedEmptyKey;
                }
            }
            try {
                callback(table);
            } finally {
                for (var _i3 = 0; _i3 < numHashes; ++_i3) {
                    var _h2 = emptySlots[_i3];
                    if (table[_h2] === mungedEmptyKey && table[_h2 + 1] === mungedEmptyKey) {
                        table[_h2] = emptyLow;
                        table[_h2 + 1] = emptyHigh;
                    }
                }
            }
        }
    }, {
        key: 'getHash',
        value: function getHash(hashIndex, low, high) {
            var hashes = this.hashFunctions[hashIndex];
            var width = this.width,
                height = this.height;
            var x = hashes[0].compute(low, high) % width;
            var y = hashes[1].compute(low, high) % height;
            return this.entryStride * (y * this.width + x);
        }
        /**
         * Iterates over the Uint64 keys contained in the hash set.
         *
         * The same temp value will be modified and yielded at every iteration.
         */

    }, {
        key: 'keys',
        value: function* keys() {
            var temp = arguments.length <= 0 || arguments[0] === undefined ? new uint64_1.Uint64() : arguments[0];
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;
            var entryStride = this.entryStride;
            var table = this.table;

            for (var i = 0, length = table.length; i < length; i += entryStride) {
                var low = table[i],
                    high = table[i + 1];
                if (low !== emptyLow || high !== emptyHigh) {
                    temp.low = low;
                    temp.high = high;
                    yield temp;
                }
            }
        }
    }, {
        key: 'indexOfPair',
        value: function indexOfPair(low, high) {
            var table = this.table;
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;

            if (low === emptyLow && high === emptyHigh) {
                return -1;
            }
            for (var i = 0, numHashes = this.hashFunctions.length; i < numHashes; ++i) {
                var h = this.getHash(i, low, high);
                if (table[h] === low && table[h + 1] === high) {
                    return h;
                }
            }
            return -1;
        }
        /**
         * Returns the offset into the hash table of the specified element, or -1 if the element is not
         * present.
         */

    }, {
        key: 'indexOf',
        value: function indexOf(x) {
            return this.indexOfPair(x.low, x.high);
        }
        /**
         * Changes the empty key to a value that is not equal to the current empty key and is not present
         * in the table.
         *
         * This is called when an attempt is made to insert the empty key.
         */

    }, {
        key: 'chooseAnotherEmptyKey',
        value: function chooseAnotherEmptyKey() {
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;
            var table = this.table;
            var entryStride = this.entryStride;

            var newLow = void 0,
                newHigh = void 0;
            while (true) {
                newLow = Math.random() * 0x100000000 >>> 0;
                newHigh = Math.random() * 0x100000000 >>> 0;
                if (newLow === emptyLow && newHigh === emptyHigh) {
                    continue;
                }
                if (this.hasPair(newLow, newHigh)) {
                    continue;
                }
                break;
            }
            this.emptyLow = newLow;
            this.emptyHigh = newHigh;
            // Replace empty keys in the table.
            for (var h = 0, length = table.length; h < length; h += entryStride) {
                if (table[h] === emptyLow && table[h + 1] === emptyHigh) {
                    table[h] = newLow;
                    table[h + 1] = newHigh;
                }
            }
        }
        /**
         * Returns true iff the specified element is present.
         */

    }, {
        key: 'has',
        value: function has(x) {
            return this.indexOf(x) !== -1;
        }
        /**
         * Returns true iff the specified element is present.
         */

    }, {
        key: 'hasPair',
        value: function hasPair(low, high) {
            return this.indexOfPair(low, high) !== -1;
        }
    }, {
        key: 'delete',
        value: function _delete(x) {
            var index = this.indexOf(x);
            if (index !== -1) {
                var table = this.table;

                table[index] = this.emptyLow;
                table[index + 1] = this.emptyHigh;
                ++this.generation;
                this.size--;
                return true;
            }
            return false;
        }
    }, {
        key: 'clearTable',
        value: function clearTable() {
            var table = this.table;
            var entryStride = this.entryStride;
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;

            var length = table.length;
            for (var h = 0; h < length; h += entryStride) {
                table[h] = emptyLow;
                table[h + 1] = emptyHigh;
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            if (this.size === 0) {
                return false;
            }
            this.size = 0;
            ++this.generation;
            this.clearTable();
            return true;
        }
    }, {
        key: 'swapPending',
        value: function swapPending(table, offset) {
            var tempLow = pendingLow,
                tempHigh = pendingHigh;
            this.storePending(table, offset);
            table[offset] = tempLow;
            table[offset + 1] = tempHigh;
        }
    }, {
        key: 'storePending',
        value: function storePending(table, offset) {
            pendingLow = table[offset];
            pendingHigh = table[offset + 1];
        }
    }, {
        key: 'backupPending',
        value: function backupPending() {
            backupPendingLow = pendingLow;
            backupPendingHigh = pendingHigh;
        }
    }, {
        key: 'restorePending',
        value: function restorePending() {
            pendingLow = backupPendingLow;
            pendingHigh = backupPendingHigh;
        }
    }, {
        key: 'tryToInsert',
        value: function tryToInsert() {
            if (DEBUG) {
                console.log(`tryToInsert: ${ pendingLow }, ${ pendingHigh }`);
            }
            var attempt = 0;
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;
            var maxAttempts = this.maxAttempts;
            var table = this.table;

            var numHashes = this.hashFunctions.length;
            var tableIndex = Math.floor(Math.random() * numHashes);
            while (true) {
                var h = this.getHash(tableIndex, pendingLow, pendingHigh);
                this.swapPending(table, h);
                if (pendingLow === emptyLow && pendingHigh === emptyHigh) {
                    return true;
                }
                if (++attempt === maxAttempts) {
                    break;
                }
                tableIndex = (tableIndex + Math.floor(Math.random() * (numHashes - 1)) + 1) % numHashes;
            }
            return false;
        }
    }, {
        key: 'allocate',
        value: function allocate(width, height) {
            var tableSize = width * height;
            this.width = width;
            this.height = height;
            var entryStride = this.entryStride;

            this.table = new Uint32Array(tableSize * entryStride);
            this.maxAttempts = tableSize;
            this.clearTable();
            this.capacity = tableSize * this.loadFactor;
            this.mungedEmptyKey = -1;
        }
    }, {
        key: 'rehash',
        value: function rehash(oldTable, width, height) {
            if (DEBUG) {
                console.log('rehash begin');
            }
            this.allocate(width, height);
            this.updateHashFunctions(this.hashFunctions.length);
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;
            var entryStride = this.entryStride;

            for (var h = 0, length = oldTable.length; h < length; h += entryStride) {
                var low = oldTable[h],
                    high = oldTable[h + 1];
                if (low !== emptyLow || high !== emptyHigh) {
                    this.storePending(oldTable, h);
                    if (!this.tryToInsert()) {
                        if (DEBUG) {
                            console.log('rehash failed');
                        }
                        return false;
                    }
                }
            }
            if (DEBUG) {
                console.log('rehash end');
            }
            return true;
        }
    }, {
        key: 'grow',
        value: function grow(desiredTableSize) {
            if (DEBUG) {
                console.log(`grow: ${ desiredTableSize }`);
            }
            var oldTable = this.table;
            var width = this.width;
            var height = this.height;
            var maxWidth = this.maxWidth;
            var maxHeight = this.maxHeight;

            while (true) {
                var origTableSize = width * height;
                width = Math.min(maxWidth, Math.ceil(desiredTableSize / this.height));
                if (width * height < desiredTableSize) {
                    height = Math.min(maxHeight, Math.ceil(desiredTableSize / width));
                }
                var tableSize = width * height;
                if (tableSize < desiredTableSize && tableSize === origTableSize) {
                    throw new Error('Maximum table size exceeded');
                }
                for (var rehashAttempt = 0; rehashAttempt < this.maxRehashAttempts; ++rehashAttempt) {
                    if (this.rehash(oldTable, width, height)) {
                        if (DEBUG) {
                            console.log(`grow end`);
                        }
                        return;
                    }
                }
                desiredTableSize = Math.ceil(this.growFactor * desiredTableSize);
            }
        }
    }, {
        key: 'insertInternal',
        value: function insertInternal() {
            ++this.generation;
            if (pendingLow === this.emptyLow && pendingHigh === this.emptyHigh) {
                this.chooseAnotherEmptyKey();
            }
            if (++this.size > this.capacity) {
                this.backupPending();
                this.grow(Math.ceil(this.growFactor * this.width * this.height));
                this.restorePending();
            }
            while (!this.tryToInsert()) {
                this.backupPending();
                this.grow(this.width * this.height);
                this.restorePending();
            }
        }
    }], [{
        key: 'generateHashFunctions',
        value: function generateHashFunctions() {
            var numAlternatives = arguments.length <= 0 || arguments[0] === undefined ? exports.NUM_ALTERNATIVES : arguments[0];

            var hashFunctions = [];
            for (var alt = 0; alt < numAlternatives; ++alt) {
                var curFunctions = [hash_function_1.HashFunction.generate(), hash_function_1.HashFunction.generate()];
                hashFunctions.push(curFunctions);
            }
            return hashFunctions;
        }
    }]);

    return HashTableBase;
}();

exports.HashTableBase = HashTableBase;
;

var HashSetUint64 = function (_HashTableBase) {
    _inherits(HashSetUint64, _HashTableBase);

    function HashSetUint64() {
        _classCallCheck(this, HashSetUint64);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(HashSetUint64).apply(this, arguments));
    }

    _createClass(HashSetUint64, [{
        key: 'add',
        value: function add(x) {
            var low = x.low;
            var high = x.high;

            if (this.hasPair(low, high)) {
                return false;
            }
            if (DEBUG) {
                console.log(`add: ${ low },${ high }`);
            }
            pendingLow = low;
            pendingHigh = high;
            this.insertInternal();
            return true;
        }
        /**
         * Iterates over the keys.  The same temporary value will be modified and yielded at every
         * iteration.
         */

    }, {
        key: Symbol.iterator,
        value: function () {
            return this.keys();
        }
    }]);

    return HashSetUint64;
}(HashTableBase);

exports.HashSetUint64 = HashSetUint64;
;
HashSetUint64.prototype.entryStride = 2;
// Value that needs to be inserted.  Temporary variables used during insert.  These can safely be
// global because control never leaves functions defined in this module while these are in use.
var pendingValueLow = 0,
    pendingValueHigh = 0,
    backupPendingValueLow = 0,
    backupPendingValueHigh = 0;

var HashMapUint64 = function (_HashTableBase2) {
    _inherits(HashMapUint64, _HashTableBase2);

    function HashMapUint64() {
        _classCallCheck(this, HashMapUint64);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(HashMapUint64).apply(this, arguments));
    }

    _createClass(HashMapUint64, [{
        key: 'set',
        value: function set(key, value) {
            var low = key.low;
            var high = key.high;

            if (this.hasPair(low, high)) {
                return false;
            }
            if (DEBUG) {
                console.log(`add: ${ low },${ high } -> ${ value.low },${ value.high }`);
            }
            pendingLow = low;
            pendingHigh = high;
            pendingValueLow = value.low;
            pendingValueHigh = value.high;
            this.insertInternal();
            return true;
        }
    }, {
        key: 'get',
        value: function get(key, value) {
            var h = this.indexOf(key);
            if (h === -1) {
                return false;
            }
            var table = this.table;

            value.low = table[h + 2];
            value.high = table[h + 3];
            return true;
        }
    }, {
        key: 'swapPending',
        value: function swapPending(table, offset) {
            var tempLow = pendingValueLow,
                tempHigh = pendingValueHigh;
            _get(Object.getPrototypeOf(HashMapUint64.prototype), 'swapPending', this).call(this, table, offset);
            table[offset + 2] = tempLow;
            table[offset + 3] = tempHigh;
        }
    }, {
        key: 'storePending',
        value: function storePending(table, offset) {
            _get(Object.getPrototypeOf(HashMapUint64.prototype), 'storePending', this).call(this, table, offset);
            pendingValueLow = table[offset + 2];
            pendingValueHigh = table[offset + 3];
        }
    }, {
        key: 'backupPending',
        value: function backupPending() {
            _get(Object.getPrototypeOf(HashMapUint64.prototype), 'backupPending', this).call(this);
            backupPendingValueLow = pendingValueLow;
            backupPendingValueHigh = pendingValueHigh;
        }
    }, {
        key: 'restorePending',
        value: function restorePending() {
            _get(Object.getPrototypeOf(HashMapUint64.prototype), 'restorePending', this).call(this);
            pendingValueLow = backupPendingValueLow;
            pendingValueHigh = backupPendingValueHigh;
        }
        /**
         * Iterates over entries.  The same temporary value will be modified and yielded at every
         * iteration.
         */

    }, {
        key: Symbol.iterator,
        value: function () {
            return this.entries();
        }
        /**
         * Iterates over entries.  The same temporary value will be modified and yielded at every
         * iteration.
         */

    }, {
        key: 'entries',
        value: function* entries() {
            var temp = arguments.length <= 0 || arguments[0] === undefined ? [new uint64_1.Uint64(), new uint64_1.Uint64()] : arguments[0];
            var emptyLow = this.emptyLow;
            var emptyHigh = this.emptyHigh;
            var entryStride = this.entryStride;
            var table = this.table;

            var _temp = _slicedToArray(temp, 2);

            var key = _temp[0];
            var value = _temp[1];

            for (var i = 0, length = table.length; i < length; i += entryStride) {
                var low = table[i],
                    high = table[i + 1];
                if (low !== emptyLow || high !== emptyHigh) {
                    key.low = low;
                    key.high = high;
                    value.low = table[i + 2];
                    value.high = table[i + 3];
                    yield temp;
                }
            }
        }
    }]);

    return HashMapUint64;
}(HashTableBase);

exports.HashMapUint64 = HashMapUint64;
;
HashMapUint64.prototype.entryStride = 4;

/***/ },
/* 129 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Converts an HSV color (with h, s, v in [0,1]) to RGB (in range [0,1]).
 *
 * Based on goog/color/color.js in the Google Closure library.
 */

function hsvToRgb(out, h, s, v) {
    h *= 6;
    var hueIndex = Math.floor(h);
    var remainder = h - hueIndex;
    var val1 = v * (1 - s);
    var val2 = v * (1 - s * remainder);
    var val3 = v * (1 - s * (1 - remainder));
    switch (hueIndex % 6) {
        case 0:
            out[0] = v;
            out[1] = val3;
            out[2] = val1;
            break;
        case 1:
            out[0] = val2;
            out[1] = v;
            out[2] = val1;
            break;
        case 2:
            out[0] = val1;
            out[1] = v;
            out[2] = val3;
            break;
        case 3:
            out[0] = val1;
            out[1] = val2;
            out[2] = v;
            break;
        case 4:
            out[0] = val3;
            out[1] = val1;
            out[2] = v;
            break;
        case 5:
            out[0] = v;
            out[1] = val1;
            out[2] = val2;
            break;
    }
    return out;
}
exports.hsvToRgb = hsvToRgb;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var disjoint_sets_1 = __webpack_require__(131);
var json_1 = __webpack_require__(8);
var uint64_1 = __webpack_require__(52);
var worker_rpc_1 = __webpack_require__(22);
var signals_1 = __webpack_require__(34);
var RPC_TYPE_ID = 'DisjointUint64Sets';
var ADD_METHOD_ID = 'DisjointUint64Sets.add';
var CLEAR_METHOD_ID = 'DisjointUint64Sets.clear';
var SharedDisjointUint64Sets = function (_worker_rpc_1$SharedO) {
    _inherits(SharedDisjointUint64Sets, _worker_rpc_1$SharedO);

    function SharedDisjointUint64Sets() {
        _classCallCheck(this, SharedDisjointUint64Sets);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SharedDisjointUint64Sets).call(this, ...args));

        _this.disjointSets = new disjoint_sets_1.DisjointUint64Sets();
        _this.changed = new signals_1.Signal();
        return _this;
    }

    _createClass(SharedDisjointUint64Sets, [{
        key: "disposed",
        value: function disposed() {
            this.disjointSets = undefined;
            this.changed = undefined;
            _get(Object.getPrototypeOf(SharedDisjointUint64Sets.prototype), "disposed", this).call(this);
        }
    }, {
        key: "link",
        value: function link(a, b) {
            if (this.disjointSets.link(a, b)) {
                var rpc = this.rpc;

                if (rpc) {
                    rpc.invoke(ADD_METHOD_ID, { 'id': this.rpcId, 'al': a.low, 'ah': a.high, 'bl': b.low, 'bh': b.high });
                }
                this.changed.dispatch();
            }
        }
    }, {
        key: "get",
        value: function get(x) {
            return this.disjointSets.get(x);
        }
    }, {
        key: "clear",
        value: function clear() {
            if (this.disjointSets.clear()) {
                var rpc = this.rpc;

                if (rpc) {
                    rpc.invoke(CLEAR_METHOD_ID, { 'id': this.rpcId });
                }
                this.changed.dispatch();
            }
        }
    }, {
        key: "setElements",
        value: function setElements(a) {
            return this.disjointSets.setElements(a);
        }
    }, {
        key: "toJSON",
        value: function toJSON() {
            return this.disjointSets.toJSON();
        }
        /**
         * Restores the state from a JSON representation.
         */

    }, {
        key: "restoreState",
        value: function restoreState(obj) {
            var _this2 = this;

            this.clear();
            if (obj !== undefined) {
                (function () {
                    var ids = [new uint64_1.Uint64(), new uint64_1.Uint64()];
                    json_1.parseArray(obj, z => {
                        json_1.parseArray(z, (s, index) => {
                            ids[index % 2].parseString(String(s), 10);
                            if (index !== 0) {
                                _this2.link(ids[0], ids[1]);
                            }
                        });
                    });
                })();
            }
        }
    }, {
        key: "size",
        get: function () {
            return this.disjointSets.size;
        }
    }], [{
        key: "makeWithCounterpart",
        value: function makeWithCounterpart(rpc) {
            var obj = new this();
            obj.initializeCounterpart(rpc);
            return obj;
        }
    }]);

    return SharedDisjointUint64Sets;
}(worker_rpc_1.SharedObjectCounterpart);
SharedDisjointUint64Sets = __decorate([worker_rpc_1.registerSharedObject(RPC_TYPE_ID)], SharedDisjointUint64Sets);
exports.SharedDisjointUint64Sets = SharedDisjointUint64Sets;
;
var tempA = new uint64_1.Uint64();
var tempB = new uint64_1.Uint64();
worker_rpc_1.registerRPC(ADD_METHOD_ID, function (x) {
    var obj = this.get(x['id']);
    tempA.low = x['al'];
    tempA.high = x['ah'];
    tempB.low = x['bl'];
    tempB.high = x['bh'];
    if (obj.disjointSets.link(tempA, tempB)) {
        obj.changed.dispatch();
    }
});
worker_rpc_1.registerRPC(CLEAR_METHOD_ID, function (x) {
    var obj = this.get(x['id']);
    if (obj.disjointSets.clear()) {
        obj.changed.dispatch();
    }
});

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var uint64_1 = __webpack_require__(52);
var rankSymbol = Symbol('disjoint_sets:rank');
var parentSymbol = Symbol('disjoint_sets:parent');
var nextSymbol = Symbol('disjoint_sets:next');
var prevSymbol = Symbol('disjoint_sets:prev');
function findRepresentative(v) {
    // First pass: find the root, which will be stored in ancestor.
    var old = v;
    var ancestor = v[parentSymbol];
    while (ancestor !== v) {
        v = ancestor;
        ancestor = v[parentSymbol];
    }
    // Second pass: set all of the parent pointers along the path from the
    // original element `old' to refer directly to the root `ancestor'.
    v = old[parentSymbol];
    while (ancestor !== v) {
        old[parentSymbol] = ancestor;
        old = v;
        v = old[parentSymbol];
    }
    return ancestor;
}
function linkUnequalSetRepresentatives(i, j) {
    var iRank = i[rankSymbol];
    var jRank = j[rankSymbol];
    if (iRank > jRank) {
        j[parentSymbol] = i;
        return i;
    }
    i[parentSymbol] = j;
    if (iRank === jRank) {
        j[rankSymbol] = jRank + 1;
    }
    return j;
}
function spliceCircularLists(i, j) {
    var iPrev = i[prevSymbol];
    var jPrev = j[prevSymbol];
    // Connect end of i to beginning of j.
    j[prevSymbol] = iPrev;
    iPrev[nextSymbol] = j;
    // Connect end of j to beginning of i.
    i[prevSymbol] = jPrev;
    jPrev[nextSymbol] = i;
}
function* setElementIterator(i) {
    var j = i;
    do {
        yield j;
        j = j[nextSymbol];
    } while (j !== i);
}
function initializeElement(v) {
    v[parentSymbol] = v;
    v[rankSymbol] = 0;
    v[nextSymbol] = v[prevSymbol] = v;
}
var minSymbol = Symbol('disjoint_sets:min');
function isRootElement(v) {
    return v[parentSymbol] === v;
}
/**
 * Represents a collection of disjoint sets of Uint64 values.
 *
 * Supports merging sets, retrieving the minimum Uint64 value contained in a set (the representative
 * value), and iterating over the elements contained in a set.
 */

var DisjointUint64Sets = function () {
    function DisjointUint64Sets() {
        _classCallCheck(this, DisjointUint64Sets);

        this.map = new Map();
        this.generation = 0;
    }

    _createClass(DisjointUint64Sets, [{
        key: 'get',
        value: function get(x) {
            var key = x.toString();
            var element = this.map.get(key);
            if (element === undefined) {
                return x;
            }
            return findRepresentative(element)[minSymbol];
        }
    }, {
        key: 'isMinElement',
        value: function isMinElement(x) {
            var y = this.get(x);
            return y === x || uint64_1.Uint64.equal(y, x);
        }
    }, {
        key: 'makeSet',
        value: function makeSet(x) {
            var key = x.toString();
            var map = this.map;

            var element = map.get(key);
            if (element === undefined) {
                element = x.clone();
                initializeElement(element);
                element[minSymbol] = element;
                map.set(key, element);
                return element;
            }
            return findRepresentative(element);
        }
    }, {
        key: 'link',
        value: function link(a, b) {
            a = this.makeSet(a);
            b = this.makeSet(b);
            if (a === b) {
                return false;
            }
            this.generation++;
            var newNode = linkUnequalSetRepresentatives(a, b);
            spliceCircularLists(a, b);
            var aMin = a[minSymbol];
            var bMin = b[minSymbol];
            newNode[minSymbol] = uint64_1.Uint64.less(aMin, bMin) ? aMin : bMin;
            return true;
        }
    }, {
        key: 'setElements',
        value: function* setElements(a) {
            var key = a.toString();
            var element = this.map.get(key);
            if (element === undefined) {
                yield a;
            } else {
                yield* setElementIterator(element);
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            var map = this.map;

            if (map.size === 0) {
                return false;
            }
            ++this.generation;
            map.clear();
            return true;
        }
    }, {
        key: 'mappings',
        value: function* mappings() {
            var temp = arguments.length <= 0 || arguments[0] === undefined ? new Array(2) : arguments[0];

            for (var element of this.map.values()) {
                temp[0] = element;
                temp[1] = findRepresentative(element)[minSymbol];
                yield temp;
            }
        }
    }, {
        key: Symbol.iterator,
        value: function () {
            return this.mappings();
        }
        /**
         * Returns an array of arrays of strings, where the arrays contained in the outer array correspond
         * to the disjoint sets, and the strings are the base-10 string representations of the members of
         * each set.  The members are sorted in numerical order, and the sets are sorted in numerical
         * order of their smallest elements.
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            var sets = new Array();
            for (var element of this.map.values()) {
                if (isRootElement(element)) {
                    var members = new Array();
                    for (var member of setElementIterator(element)) {
                        members.push(member);
                    }
                    members.sort(uint64_1.Uint64.compare);
                    sets.push(members);
                }
            }
            sets.sort((a, b) => uint64_1.Uint64.compare(a[0], b[0]));
            return sets.map(set => set.map(element => element.toString()));
        }
    }, {
        key: 'size',
        get: function () {
            return this.map.size;
        }
    }]);

    return DisjointUint64Sets;
}();

exports.DisjointUint64Sets = DisjointUint64Sets;
;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var hash_table_1 = __webpack_require__(128);
var shader_1 = __webpack_require__(127);
var segment_color_1 = __webpack_require__(125);
var frontend_1 = __webpack_require__(75);
var renderlayer_1 = __webpack_require__(66);
var selectedSegmentForShader = new Float32Array(8);

var EquivalencesHashMap = function () {
    function EquivalencesHashMap(disjointSets) {
        _classCallCheck(this, EquivalencesHashMap);

        this.disjointSets = disjointSets;
        this.generation = Number.NaN;
        this.hashMap = new hash_table_1.HashMapUint64();
    }

    _createClass(EquivalencesHashMap, [{
        key: 'update',
        value: function update() {
            var disjointSets = this.disjointSets;
            var generation = disjointSets.generation;

            if (this.generation !== generation) {
                this.generation = generation;
                var hashMap = this.hashMap;

                hashMap.clear();
                for (var _ref3 of disjointSets.mappings()) {
                    var _ref2 = _slicedToArray(_ref3, 2);

                    var objectId = _ref2[0];
                    var minObjectId = _ref2[1];

                    hashMap.set(objectId, minObjectId);
                }
            }
        }
    }]);

    return EquivalencesHashMap;
}();

exports.EquivalencesHashMap = EquivalencesHashMap;
;

var SegmentationRenderLayer = function (_renderlayer_1$Render) {
    _inherits(SegmentationRenderLayer, _renderlayer_1$Render);

    function SegmentationRenderLayer(chunkManager, multiscaleSourcePromise, displayState) {
        var selectedAlpha = arguments.length <= 3 || arguments[3] === undefined ? renderlayer_1.trackableAlphaValue(0.5) : arguments[3];
        var notSelectedAlpha = arguments.length <= 4 || arguments[4] === undefined ? renderlayer_1.trackableAlphaValue(0) : arguments[4];

        _classCallCheck(this, SegmentationRenderLayer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SegmentationRenderLayer).call(this, chunkManager, multiscaleSourcePromise));

        _this.displayState = displayState;
        _this.selectedAlpha = selectedAlpha;
        _this.notSelectedAlpha = notSelectedAlpha;
        _this.segmentColorShaderManager = new segment_color_1.SegmentColorShaderManager('segmentColorHash');
        _this.hashTableManager = new shader_1.HashSetShaderManager('visibleSegments');
        _this.gpuHashTable = shader_1.GPUHashTable.get(_this.gl, _this.displayState.visibleSegments.hashTable);
        _this.equivalencesShaderManager = new shader_1.HashMapShaderManager('equivalences');
        _this.equivalencesHashMap = new EquivalencesHashMap(_this.displayState.segmentEquivalences.disjointSets);
        _this.gpuEquivalencesHashTable = shader_1.GPUHashTable.get(_this.gl, _this.equivalencesHashMap.hashMap);
        frontend_1.registerRedrawWhenSegmentationDisplayStateChanged(displayState, _this);
        _this.registerSignalBinding(selectedAlpha.changed.add(() => {
            _this.redrawNeeded.dispatch();
        }));
        _this.hasEquivalences = _this.displayState.segmentEquivalences.size !== 0;
        displayState.segmentEquivalences.changed.add(() => {
            var segmentEquivalences = _this.displayState.segmentEquivalences;

            var hasEquivalences = segmentEquivalences.size !== 0;
            if (hasEquivalences !== _this.hasEquivalences) {
                _this.hasEquivalences = hasEquivalences;
                _this.shaderUpdated = true;
            }
        });
        _this.registerSignalBinding(notSelectedAlpha.changed.add(() => {
            _this.redrawNeeded.dispatch();
        }));
        return _this;
    }

    _createClass(SegmentationRenderLayer, [{
        key: 'getShaderKey',
        value: function getShaderKey() {
            // The shader to use depends on whether there are any equivalences.
            return `sliceview.SegmentationRenderLayer/${ this.hasEquivalences }`;
        }
    }, {
        key: 'defineShader',
        value: function defineShader(builder) {
            _get(Object.getPrototypeOf(SegmentationRenderLayer.prototype), 'defineShader', this).call(this, builder);
            this.hashTableManager.defineShader(builder);
            builder.addFragmentCode(`
uint64_t getUint64DataValue() {
  return toUint64(getDataValue());
}
`);
            if (this.hasEquivalences) {
                this.equivalencesShaderManager.defineShader(builder);
                builder.addFragmentCode(`
uint64_t getMappedObjectId() {
  uint64_t value = getUint64DataValue();
  uint64_t mappedValue;
  if (${ this.equivalencesShaderManager.getFunctionName }(value, mappedValue)) {
    return mappedValue;
  }
  return value;
}
`);
            } else {
                builder.addFragmentCode(`
uint64_t getMappedObjectId() {
  return getUint64DataValue();
}
`);
            }
            this.segmentColorShaderManager.defineShader(builder);
            builder.addUniform('highp vec4', 'uSelectedSegment', 2);
            builder.addUniform('highp float', 'uShowAllSegments');
            builder.addUniform('highp float', 'uSelectedAlpha');
            builder.addUniform('highp float', 'uNotSelectedAlpha');
            builder.setFragmentMain(`
  uint64_t value = getMappedObjectId();
  
  float alpha = uSelectedAlpha;
  float saturation = 1.0;
  if (value.low == vec4(0,0,0,0) && value.high == vec4(0,0,0,0)) {
    emit(vec4(vec4(0, 0, 0, 0)));
    return;
  }
  bool has = uShowAllSegments > 0.0 ? true : ${ this.hashTableManager.hasFunctionName }(value);
  if (uSelectedSegment[0] == value.low && uSelectedSegment[1] == value.high) {
    saturation = has ? 0.5 : 0.75;
  } else if (!has) {
    alpha = uNotSelectedAlpha;
  }
  vec3 rgb = segmentColorHash(value);
  emit(vec4(mix(vec3(1.0,1.0,1.0), rgb, saturation), alpha));
`);
        }
    }, {
        key: 'beginSlice',
        value: function beginSlice(sliceView) {
            var shader = _get(Object.getPrototypeOf(SegmentationRenderLayer.prototype), 'beginSlice', this).call(this, sliceView);
            var gl = this.gl;
            var displayState = this.displayState;
            var _displayState = this.displayState;
            var segmentSelectionState = _displayState.segmentSelectionState;
            var visibleSegments = _displayState.visibleSegments;

            if (!segmentSelectionState.hasSelectedSegment) {
                selectedSegmentForShader.fill(0);
            } else {
                var seg = segmentSelectionState.selectedSegment;
                var low = seg.low,
                    high = seg.high;
                for (var i = 0; i < 4; ++i) {
                    selectedSegmentForShader[i] = (low >> 8 * i & 0xFF) / 255.0;
                    selectedSegmentForShader[4 + i] = (high >> 8 * i & 0xFF) / 255.0;
                }
            }
            gl.uniform1f(shader.uniform('uSelectedAlpha'), this.selectedAlpha.value);
            gl.uniform1f(shader.uniform('uNotSelectedAlpha'), this.notSelectedAlpha.value);
            gl.uniform4fv(shader.uniform('uSelectedSegment'), selectedSegmentForShader);
            gl.uniform1f(shader.uniform('uShowAllSegments'), visibleSegments.hashTable.size ? 0.0 : 1.0);
            this.hashTableManager.enable(gl, shader, this.gpuHashTable);
            if (this.hasEquivalences) {
                this.equivalencesHashMap.update();
                this.equivalencesShaderManager.enable(gl, shader, this.gpuEquivalencesHashTable);
            }
            this.segmentColorShaderManager.enable(gl, shader, displayState.segmentColorHash);
            return shader;
        }
    }, {
        key: 'endSlice',
        value: function endSlice(shader) {
            var gl = this.gl;

            this.hashTableManager.disable(gl, shader);
            _get(Object.getPrototypeOf(SegmentationRenderLayer.prototype), 'endSlice', this).call(this, shader);
        }
    }]);

    return SegmentationRenderLayer;
}(renderlayer_1.RenderLayer);

exports.SegmentationRenderLayer = SegmentationRenderLayer;
;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var hash_table_1 = __webpack_require__(128);
var worker_rpc_1 = __webpack_require__(22);
var signals_1 = __webpack_require__(34);
var Uint64Set_1 = function (_worker_rpc_1$SharedO) {
    _inherits(Uint64Set, _worker_rpc_1$SharedO);

    function Uint64Set() {
        _classCallCheck(this, Uint64Set);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Uint64Set).call(this, ...args));

        _this.hashTable = new hash_table_1.HashSetUint64();
        _this.changed = new signals_1.Signal();
        return _this;
    }

    _createClass(Uint64Set, [{
        key: "disposed",
        value: function disposed() {
            _get(Object.getPrototypeOf(Uint64Set.prototype), "disposed", this).call(this);
            this.hashTable = undefined;
            this.changed = undefined;
        }
    }, {
        key: "add_",
        value: function add_(x) {
            return this.hashTable.add(x);
        }
    }, {
        key: "add",
        value: function add(x) {
            if (this.add_(x)) {
                var rpc = this.rpc;

                if (rpc) {
                    rpc.invoke('Uint64Set.add', { 'id': this.rpcId, 'value': x });
                }
                this.changed.dispatch(x, true);
            }
        }
    }, {
        key: "has",
        value: function has(x) {
            return this.hashTable.has(x);
        }
    }, {
        key: Symbol.iterator,
        value: function () {
            return this.hashTable.keys();
        }
    }, {
        key: "delete_",
        value: function delete_(x) {
            return this.hashTable.delete(x);
        }
    }, {
        key: "delete",
        value: function _delete(x) {
            if (this.delete_(x)) {
                var rpc = this.rpc;

                if (rpc) {
                    rpc.invoke('Uint64Set.delete', { 'id': this.rpcId, 'value': x });
                }
                this.changed.dispatch(x, false);
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            if (this.hashTable.clear()) {
                var rpc = this.rpc;

                if (rpc) {
                    rpc.invoke('Uint64Set.clear', { 'id': this.rpcId });
                }
                this.changed.dispatch(null, false);
            }
        }
    }, {
        key: "toJSON",
        value: function toJSON() {
            var result = new Array();
            for (var id of this) {
                result.push(id.toString());
            }
            return result;
        }
    }, {
        key: "size",
        get: function () {
            return this.hashTable.size;
        }
    }], [{
        key: "makeWithCounterpart",
        value: function makeWithCounterpart(rpc) {
            var obj = new Uint64Set_1();
            obj.initializeCounterpart(rpc);
            return obj;
        }
    }]);

    return Uint64Set;
}(worker_rpc_1.SharedObjectCounterpart);
var Uint64Set = Uint64Set_1;
Uint64Set = Uint64Set_1 = __decorate([worker_rpc_1.registerSharedObject('Uint64Set')], Uint64Set);
exports.Uint64Set = Uint64Set;
;
worker_rpc_1.registerRPC('Uint64Set.add', function (x) {
    var obj = this.get(x['id']);
    if (obj.add_(x['value'])) {
        obj.changed.dispatch();
    }
});
worker_rpc_1.registerRPC('Uint64Set.delete', function (x) {
    var obj = this.get(x['id']);
    if (obj.delete_(x['value'])) {
        obj.changed.dispatch();
    }
});
worker_rpc_1.registerRPC('Uint64Set.clear', function (x) {
    var obj = this.get(x['id']);
    if (obj.hashTable.clear()) {
        obj.changed.dispatch();
    }
});

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var uint64_1 = __webpack_require__(52);
__webpack_require__(73);
__webpack_require__(135);
var temp = new uint64_1.Uint64();

var SegmentSetWidget = function (_disposable_1$RefCoun) {
    _inherits(SegmentSetWidget, _disposable_1$RefCoun);

    function SegmentSetWidget(displayState) {
        _classCallCheck(this, SegmentSetWidget);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SegmentSetWidget).call(this));

        _this.displayState = displayState;
        _this.element = document.createElement('div');
        _this.clearButton = document.createElement('button');
        _this.itemContainer = document.createElement('span');
        _this.items = new Map();
        var element = _this.element;
        var clearButton = _this.clearButton;
        var itemContainer = _this.itemContainer;

        element.className = 'segment-set-widget noselect';
        clearButton.className = 'clear-button';
        clearButton.title = 'Remove all segment IDs';
        _this.registerEventListener(clearButton, 'click', () => {
            _this.visibleSegments.clear();
        });
        itemContainer.className = 'item-container';
        element.appendChild(itemContainer);
        itemContainer.appendChild(clearButton);
        _this.registerSignalBinding(displayState.visibleSegments.changed.add(_this.handleSetChanged, _this));
        _this.registerSignalBinding(displayState.segmentColorHash.changed.add(_this.handleColorChanged, _this));
        for (var x of displayState.visibleSegments) {
            _this.addElement(x.toString());
        }
        _this.updateClearButtonVisibility();
        return _this;
    }

    _createClass(SegmentSetWidget, [{
        key: 'updateClearButtonVisibility',
        value: function updateClearButtonVisibility() {
            var clearButton = this.clearButton;

            clearButton.style.display = this.displayState.visibleSegments.size > 0 ? '' : 'none';
        }
    }, {
        key: 'handleSetChanged',
        value: function handleSetChanged(x, added) {
            this.updateClearButtonVisibility();
            var items = this.items;

            if (x === null) {
                // Cleared.
                var itemContainer = this.itemContainer;
                var clearButton = this.clearButton;

                while (true) {
                    var lastElement = itemContainer.lastElementChild;
                    if (lastElement === clearButton) {
                        break;
                    }
                    itemContainer.removeChild(lastElement);
                }
                items.clear();
            } else if (added) {
                this.addElement(x.toString());
            } else {
                var s = x.toString();
                var itemElement = items.get(s);
                itemElement.parentElement.removeChild(itemElement);
                items.delete(s);
            }
        }
    }, {
        key: 'addElement',
        value: function addElement(s) {
            var itemElement = document.createElement('button');
            itemElement.className = 'segment-button';
            itemElement.textContent = s;
            itemElement.title = `Remove segment ID ${ s }`;
            var widget = this;
            itemElement.addEventListener('click', function () {
                temp.tryParseString(this.textContent);
                widget.visibleSegments.delete(temp);
            });
            itemElement.addEventListener('mouseenter', function () {
                temp.tryParseString(this.textContent);
                widget.segmentSelectionState.set(temp);
            });
            itemElement.addEventListener('mouseleave', function () {
                temp.tryParseString(this.textContent);
                widget.segmentSelectionState.set(null);
            });
            this.setItemColor(itemElement);
            this.itemContainer.appendChild(itemElement);
            this.items.set(s, itemElement);
        }
    }, {
        key: 'setItemColor',
        value: function setItemColor(itemElement) {
            temp.tryParseString(itemElement.textContent);
            itemElement.style.backgroundColor = this.segmentColorHash.computeCssColor(temp);
        }
    }, {
        key: 'handleColorChanged',
        value: function handleColorChanged() {
            this.items.forEach(itemElement => {
                this.setItemColor(itemElement);
            });
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            var element = this.element;
            var parentElement = element.parentElement;

            if (parentElement) {
                parentElement.removeChild(element);
            }
            _get(Object.getPrototypeOf(SegmentSetWidget.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'visibleSegments',
        get: function () {
            return this.displayState.visibleSegments;
        }
    }, {
        key: 'segmentColorHash',
        get: function () {
            return this.displayState.segmentColorHash;
        }
    }, {
        key: 'segmentSelectionState',
        get: function () {
            return this.displayState.segmentSelectionState;
        }
    }]);

    return SegmentSetWidget;
}(disposable_1.RefCounted);

exports.SegmentSetWidget = SegmentSetWidget;
;

/***/ },
/* 135 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var dom_1 = __webpack_require__(7);
var uint64_1 = __webpack_require__(52);
var signals_1 = __webpack_require__(34);
__webpack_require__(73);
__webpack_require__(137);

var Uint64EntryWidget = function (_disposable_1$RefCoun) {
    _inherits(Uint64EntryWidget, _disposable_1$RefCoun);

    function Uint64EntryWidget() {
        _classCallCheck(this, Uint64EntryWidget);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Uint64EntryWidget).call(this));

        _this.element = document.createElement('form');
        _this.label = document.createElement('label');
        _this.input = document.createElement('input');
        _this.value = new uint64_1.Uint64();
        _this.valueEntered = new signals_1.Signal();
        var element = _this.element;
        var label = _this.label;
        var input = _this.input;

        element.className = 'uint64-entry noselect';
        element.appendChild(label);
        label.appendChild(input);
        _this.registerEventListener(element, 'submit', event => {
            event.preventDefault();
            if (_this.validateInput()) {
                _this.input.value = '';
                _this.input.classList.remove('valid-input', 'invalid-input');
                _this.valueEntered.dispatch(_this.value);
            }
        });
        _this.registerEventListener(element, 'input', () => {
            if (_this.input.value === '') {
                _this.input.classList.remove('valid-input', 'invalid-input');
                return;
            }
            if (_this.validateInput()) {
                _this.input.classList.remove('invalid-input');
            } else {
                _this.input.classList.add('invalid-input');
            }
        });
        return _this;
    }

    _createClass(Uint64EntryWidget, [{
        key: 'validateInput',
        value: function validateInput() {
            return this.value.tryParseString(this.input.value);
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            dom_1.removeFromParent(this.element);
            _get(Object.getPrototypeOf(Uint64EntryWidget.prototype), 'disposed', this).call(this);
        }
    }]);

    return Uint64EntryWidget;
}(disposable_1.RefCounted);

exports.Uint64EntryWidget = Uint64EntryWidget;
;

/***/ },
/* 137 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 138 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 139 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var nextElementId = 0;
function associateLabelWithElement(label, element) {
    if (element.id === '') {
        element.id = `unique-id-for-association-${ nextElementId++ }`;
    }
    label.setAttribute('for', element.id);
}
exports.associateLabelWithElement = associateLabelWithElement;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debounce = __webpack_require__(43);
var disposable_1 = __webpack_require__(23);
var dom_1 = __webpack_require__(7);
var dropdown_1 = __webpack_require__(141);
var keyboard_shortcut_handler_1 = __webpack_require__(106);
var longest_common_prefix_1 = __webpack_require__(142);
var promise_1 = __webpack_require__(20);
var scroll_into_view_1 = __webpack_require__(143);
var associate_label_1 = __webpack_require__(139);
var signals_1 = __webpack_require__(34);
__webpack_require__(144);
var ACTIVE_COMPLETION_CLASS_NAME = 'autocomplete-completion-active';
var AUTOCOMPLETE_INDEX_SYMBOL = Symbol('autocompleteIndex');
function makeDefaultCompletionElement(completion) {
    var element = document.createElement('div');
    element.textContent = completion.value;
    return element;
}
exports.makeDefaultCompletionElement = makeDefaultCompletionElement;
function makeCompletionElementWithDescription(completion) {
    var element = document.createElement('div');
    element.className = 'autocomplete-completion-with-description';
    element.textContent = completion.value;
    var descriptionElement = document.createElement('div');
    descriptionElement.className = 'autocomplete-completion-description';
    descriptionElement.textContent = completion.description || '';
    element.appendChild(descriptionElement);
    return element;
}
exports.makeCompletionElementWithDescription = makeCompletionElementWithDescription;
var KEY_MAP = new keyboard_shortcut_handler_1.KeySequenceMap({
    'arrowdown': 'cycle-next-active-completion',
    'arrowup': 'cycle-prev-active-completion',
    'tab': 'choose-active-completion-or-prefix',
    'enter': 'choose-active-completion',
    'escape': 'cancel'
});
var KEY_COMMANDS = new Map([['cycle-next-active-completion', function () {
    this.cycleActiveCompletion(+1);
    return true;
}], ['cycle-prev-active-completion', function () {
    this.cycleActiveCompletion(-1);
    return true;
}], ['choose-active-completion-or-prefix', function () {
    return this.selectActiveCompletion( /*allowPrefix=*/true);
}], ['choose-active-completion', function () {
    return this.selectActiveCompletion( /*allowPrefix=*/false);
}], ['cancel', function () {
    return this.cancel();
}]]);
var DEFAULT_COMPLETION_DELAY = 200; // milliseconds

var AutocompleteTextInput = function (_disposable_1$RefCoun) {
    _inherits(AutocompleteTextInput, _disposable_1$RefCoun);

    function AutocompleteTextInput(options) {
        _classCallCheck(this, AutocompleteTextInput);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AutocompleteTextInput).call(this));

        _this.inputChanged = new signals_1.Signal();
        _this.prevInputValue = '';
        _this.completionsVisible = false;
        _this.activeCompletionPromise = null;
        _this.hasFocus = false;
        _this.completionResult = null;
        _this.dropdownContentsStale = true;
        _this.updateHintScrollPositionTimer = null;
        _this.completionElements = null;
        _this.hasResultForDropdown = false;
        _this.commonPrefix = '';
        /**
         * Index of the active completion.  The active completion is displayed as the hint text and is
         * highlighted in the dropdown.
         */
        _this.activeIndex = -1;
        _this.dropdownStyleStale = true;
        _this.completer = options.completer;
        var _options$delay = options.delay;
        var delay = _options$delay === undefined ? DEFAULT_COMPLETION_DELAY : _options$delay;

        var debouncedCompleter = _this.scheduleUpdateCompletions = debounce(() => {
            var activeCompletionPromise = _this.activeCompletionPromise = _this.completer(_this.value);
            if (activeCompletionPromise !== null) {
                activeCompletionPromise.then(completionResult => {
                    if (_this.activeCompletionPromise === activeCompletionPromise) {
                        _this.setCompletions(completionResult);
                        _this.activeCompletionPromise = null;
                    }
                });
            }
        }, delay);
        _this.registerDisposer(() => {
            debouncedCompleter.cancel();
        });
        var element = _this.element = document.createElement('div');
        element.className = 'autocomplete';
        var dropdownAndInputWrapper = document.createElement('div');
        dropdownAndInputWrapper.className = 'autocomplete-dropdown-wrapper';
        var dropdownElement = _this.dropdownElement = document.createElement('div');
        dropdownElement.className = 'autocomplete-dropdown';
        var promptElement = _this.promptElement = document.createElement('label');
        promptElement.className = 'autocomplete-prompt';
        var inputWrapperElement = _this.inputWrapperElement = document.createElement('div');
        inputWrapperElement.className = 'autocomplete-input-wrapper';
        element.appendChild(promptElement);
        var inputElement = _this.inputElement = document.createElement('input');
        inputElement.type = 'text';
        inputElement.autocomplete = 'off';
        inputElement.spellcheck = false;
        inputElement.className = 'autocomplete-input';
        associate_label_1.associateLabelWithElement(promptElement, inputElement);
        var hintElement = _this.hintElement = document.createElement('input');
        hintElement.type = 'text';
        hintElement.spellcheck = false;
        hintElement.className = 'autocomplete-hint';
        hintElement.disabled = true;
        inputWrapperElement.appendChild(hintElement);
        inputWrapperElement.appendChild(inputElement);
        dropdownAndInputWrapper.appendChild(inputWrapperElement);
        dropdownAndInputWrapper.appendChild(dropdownElement);
        element.appendChild(dropdownAndInputWrapper);
        _this.registerInputHandler();
        _this.handleInputChanged('');
        _this.registerEventListener(_this.inputElement, 'focus', () => {
            if (!_this.hasFocus) {
                _this.hasFocus = true;
                _this.dropdownStyleStale = true;
                _this.updateDropdown();
            }
        });
        _this.registerEventListener(_this.inputElement, 'blur', () => {
            if (_this.hasFocus) {
                _this.hasFocus = false;
                _this.updateDropdown();
            }
        });
        _this.registerEventListener(element.ownerDocument.defaultView, 'resize', () => {
            _this.dropdownStyleStale = true;
        });
        _this.registerEventListener(element.ownerDocument.defaultView, 'scroll', () => {
            _this.dropdownStyleStale = true;
        });
        _this.registerEventListener(_this.dropdownElement, 'mousedown', _this.handleDropdownMousedown.bind(_this));
        _this.registerEventListener(_this.inputElement, 'keydown', () => {
            // User may have used a keyboard shortcut to scroll the input.
            _this.hintScrollPositionMayBeStale();
        });
        _this.registerEventListener(_this.inputElement, 'mousemove', event => {
            if (event.buttons !== 0) {
                // May be dragging the text, which could cause scrolling.  This is not perfect, because we
                // don't detect mouse movements outside of the input box.
                _this.hintScrollPositionMayBeStale();
            }
        });
        var keyboardHandler = _this.keyboardHandler = _this.registerDisposer(new keyboard_shortcut_handler_1.KeyboardShortcutHandler(inputElement, KEY_MAP, _this.handleKeyCommand.bind(_this)));
        keyboardHandler.allShortcutsAreGlobal = true;
        return _this;
    }

    _createClass(AutocompleteTextInput, [{
        key: 'hintScrollPositionMayBeStale',
        value: function hintScrollPositionMayBeStale() {
            if (this.hintElement.value !== '') {
                this.scheduleUpdateHintScrollPosition();
            }
        }
    }, {
        key: 'handleDropdownMousedown',
        value: function handleDropdownMousedown(event) {
            this.inputElement.focus();
            var dropdownElement = this.dropdownElement;

            for (var target = event.target; target instanceof HTMLElement; target = target.parentElement) {
                var index = target[AUTOCOMPLETE_INDEX_SYMBOL];
                if (index !== undefined) {
                    this.selectCompletion(index);
                    break;
                }
                if (target === dropdownElement) {
                    break;
                }
            }
            event.preventDefault();
        }
    }, {
        key: 'cycleActiveCompletion',
        value: function cycleActiveCompletion(delta) {
            if (this.completionResult === null) {
                return;
            }
            var activeIndex = this.activeIndex;

            var numCompletions = this.completionResult.completions.length;
            if (activeIndex === -1) {
                if (delta > 0) {
                    activeIndex = 0;
                } else {
                    activeIndex = numCompletions - 1;
                }
            } else {
                activeIndex = (activeIndex + delta + numCompletions) % numCompletions;
            }
            this.setActiveIndex(activeIndex);
        }
    }, {
        key: 'handleKeyCommand',
        value: function handleKeyCommand(action) {
            return KEY_COMMANDS.get(action).call(this);
        }
    }, {
        key: 'registerInputHandler',
        value: function registerInputHandler() {
            var handler = event => {
                var value = this.inputElement.value;
                if (value !== this.prevInputValue) {
                    this.prevInputValue = value;
                    this.handleInputChanged(value);
                }
            };
            for (var eventType of ['input']) {
                this.registerEventListener(this.inputElement, eventType, handler, /*useCapture=*/false);
            }
        }
    }, {
        key: 'shouldShowDropdown',
        value: function shouldShowDropdown() {
            var completionResult = this.completionResult;

            if (completionResult === null || !this.hasFocus) {
                return false;
            }
            return this.hasResultForDropdown;
        }
    }, {
        key: 'updateDropdownStyle',
        value: function updateDropdownStyle() {
            var element = this.element;
            var dropdownElement = this.dropdownElement;
            var inputElement = this.inputElement;

            dropdown_1.positionDropdown(dropdownElement, inputElement, { horizontal: false });
            this.dropdownStyleStale = false;
        }
    }, {
        key: 'updateDropdown',
        value: function updateDropdown() {
            var _this2 = this;

            if (this.shouldShowDropdown()) {
                (function () {
                    var dropdownElement = _this2.dropdownElement;
                    var activeIndex = _this2.activeIndex;

                    if (_this2.dropdownContentsStale) {
                        (function () {
                            var completionResult = _this2.completionResult;
                            var _completionResult$mak = completionResult.makeElement;
                            var makeElement = _completionResult$mak === undefined ? makeDefaultCompletionElement : _completionResult$mak;

                            _this2.completionElements = completionResult.completions.map((completion, index) => {
                                var completionElement = makeElement.call(completionResult, completion);
                                completionElement[AUTOCOMPLETE_INDEX_SYMBOL] = index;
                                completionElement.classList.add('autocomplete-completion');
                                if (activeIndex === index) {
                                    completionElement.classList.add(ACTIVE_COMPLETION_CLASS_NAME);
                                }
                                dropdownElement.appendChild(completionElement);
                                return completionElement;
                            });
                            _this2.dropdownContentsStale = false;
                        })();
                    }
                    if (_this2.dropdownStyleStale) {
                        _this2.updateDropdownStyle();
                    }
                    if (!_this2.completionsVisible) {
                        dropdownElement.style.display = 'block';
                        _this2.completionsVisible = true;
                    }
                    if (activeIndex !== -1) {
                        var completionElement = _this2.completionElements[activeIndex];
                        scroll_into_view_1.scrollIntoViewIfNeeded(completionElement);
                    }
                })();
            } else if (this.completionsVisible) {
                this.dropdownElement.style.display = 'none';
                this.completionsVisible = false;
            }
        }
    }, {
        key: 'setCompletions',
        value: function setCompletions(completionResult) {
            this.clearCompletions();
            var completions = completionResult.completions;

            if (completions.length === 0) {
                return;
            }
            this.completionResult = completionResult;
            if (completions.length === 1) {
                var completion = completions[0];
                if (completionResult.showSingleResult) {
                    this.hasResultForDropdown = true;
                } else {
                    var value = this.prevInputValue;
                    if (!completion.value.startsWith(value)) {
                        this.hasResultForDropdown = true;
                    } else {
                        this.hasResultForDropdown = false;
                    }
                }
                if (completionResult.selectSingleResult) {
                    this.setActiveIndex(0);
                } else {
                    this.setHintValue(this.getCompletedValueByIndex(0));
                }
            } else {
                this.hasResultForDropdown = true;
                // Check for a common prefix.
                var commonResultPrefix = longest_common_prefix_1.longestCommonPrefix(function* () {
                    for (var _completion of completionResult.completions) {
                        yield _completion.value;
                    }
                }());
                var commonPrefix = this.getCompletedValue(commonResultPrefix);
                var _value = this.prevInputValue;
                if (commonPrefix.startsWith(_value)) {
                    this.commonPrefix = commonPrefix;
                    this.setHintValue(commonPrefix);
                }
            }
            this.updateDropdown();
        }
    }, {
        key: 'scheduleUpdateHintScrollPosition',
        value: function scheduleUpdateHintScrollPosition() {
            if (this.updateHintScrollPositionTimer === null) {
                this.updateHintScrollPositionTimer = setTimeout(() => {
                    this.updateHintScrollPosition();
                }, 0);
            }
        }
    }, {
        key: 'setHintValue',
        value: function setHintValue(hintValue) {
            var value = this.prevInputValue;
            if (hintValue === value || !hintValue.startsWith(value)) {
                // If the hint value is identical to the current value, there is no need to show it.  Also,
                // if it is not a prefix of the current value, then we cannot show it either.
                hintValue = '';
            }
            this.hintElement.value = hintValue;
            this.scheduleUpdateHintScrollPosition();
        }
        /**
         * This sets the active completion, which causes it to be highlighted and displayed as the hint.
         * Additionally, if the user hits tab then it is chosen.
         */

    }, {
        key: 'setActiveIndex',
        value: function setActiveIndex(index) {
            if (!this.dropdownContentsStale) {
                var activeIndex = this.activeIndex;

                if (activeIndex !== -1) {
                    this.completionElements[activeIndex].classList.remove(ACTIVE_COMPLETION_CLASS_NAME);
                }
                if (index !== -1) {
                    var completionElement = this.completionElements[index];
                    completionElement.classList.add(ACTIVE_COMPLETION_CLASS_NAME);
                    scroll_into_view_1.scrollIntoViewIfNeeded(completionElement);
                }
            }
            if (index !== -1) {
                this.setHintValue(this.getCompletedValueByIndex(index));
            }
            this.activeIndex = index;
        }
    }, {
        key: 'getCompletedValueByIndex',
        value: function getCompletedValueByIndex(index) {
            return this.getCompletedValue(this.completionResult.completions[index].value);
        }
    }, {
        key: 'getCompletedValue',
        value: function getCompletedValue(completionValue) {
            var completionResult = this.completionResult;
            var value = this.prevInputValue;
            return value.substring(0, completionResult.offset) + completionValue;
        }
    }, {
        key: 'selectActiveCompletion',
        value: function selectActiveCompletion(allowPrefix) {
            var activeIndex = this.activeIndex;

            if (activeIndex === -1) {
                if (!allowPrefix) {
                    return false;
                }
                var completionResult = this.completionResult;

                if (completionResult !== null && completionResult.completions.length === 1) {
                    activeIndex = 0;
                } else {
                    var commonPrefix = this.commonPrefix;

                    if (commonPrefix.length > this.value.length) {
                        this.value = commonPrefix;
                        return true;
                    }
                    return false;
                }
            }
            var newValue = this.getCompletedValueByIndex(activeIndex);
            if (this.value === newValue) {
                return false;
            }
            this.value = newValue;
            return true;
        }
    }, {
        key: 'selectCompletion',
        value: function selectCompletion(index) {
            this.value = this.getCompletedValueByIndex(index);
        }
        /**
         * Called when user presses escape.  Does nothing here, but may be overridden in a subclass.
         */

    }, {
        key: 'cancel',
        value: function cancel() {
            return false;
        }
        /**
         * Updates the hintElement scroll position to match the scroll position of inputElement.
         *
         * This is called asynchronously after the input changes because automatic scrolling appears to
         * take place after the 'input' event fires.
         */

    }, {
        key: 'updateHintScrollPosition',
        value: function updateHintScrollPosition() {
            this.updateHintScrollPositionTimer = null;
            this.hintElement.scrollLeft = this.inputElement.scrollLeft;
        }
    }, {
        key: 'cancelActiveCompletion',
        value: function cancelActiveCompletion() {
            promise_1.cancelPromise(this.activeCompletionPromise);
            this.activeCompletionPromise = null;
        }
    }, {
        key: 'handleInputChanged',
        value: function handleInputChanged(value) {
            this.cancelActiveCompletion();
            this.hintElement.value = '';
            this.clearCompletions();
            this.inputChanged.dispatch(value);
            this.scheduleUpdateCompletions();
        }
    }, {
        key: 'clearCompletions',
        value: function clearCompletions() {
            if (this.completionResult !== null) {
                this.activeIndex = -1;
                this.completionResult = null;
                this.completionElements = null;
                this.dropdownContentsStale = true;
                this.dropdownStyleStale = true;
                this.commonPrefix = '';
                dom_1.removeChildren(this.dropdownElement);
                this.updateDropdown();
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            dom_1.removeFromParent(this.element);
            this.cancelActiveCompletion();
            if (this.updateHintScrollPositionTimer !== null) {
                clearTimeout(this.updateHintScrollPositionTimer);
                this.updateHintScrollPositionTimer = null;
            }
            _get(Object.getPrototypeOf(AutocompleteTextInput.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'disabled',
        get: function () {
            return this.inputElement.disabled;
        },
        set: function (value) {
            this.inputElement.disabled = value;
        }
    }, {
        key: 'value',
        get: function () {
            return this.prevInputValue;
        },
        set: function (value) {
            if (value !== this.prevInputValue) {
                this.inputElement.value = value;
                this.prevInputValue = value;
                this.handleInputChanged(value);
            }
        }
    }]);

    return AutocompleteTextInput;
}(disposable_1.RefCounted);

exports.AutocompleteTextInput = AutocompleteTextInput;
;

/***/ },
/* 141 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Utilities for positioning dropdown menus.
 */

function positionDropdown(dropdownElement, associatedElement) {
    var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref$horizontal = _ref.horizontal;
    var horizontal = _ref$horizontal === undefined ? false : _ref$horizontal;
    var _ref$vertical = _ref.vertical;
    var vertical = _ref$vertical === undefined ? true : _ref$vertical;
    var _ref$topMargin = _ref.topMargin;
    var topMargin = _ref$topMargin === undefined ? 6 : _ref$topMargin;
    var _ref$bottomMargin = _ref.bottomMargin;
    var bottomMargin = _ref$bottomMargin === undefined ? 6 : _ref$bottomMargin;
    var _ref$leftMargin = _ref.leftMargin;
    var leftMargin = _ref$leftMargin === undefined ? 6 : _ref$leftMargin;
    var _ref$rightMargin = _ref.rightMargin;
    var rightMargin = _ref$rightMargin === undefined ? 6 : _ref$rightMargin;
    var _ref$maxHeight = _ref.maxHeight;
    var maxHeight = _ref$maxHeight === undefined ? true : _ref$maxHeight;
    var _ref$maxWidth = _ref.maxWidth;
    var maxWidth = _ref$maxWidth === undefined ? true : _ref$maxWidth;

    var rect = associatedElement.getBoundingClientRect();
    if (horizontal) {
        var viewportWidth = dropdownElement.ownerDocument.documentElement.clientHeight;
        var distanceLeft = rect.right;
        var distanceRight = viewportWidth - rect.left;
        if (distanceLeft > distanceRight) {
            dropdownElement.style.left = '';
            dropdownElement.style.right = '0';
            if (maxWidth) {
                dropdownElement.style.maxWidth = distanceLeft - leftMargin + 'px';
            }
        } else {
            dropdownElement.style.right = '';
            dropdownElement.style.left = '0';
            if (maxWidth) {
                dropdownElement.style.maxWidth = distanceRight - rightMargin + 'px';
            }
        }
    }
    if (vertical) {
        var viewportHeight = dropdownElement.ownerDocument.documentElement.clientHeight;
        var distanceToTop = rect.top - topMargin;
        var distanceToBottom = viewportHeight - rect.bottom - bottomMargin;
        if (distanceToTop > distanceToBottom * 3) {
            dropdownElement.style.top = '';
            dropdownElement.style.bottom = '100%';
            if (maxHeight) {
                dropdownElement.style.maxHeight = distanceToTop + 'px';
            }
        } else {
            dropdownElement.style.top = '100%';
            dropdownElement.style.bottom = '';
            if (maxHeight) {
                dropdownElement.style.maxHeight = distanceToBottom + 'px';
            }
        }
    }
}
exports.positionDropdown = positionDropdown;

/***/ },
/* 142 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * Returns the longest common prefix of a sequence of strings.
 *
 * Returns '' if the sequence of strings is empty.
 */

function longestCommonPrefix(strings) {
    var it = strings[Symbol.iterator]();

    var _it$next = it.next();

    var firstValue = _it$next.value;
    var noValues = _it$next.done;

    if (noValues) {
        // The sequence of strings is empty.
        return '';
    }
    var commonPrefixLength = firstValue.length;
    while (commonPrefixLength > 0) {
        var _it$next2 = it.next();

        var value = _it$next2.value;
        var done = _it$next2.done;

        if (done) {
            break;
        }
        var i = 0;
        for (; i < commonPrefixLength; ++i) {
            if (firstValue.charCodeAt(i) !== value.charCodeAt(i)) {
                break;
            }
        }
        commonPrefixLength = i;
    }
    return firstValue.substring(0, commonPrefixLength);
}
exports.longestCommonPrefix = longestCommonPrefix;

/***/ },
/* 143 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function scrollIntoViewIfNeeded(element) {
    var parent = element.parentElement;
    var elementLeft = element.offsetLeft - parent.clientLeft;
    var elementTop = element.offsetTop - parent.clientTop;
    var elementRight = elementLeft + element.offsetWidth;
    var elementBottom = elementTop + element.offsetHeight;
    var parentWidth = parent.clientWidth;
    var parentHeight = parent.clientHeight;
    var viewportLeft = parent.scrollLeft;
    var viewportRight = viewportLeft + parentWidth;
    var viewportTop = parent.scrollTop;
    var viewportBottom = viewportTop + parentHeight;
    var scrollLeftDelta = Math.max(0.0, elementRight - viewportRight) || Math.min(0.0, elementLeft - viewportLeft);
    var scrollTopDelta = Math.max(0.0, elementBottom - viewportBottom) || Math.min(0.0, elementTop - viewportTop);
    parent.scrollLeft += scrollLeftDelta;
    parent.scrollTop += scrollTopDelta;
}
exports.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;

/***/ },
/* 144 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 145 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
/**
 * This creates a form submit button that is not displayed, in order that the form may be submitted
 * using the enter key.
 */

function makeHiddenSubmitButton() {
  var element = document.createElement('button');
  element.type = 'submit';
  element.className = 'hidden-submit-button';
  // We apply these styles directly to the element rather than by styling the class in order to
  // avoid them being overridden accidentally.
  element.style.margin = '0';
  element.style.border = '0';
  element.style.padding = '0';
  element.style.width = '0';
  element.style.height = '0';
  element.style.overflow = 'hidden';
  element.tabIndex = -1;
  return element;
}
exports.makeHiddenSubmitButton = makeHiddenSubmitButton;

/***/ },
/* 146 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var layer_dialog_1 = __webpack_require__(109);
var layer_specification_1 = __webpack_require__(110);
var disposable_1 = __webpack_require__(23);
var dom_1 = __webpack_require__(7);
var dropdown_1 = __webpack_require__(141);
// Sortable must be imported using non-ES6 module syntax because of how it is exported.
var Sortable = __webpack_require__(148);
__webpack_require__(73);
__webpack_require__(149);

var LayerWidget = function (_disposable_1$RefCoun) {
    _inherits(LayerWidget, _disposable_1$RefCoun);

    function LayerWidget(layer, panel) {
        _classCallCheck(this, LayerWidget);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LayerWidget).call(this));

        _this.layer = layer;
        _this.panel = panel;
        var element = _this.element = document.createElement('span');
        element.className = 'layer-item-parent noselect';
        var widgetElement = _this.widgetElement = document.createElement('span');
        widgetElement.className = 'layer-item noselect';
        element.appendChild(widgetElement);
        var labelElement = _this.labelElement = document.createElement('span');
        labelElement.className = 'layer-item-label';
        var layerNumberElement = _this.layerNumberElement = document.createElement('span');
        layerNumberElement.className = 'layer-item-number';
        var valueElement = _this.valueElement = document.createElement('span');
        valueElement.className = 'layer-item-value';
        var closeElement = document.createElement('span');
        closeElement.title = 'Delete layer';
        closeElement.className = 'layer-item-close';
        _this.registerEventListener(closeElement, 'click', event => {
            _this.panel.layerManager.removeManagedLayer(_this.layer);
        });
        widgetElement.appendChild(layerNumberElement);
        widgetElement.appendChild(labelElement);
        widgetElement.appendChild(valueElement);
        widgetElement.appendChild(closeElement);
        _this.registerEventListener(widgetElement, 'click', event => {
            layer.setVisible(!layer.visible);
        });
        // Hide the dropdown menu while dragging.  We can't wait until the onStart handler from
        // Sortablejs fires because it occurs too late to affect what is shown while dragging.
        _this.registerEventListener(element, 'mousedown', event => {
            if (event.button === 0) {
                _this.panel.setDragging(true);
            }
        });
        _this.registerEventListener(element, 'mouseup', event => {
            if (event.button === 0) {
                _this.panel.setDragging(false);
            }
        });
        _this.registerEventListener(widgetElement, 'dblclick', event => {
            if (layer instanceof layer_specification_1.ManagedUserLayerWithSpecification) {
                new layer_dialog_1.LayerDialog(_this.panel.manager, layer);
            }
        });
        var dropdownElement = _this.dropdownElement = document.createElement('div');
        _this.registerEventListener(dropdownElement, 'mousedown', event => {
            // Prevent clicks on the dropdown from triggering dragging.
            event.stopPropagation();
        });
        _this.setupDropdownElement();
        _this.handleLayerChanged();
        _this.registerSignalBinding(layer.layerChanged.add(_this.handleLayerChanged, _this));
        element.appendChild(dropdownElement);
        _this.registerEventListener(element, 'mouseenter', () => {
            _this.hovering = true;
            _this.updateDropdownState();
        });
        _this.registerEventListener(element, 'mouseleave', event => {
            _this.hovering = false;
            _this.updateDropdownState();
        });
        return _this;
    }

    _createClass(LayerWidget, [{
        key: 'updateDropdownState',
        value: function updateDropdownState() {
            var style = this.dropdownElement.style;
            if (this.hovering && !this.panel.dragging && this.dropdownElement.childElementCount > 0) {
                if (style.display !== 'flex') {
                    style.display = 'flex';
                    if (this.dropdown) {
                        this.dropdown.onShow();
                    }
                }
                dropdown_1.positionDropdown(this.dropdownElement, this.widgetElement);
            } else {
                if (style.display !== 'none') {
                    this.dropdownElement.style.display = 'none';
                    if (this.dropdown) {
                        this.dropdown.onHide();
                    }
                }
            }
        }
    }, {
        key: 'setupDropdownElement',
        value: function setupDropdownElement() {
            this.dropdownElement.className = 'layer-dropdown';
        }
    }, {
        key: 'update',
        value: function update() {
            var layer = this.layer;

            this.labelElement.textContent = layer.name;
            this.widgetElement.setAttribute('layer-visible', layer.visible.toString());
        }
    }, {
        key: 'handleLayerChanged',
        value: function handleLayerChanged() {
            var layer = this.layer;

            var userLayer = layer.layer;
            if (userLayer !== this.userLayer) {
                if (this.dropdown) {
                    this.dropdown.dispose();
                    dom_1.removeChildren(this.dropdownElement);
                    this.setupDropdownElement();
                }
                this.userLayer = userLayer;
                if (userLayer) {
                    this.dropdown = userLayer.makeDropdown(this.dropdownElement);
                } else {
                    this.dropdown = undefined;
                }
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            if (this.dropdown) {
                this.dropdown.dispose();
            }
            this.element.parentElement.removeChild(this.element);
            _get(Object.getPrototypeOf(LayerWidget.prototype), 'disposed', this).call(this);
        }
    }]);

    return LayerWidget;
}(disposable_1.RefCounted);

var LayerPanel = function (_disposable_1$RefCoun2) {
    _inherits(LayerPanel, _disposable_1$RefCoun2);

    function LayerPanel(element, manager) {
        _classCallCheck(this, LayerPanel);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(LayerPanel).call(this));

        _this2.element = element;
        _this2.manager = manager;
        _this2.layerWidgets = new Map();
        _this2.layerUpdateNeeded = true;
        _this2.valueUpdateNeeded = false;
        _this2.dragging = false;
        element.className = 'layer-panel';
        _this2.registerSignalBinding(manager.layerSelectedValues.changed.add(_this2.handleLayerValuesChanged, _this2));
        _this2.registerSignalBinding(manager.layerManager.layersChanged.add(_this2.handleLayersChanged, _this2));
        var addButton = _this2.addButton = document.createElement('button');
        addButton.className = 'layer-add-button';
        addButton.title = 'Add layer';
        _this2.registerEventListener(addButton, 'click', () => {
            _this2.addLayerMenu();
        });
        element.appendChild(addButton);
        _this2.update();
        var sortable = new Sortable(_this2.element, {
            draggable: '.layer-item-parent',
            onStart: evt => {
                _this2.setDragging(true);
                _this2.element.classList.add('sorting-in-progress');
            },
            onEnd: evt => {
                _this2.setDragging(false);
                _this2.element.classList.remove('sorting-in-progress');
                _this2.layerManager.reorderManagedLayer(evt.oldIndex, evt.newIndex);
            },
            onMove: evt => {
                return evt.related !== _this2.addButton;
            }
        });
        _this2.registerDisposer(() => {
            sortable.destroy();
        });
        return _this2;
    }

    _createClass(LayerPanel, [{
        key: 'setDragging',
        value: function setDragging(value) {
            this.dragging = value;
            for (var widget of this.layerWidgets.values()) {
                widget.updateDropdownState();
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            this.layerWidgets.forEach(x => x.dispose());
            this.layerWidgets = undefined;
            _get(Object.getPrototypeOf(LayerPanel.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'handleLayersChanged',
        value: function handleLayersChanged() {
            this.layerUpdateNeeded = true;
            this.handleLayerValuesChanged();
        }
    }, {
        key: 'handleLayerValuesChanged',
        value: function handleLayerValuesChanged() {
            if (!this.valueUpdateNeeded) {
                this.valueUpdateNeeded = true;
                requestAnimationFrame(this.update.bind(this));
            }
        }
    }, {
        key: 'update',
        value: function update() {
            this.valueUpdateNeeded = false;
            this.updateLayers();
            var values = this.manager.layerSelectedValues;
            for (var _ref3 of this.layerWidgets) {
                var _ref2 = _slicedToArray(_ref3, 2);

                var layer = _ref2[0];
                var widget = _ref2[1];

                var userLayer = layer.layer;
                var text = '';
                if (userLayer !== null) {
                    var value = values.get(userLayer);
                    if (value !== undefined) {
                        text = '' + value;
                    }
                }
                widget.valueElement.textContent = text;
            }
        }
    }, {
        key: 'updateLayers',
        value: function updateLayers() {
            if (!this.layerUpdateNeeded) {
                return;
            }
            this.layerUpdateNeeded = false;
            var container = this.element;
            var layers = new Set();
            var nextChild = container.firstElementChild;
            this.manager.layerManager.managedLayers.forEach((layer, layerIndex) => {
                layers.add(layer);
                var widget = this.layerWidgets.get(layer);
                if (widget === undefined) {
                    widget = new LayerWidget(layer, this);
                    this.layerWidgets.set(layer, widget);
                }
                widget.layerNumberElement.textContent = '' + (1 + layerIndex);
                widget.update();
                var _widget = widget;
                var element = _widget.element;

                if (element !== nextChild) {
                    container.insertBefore(widget.element, this.addButton);
                }
            });
            for (var _ref6 of this.layerWidgets) {
                var _ref5 = _slicedToArray(_ref6, 2);

                var layer = _ref5[0];
                var widget = _ref5[1];

                if (!layers.has(layer)) {
                    this.layerWidgets.delete(layer);
                    widget.dispose();
                }
            }
        }
    }, {
        key: 'addLayerMenu',
        value: function addLayerMenu() {
            // Automatically destroys itself when it exits.
            new layer_dialog_1.LayerDialog(this.manager);
        }
    }, {
        key: 'layerManager',
        get: function () {
            return this.manager.layerManager;
        }
    }]);

    return LayerPanel;
}(disposable_1.RefCounted);

exports.LayerPanel = LayerPanel;
;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**!
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */


(function (factory) {
	"use strict";

	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else if (typeof module != "undefined" && typeof module.exports != "undefined") {
		module.exports = factory();
	}
	else if (typeof Package !== "undefined") {
		Sortable = factory();  // export for Meteor.js
	}
	else {
		/* jshint sub:true */
		window["Sortable"] = factory();
	}
})(function () {
	"use strict";

	var dragEl,
		parentEl,
		ghostEl,
		cloneEl,
		rootEl,
		nextEl,

		scrollEl,
		scrollParentEl,

		lastEl,
		lastCSS,
		lastParentCSS,

		oldIndex,
		newIndex,

		activeGroup,
		autoScroll = {},

		tapEvt,
		touchEvt,

		moved,

		/** @const */
		RSPACE = /\s+/g,

		expando = 'Sortable' + (new Date).getTime(),

		win = window,
		document = win.document,
		parseInt = win.parseInt,

		supportDraggable = !!('draggable' in document.createElement('div')),
		supportCssPointerEvents = (function (el) {
			el = document.createElement('x');
			el.style.cssText = 'pointer-events:auto';
			return el.style.pointerEvents === 'auto';
		})(),

		_silent = false,

		abs = Math.abs,
		slice = [].slice,

		touchDragOverListeners = [],

		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
			// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
			if (rootEl && options.scroll) {
				var el,
					rect,
					sens = options.scrollSensitivity,
					speed = options.scrollSpeed,

					x = evt.clientX,
					y = evt.clientY,

					winWidth = window.innerWidth,
					winHeight = window.innerHeight,

					vx,
					vy
				;

				// Delect scrollEl
				if (scrollParentEl !== rootEl) {
					scrollEl = options.scroll;
					scrollParentEl = rootEl;

					if (scrollEl === true) {
						scrollEl = rootEl;

						do {
							if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||
								(scrollEl.offsetHeight < scrollEl.scrollHeight)
							) {
								break;
							}
							/* jshint boss:true */
						} while (scrollEl = scrollEl.parentNode);
					}
				}

				if (scrollEl) {
					el = scrollEl;
					rect = scrollEl.getBoundingClientRect();
					vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
					vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
				}


				if (!(vx || vy)) {
					vx = (winWidth - x <= sens) - (x <= sens);
					vy = (winHeight - y <= sens) - (y <= sens);

					/* jshint expr:true */
					(vx || vy) && (el = win);
				}


				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
					autoScroll.el = el;
					autoScroll.vx = vx;
					autoScroll.vy = vy;

					clearInterval(autoScroll.pid);

					if (el) {
						autoScroll.pid = setInterval(function () {
							if (el === win) {
								win.scrollTo(win.pageXOffset + vx * speed, win.pageYOffset + vy * speed);
							} else {
								vy && (el.scrollTop += vy * speed);
								vx && (el.scrollLeft += vx * speed);
							}
						}, 24);
					}
				}
			}
		}, 30),

		_prepareGroup = function (options) {
			var group = options.group;

			if (!group || typeof group != 'object') {
				group = options.group = {name: group};
			}

			['pull', 'put'].forEach(function (key) {
				if (!(key in group)) {
					group[key] = true;
				}
			});

			options.groups = ' ' + group.name + (group.put.join ? ' ' + group.put.join(' ') : '') + ' ';
		}
	;



	/**
	 * @class  Sortable
	 * @param  {HTMLElement}  el
	 * @param  {Object}       [options]
	 */
	function Sortable(el, options) {
		if (!(el && el.nodeType && el.nodeType === 1)) {
			throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
		}

		this.el = el; // root element
		this.options = options = _extend({}, options);


		// Export instance
		el[expando] = this;


		// Default options
		var defaults = {
			group: Math.random(),
			sort: true,
			disabled: false,
			store: null,
			handle: null,
			scroll: true,
			scrollSensitivity: 30,
			scrollSpeed: 10,
			draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
			ghostClass: 'sortable-ghost',
			chosenClass: 'sortable-chosen',
			ignore: 'a, img',
			filter: null,
			animation: 0,
			setData: function (dataTransfer, dragEl) {
				dataTransfer.setData('Text', dragEl.textContent);
			},
			dropBubble: false,
			dragoverBubble: false,
			dataIdAttr: 'data-id',
			delay: 0,
			forceFallback: false,
			fallbackClass: 'sortable-fallback',
			fallbackOnBody: false
		};


		// Set default options
		for (var name in defaults) {
			!(name in options) && (options[name] = defaults[name]);
		}

		_prepareGroup(options);

		// Bind all private methods
		for (var fn in this) {
			if (fn.charAt(0) === '_') {
				this[fn] = this[fn].bind(this);
			}
		}

		// Setup drag mode
		this.nativeDraggable = options.forceFallback ? false : supportDraggable;

		// Bind events
		_on(el, 'mousedown', this._onTapStart);
		_on(el, 'touchstart', this._onTapStart);

		if (this.nativeDraggable) {
			_on(el, 'dragover', this);
			_on(el, 'dragenter', this);
		}

		touchDragOverListeners.push(this._onDragOver);

		// Restore sorting
		options.store && this.sort(options.store.get(this));
	}


	Sortable.prototype = /** @lends Sortable.prototype */ {
		constructor: Sortable,

		_onTapStart: function (/** Event|TouchEvent */evt) {
			var _this = this,
				el = this.el,
				options = this.options,
				type = evt.type,
				touch = evt.touches && evt.touches[0],
				target = (touch || evt).target,
				originalTarget = target,
				filter = options.filter;


			if (type === 'mousedown' && evt.button !== 0 || options.disabled) {
				return; // only left button or enabled
			}

			target = _closest(target, options.draggable, el);

			if (!target) {
				return;
			}

			// get the index of the dragged element within its parent
			oldIndex = _index(target);

			// Check filter
			if (typeof filter === 'function') {
				if (filter.call(this, evt, target, this)) {
					_dispatchEvent(_this, originalTarget, 'filter', target, el, oldIndex);
					evt.preventDefault();
					return; // cancel dnd
				}
			}
			else if (filter) {
				filter = filter.split(',').some(function (criteria) {
					criteria = _closest(originalTarget, criteria.trim(), el);

					if (criteria) {
						_dispatchEvent(_this, criteria, 'filter', target, el, oldIndex);
						return true;
					}
				});

				if (filter) {
					evt.preventDefault();
					return; // cancel dnd
				}
			}


			if (options.handle && !_closest(originalTarget, options.handle, el)) {
				return;
			}


			// Prepare `dragstart`
			this._prepareDragStart(evt, touch, target);
		},

		_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target) {
			var _this = this,
				el = _this.el,
				options = _this.options,
				ownerDocument = el.ownerDocument,
				dragStartFn;

			if (target && !dragEl && (target.parentNode === el)) {
				tapEvt = evt;

				rootEl = el;
				dragEl = target;
				parentEl = dragEl.parentNode;
				nextEl = dragEl.nextSibling;
				activeGroup = options.group;

				dragStartFn = function () {
					// Delayed drag has been triggered
					// we can re-enable the events: touchmove/mousemove
					_this._disableDelayedDrag();

					// Make the element draggable
					dragEl.draggable = true;

					// Chosen item
					_toggleClass(dragEl, _this.options.chosenClass, true);

					// Bind the events: dragstart/dragend
					_this._triggerDragStart(touch);
				};

				// Disable "draggable"
				options.ignore.split(',').forEach(function (criteria) {
					_find(dragEl, criteria.trim(), _disableDraggable);
				});

				_on(ownerDocument, 'mouseup', _this._onDrop);
				_on(ownerDocument, 'touchend', _this._onDrop);
				_on(ownerDocument, 'touchcancel', _this._onDrop);

				if (options.delay) {
					// If the user moves the pointer or let go the click or touch
					// before the delay has been reached:
					// disable the delayed drag
					_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
					_on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchmove', _this._disableDelayedDrag);

					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
				} else {
					dragStartFn();
				}
			}
		},

		_disableDelayedDrag: function () {
			var ownerDocument = this.el.ownerDocument;

			clearTimeout(this._dragStartTimer);
			_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
			_off(ownerDocument, 'touchend', this._disableDelayedDrag);
			_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
			_off(ownerDocument, 'mousemove', this._disableDelayedDrag);
			_off(ownerDocument, 'touchmove', this._disableDelayedDrag);
		},

		_triggerDragStart: function (/** Touch */touch) {
			if (touch) {
				// Touch device support
				tapEvt = {
					target: dragEl,
					clientX: touch.clientX,
					clientY: touch.clientY
				};

				this._onDragStart(tapEvt, 'touch');
			}
			else if (!this.nativeDraggable) {
				this._onDragStart(tapEvt, true);
			}
			else {
				_on(dragEl, 'dragend', this);
				_on(rootEl, 'dragstart', this._onDragStart);
			}

			try {
				if (document.selection) {
					document.selection.empty();
				} else {
					window.getSelection().removeAllRanges();
				}
			} catch (err) {
			}
		},

		_dragStarted: function () {
			if (rootEl && dragEl) {
				// Apply effect
				_toggleClass(dragEl, this.options.ghostClass, true);

				Sortable.active = this;

				// Drag start event
				_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
			}
		},

		_emulateDragOver: function () {
			if (touchEvt) {
				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
					return;
				}

				this._lastX = touchEvt.clientX;
				this._lastY = touchEvt.clientY;

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', 'none');
				}

				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
					parent = target,
					groupName = ' ' + this.options.group.name + '',
					i = touchDragOverListeners.length;

				if (parent) {
					do {
						if (parent[expando] && parent[expando].options.groups.indexOf(groupName) > -1) {
							while (i--) {
								touchDragOverListeners[i]({
									clientX: touchEvt.clientX,
									clientY: touchEvt.clientY,
									target: target,
									rootEl: parent
								});
							}

							break;
						}

						target = parent; // store last element
					}
					/* jshint boss:true */
					while (parent = parent.parentNode);
				}

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', '');
				}
			}
		},


		_onTouchMove: function (/**TouchEvent*/evt) {
			if (tapEvt) {
				// only set the status to dragging, when we are actually dragging
				if (!Sortable.active) {
					this._dragStarted();
				}

				// as well as creating the ghost element on the document body
				this._appendGhost();

				var touch = evt.touches ? evt.touches[0] : evt,
					dx = touch.clientX - tapEvt.clientX,
					dy = touch.clientY - tapEvt.clientY,
					translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

				moved = true;
				touchEvt = touch;

				_css(ghostEl, 'webkitTransform', translate3d);
				_css(ghostEl, 'mozTransform', translate3d);
				_css(ghostEl, 'msTransform', translate3d);
				_css(ghostEl, 'transform', translate3d);

				evt.preventDefault();
			}
		},

		_appendGhost: function () {
			if (!ghostEl) {
				var rect = dragEl.getBoundingClientRect(),
					css = _css(dragEl),
					options = this.options,
					ghostRect;

				ghostEl = dragEl.cloneNode(true);

				_toggleClass(ghostEl, options.ghostClass, false);
				_toggleClass(ghostEl, options.fallbackClass, true);

				_css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
				_css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
				_css(ghostEl, 'width', rect.width);
				_css(ghostEl, 'height', rect.height);
				_css(ghostEl, 'opacity', '0.8');
				_css(ghostEl, 'position', 'fixed');
				_css(ghostEl, 'zIndex', '100000');
				_css(ghostEl, 'pointerEvents', 'none');

				options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);

				// Fixing dimensions.
				ghostRect = ghostEl.getBoundingClientRect();
				_css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
				_css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
			}
		},

		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {
			var dataTransfer = evt.dataTransfer,
				options = this.options;

			this._offUpEvents();

			if (activeGroup.pull == 'clone') {
				cloneEl = dragEl.cloneNode(true);
				_css(cloneEl, 'display', 'none');
				rootEl.insertBefore(cloneEl, dragEl);
			}

			if (useFallback) {

				if (useFallback === 'touch') {
					// Bind touch events
					_on(document, 'touchmove', this._onTouchMove);
					_on(document, 'touchend', this._onDrop);
					_on(document, 'touchcancel', this._onDrop);
				} else {
					// Old brwoser
					_on(document, 'mousemove', this._onTouchMove);
					_on(document, 'mouseup', this._onDrop);
				}

				this._loopId = setInterval(this._emulateDragOver, 50);
			}
			else {
				if (dataTransfer) {
					dataTransfer.effectAllowed = 'move';
					options.setData && options.setData.call(this, dataTransfer, dragEl);
				}

				_on(document, 'drop', this);
				setTimeout(this._dragStarted, 0);
			}
		},

		_onDragOver: function (/**Event*/evt) {
			var el = this.el,
				target,
				dragRect,
				revert,
				options = this.options,
				group = options.group,
				groupPut = group.put,
				isOwner = (activeGroup === group),
				canSort = options.sort;

			if (evt.preventDefault !== void 0) {
				evt.preventDefault();
				!options.dragoverBubble && evt.stopPropagation();
			}

			moved = true;

			if (activeGroup && !options.disabled &&
				(isOwner
					? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
					: activeGroup.pull && groupPut && (
						(activeGroup.name === group.name) || // by Name
						(groupPut.indexOf && ~groupPut.indexOf(activeGroup.name)) // by Array
					)
				) &&
				(evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback
			) {
				// Smart auto-scrolling
				_autoScroll(evt, options, this.el);

				if (_silent) {
					return;
				}

				target = _closest(evt.target, options.draggable, el);
				dragRect = dragEl.getBoundingClientRect();

				if (revert) {
					_cloneHide(true);

					if (cloneEl || nextEl) {
						rootEl.insertBefore(dragEl, cloneEl || nextEl);
					}
					else if (!canSort) {
						rootEl.appendChild(dragEl);
					}

					return;
				}


				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
					(el === evt.target) && (target = _ghostIsLast(el, evt))
				) {

					if (target) {
						if (target.animated) {
							return;
						}

						targetRect = target.getBoundingClientRect();
					}

					_cloneHide(isOwner);

					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect) !== false) {
						if (!dragEl.contains(el)) {
							el.appendChild(dragEl);
							parentEl = el; // actualization
						}

						this._animate(dragRect, dragEl);
						target && this._animate(targetRect, target);
					}
				}
				else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {
					if (lastEl !== target) {
						lastEl = target;
						lastCSS = _css(target);
						lastParentCSS = _css(target.parentNode);
					}


					var targetRect = target.getBoundingClientRect(),
						width = targetRect.right - targetRect.left,
						height = targetRect.bottom - targetRect.top,
						floating = /left|right|inline/.test(lastCSS.cssFloat + lastCSS.display)
							|| (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),
						isWide = (target.offsetWidth > dragEl.offsetWidth),
						isLong = (target.offsetHeight > dragEl.offsetHeight),
						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
						nextSibling = target.nextElementSibling,
						moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect),
						after
					;

					if (moveVector !== false) {
						_silent = true;
						setTimeout(_unsilent, 30);

						_cloneHide(isOwner);

						if (moveVector === 1 || moveVector === -1) {
							after = (moveVector === 1);
						}
						else if (floating) {
							var elTop = dragEl.offsetTop,
								tgTop = target.offsetTop;

							if (elTop === tgTop) {
								after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
							} else {
								after = tgTop > elTop;
							}
						} else {
							after = (nextSibling !== dragEl) && !isLong || halfway && isLong;
						}

						if (!dragEl.contains(el)) {
							if (after && !nextSibling) {
								el.appendChild(dragEl);
							} else {
								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
							}
						}

						parentEl = dragEl.parentNode; // actualization

						this._animate(dragRect, dragEl);
						this._animate(targetRect, target);
					}
				}
			}
		},

		_animate: function (prevRect, target) {
			var ms = this.options.animation;

			if (ms) {
				var currentRect = target.getBoundingClientRect();

				_css(target, 'transition', 'none');
				_css(target, 'transform', 'translate3d('
					+ (prevRect.left - currentRect.left) + 'px,'
					+ (prevRect.top - currentRect.top) + 'px,0)'
				);

				target.offsetWidth; // repaint

				_css(target, 'transition', 'all ' + ms + 'ms');
				_css(target, 'transform', 'translate3d(0,0,0)');

				clearTimeout(target.animated);
				target.animated = setTimeout(function () {
					_css(target, 'transition', '');
					_css(target, 'transform', '');
					target.animated = false;
				}, ms);
			}
		},

		_offUpEvents: function () {
			var ownerDocument = this.el.ownerDocument;

			_off(document, 'touchmove', this._onTouchMove);
			_off(ownerDocument, 'mouseup', this._onDrop);
			_off(ownerDocument, 'touchend', this._onDrop);
			_off(ownerDocument, 'touchcancel', this._onDrop);
		},

		_onDrop: function (/**Event*/evt) {
			var el = this.el,
				options = this.options;

			clearInterval(this._loopId);
			clearInterval(autoScroll.pid);
			clearTimeout(this._dragStartTimer);

			// Unbind events
			_off(document, 'mousemove', this._onTouchMove);

			if (this.nativeDraggable) {
				_off(document, 'drop', this);
				_off(el, 'dragstart', this._onDragStart);
			}

			this._offUpEvents();

			if (evt) {
				if (moved) {
					evt.preventDefault();
					!options.dropBubble && evt.stopPropagation();
				}

				ghostEl && ghostEl.parentNode.removeChild(ghostEl);

				if (dragEl) {
					if (this.nativeDraggable) {
						_off(dragEl, 'dragend', this);
					}

					_disableDraggable(dragEl);

					// Remove class's
					_toggleClass(dragEl, this.options.ghostClass, false);
					_toggleClass(dragEl, this.options.chosenClass, false);

					if (rootEl !== parentEl) {
						newIndex = _index(dragEl);

						if (newIndex >= 0) {
							// drag from one list and drop into another
							_dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);

							// Add event
							_dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);

							// Remove event
							_dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);
						}
					}
					else {
						// Remove clone
						cloneEl && cloneEl.parentNode.removeChild(cloneEl);

						if (dragEl.nextSibling !== nextEl) {
							// Get the index of the dragged element within its parent
							newIndex = _index(dragEl);

							if (newIndex >= 0) {
								// drag & drop within the same list
								_dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
								_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							}
						}
					}

					if (Sortable.active) {
						if (newIndex === null || newIndex === -1) {
							newIndex = oldIndex;
						}

						_dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);

						// Save sorting
						this.save();
					}
				}

				// Nulling
				rootEl =
				dragEl =
				parentEl =
				ghostEl =
				nextEl =
				cloneEl =

				scrollEl =
				scrollParentEl =

				tapEvt =
				touchEvt =

				moved =
				newIndex =

				lastEl =
				lastCSS =

				activeGroup =
				Sortable.active = null;
			}
		},


		handleEvent: function (/**Event*/evt) {
			var type = evt.type;

			if (type === 'dragover' || type === 'dragenter') {
				if (dragEl) {
					this._onDragOver(evt);
					_globalDragOver(evt);
				}
			}
			else if (type === 'drop' || type === 'dragend') {
				this._onDrop(evt);
			}
		},


		/**
		 * Serializes the item into an array of string.
		 * @returns {String[]}
		 */
		toArray: function () {
			var order = [],
				el,
				children = this.el.children,
				i = 0,
				n = children.length,
				options = this.options;

			for (; i < n; i++) {
				el = children[i];
				if (_closest(el, options.draggable, this.el)) {
					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
				}
			}

			return order;
		},


		/**
		 * Sorts the elements according to the array.
		 * @param  {String[]}  order  order of the items
		 */
		sort: function (order) {
			var items = {}, rootEl = this.el;

			this.toArray().forEach(function (id, i) {
				var el = rootEl.children[i];

				if (_closest(el, this.options.draggable, rootEl)) {
					items[id] = el;
				}
			}, this);

			order.forEach(function (id) {
				if (items[id]) {
					rootEl.removeChild(items[id]);
					rootEl.appendChild(items[id]);
				}
			});
		},


		/**
		 * Save the current sorting
		 */
		save: function () {
			var store = this.options.store;
			store && store.set(this);
		},


		/**
		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
		 * @param   {HTMLElement}  el
		 * @param   {String}       [selector]  default: `options.draggable`
		 * @returns {HTMLElement|null}
		 */
		closest: function (el, selector) {
			return _closest(el, selector || this.options.draggable, this.el);
		},


		/**
		 * Set/get option
		 * @param   {string} name
		 * @param   {*}      [value]
		 * @returns {*}
		 */
		option: function (name, value) {
			var options = this.options;

			if (value === void 0) {
				return options[name];
			} else {
				options[name] = value;

				if (name === 'group') {
					_prepareGroup(options);
				}
			}
		},


		/**
		 * Destroy
		 */
		destroy: function () {
			var el = this.el;

			el[expando] = null;

			_off(el, 'mousedown', this._onTapStart);
			_off(el, 'touchstart', this._onTapStart);

			if (this.nativeDraggable) {
				_off(el, 'dragover', this);
				_off(el, 'dragenter', this);
			}

			// Remove draggable attributes
			Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
				el.removeAttribute('draggable');
			});

			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

			this._onDrop();

			this.el = el = null;
		}
	};


	function _cloneHide(state) {
		if (cloneEl && (cloneEl.state !== state)) {
			_css(cloneEl, 'display', state ? 'none' : '');
			!state && cloneEl.state && rootEl.insertBefore(cloneEl, dragEl);
			cloneEl.state = state;
		}
	}


	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
		if (el) {
			ctx = ctx || document;
			selector = selector.split('.');

			var tag = selector.shift().toUpperCase(),
				re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');

			do {
				if (
					(tag === '>*' && el.parentNode === ctx) || (
						(tag === '' || el.nodeName.toUpperCase() == tag) &&
						(!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)
					)
				) {
					return el;
				}
			}
			while (el !== ctx && (el = el.parentNode));
		}

		return null;
	}


	function _globalDragOver(/**Event*/evt) {
		if (evt.dataTransfer) {
			evt.dataTransfer.dropEffect = 'move';
		}
		evt.preventDefault();
	}


	function _on(el, event, fn) {
		el.addEventListener(event, fn, false);
	}


	function _off(el, event, fn) {
		el.removeEventListener(event, fn, false);
	}


	function _toggleClass(el, name, state) {
		if (el) {
			if (el.classList) {
				el.classList[state ? 'add' : 'remove'](name);
			}
			else {
				var className = (' ' + el.className + ' ').replace(RSPACE, ' ').replace(' ' + name + ' ', ' ');
				el.className = (className + (state ? ' ' + name : '')).replace(RSPACE, ' ');
			}
		}
	}


	function _css(el, prop, val) {
		var style = el && el.style;

		if (style) {
			if (val === void 0) {
				if (document.defaultView && document.defaultView.getComputedStyle) {
					val = document.defaultView.getComputedStyle(el, '');
				}
				else if (el.currentStyle) {
					val = el.currentStyle;
				}

				return prop === void 0 ? val : val[prop];
			}
			else {
				if (!(prop in style)) {
					prop = '-webkit-' + prop;
				}

				style[prop] = val + (typeof val === 'string' ? '' : 'px');
			}
		}
	}


	function _find(ctx, tagName, iterator) {
		if (ctx) {
			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

			if (iterator) {
				for (; i < n; i++) {
					iterator(list[i], i);
				}
			}

			return list;
		}

		return [];
	}



	function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
		var evt = document.createEvent('Event'),
			options = (sortable || rootEl[expando]).options,
			onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);

		evt.initEvent(name, true, true);

		evt.to = rootEl;
		evt.from = fromEl || rootEl;
		evt.item = targetEl || rootEl;
		evt.clone = cloneEl;

		evt.oldIndex = startIndex;
		evt.newIndex = newIndex;

		rootEl.dispatchEvent(evt);

		if (options[onName]) {
			options[onName].call(sortable, evt);
		}
	}


	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect) {
		var evt,
			sortable = fromEl[expando],
			onMoveFn = sortable.options.onMove,
			retVal;

		evt = document.createEvent('Event');
		evt.initEvent('move', true, true);

		evt.to = toEl;
		evt.from = fromEl;
		evt.dragged = dragEl;
		evt.draggedRect = dragRect;
		evt.related = targetEl || toEl;
		evt.relatedRect = targetRect || toEl.getBoundingClientRect();

		fromEl.dispatchEvent(evt);

		if (onMoveFn) {
			retVal = onMoveFn.call(sortable, evt);
		}

		return retVal;
	}


	function _disableDraggable(el) {
		el.draggable = false;
	}


	function _unsilent() {
		_silent = false;
	}


	/** @returns {HTMLElement|false} */
	function _ghostIsLast(el, evt) {
		var lastEl = el.lastElementChild,
				rect = lastEl.getBoundingClientRect();

		return ((evt.clientY - (rect.top + rect.height) > 5) || (evt.clientX - (rect.right + rect.width) > 5)) && lastEl; // min delta
	}


	/**
	 * Generate id
	 * @param   {HTMLElement} el
	 * @returns {String}
	 * @private
	 */
	function _generateId(el) {
		var str = el.tagName + el.className + el.src + el.href + el.textContent,
			i = str.length,
			sum = 0;

		while (i--) {
			sum += str.charCodeAt(i);
		}

		return sum.toString(36);
	}

	/**
	 * Returns the index of an element within its parent
	 * @param  {HTMLElement} el
	 * @return {number}
	 */
	function _index(el) {
		var index = 0;

		if (!el || !el.parentNode) {
			return -1;
		}

		while (el && (el = el.previousElementSibling)) {
			if (el.nodeName.toUpperCase() !== 'TEMPLATE') {
				index++;
			}
		}

		return index;
	}

	function _throttle(callback, ms) {
		var args, _this;

		return function () {
			if (args === void 0) {
				args = arguments;
				_this = this;

				setTimeout(function () {
					if (args.length === 1) {
						callback.call(_this, args[0]);
					} else {
						callback.apply(_this, args);
					}

					args = void 0;
				}, ms);
			}
		};
	}

	function _extend(dst, src) {
		if (dst && src) {
			for (var key in src) {
				if (src.hasOwnProperty(key)) {
					dst[key] = src[key];
				}
			}
		}

		return dst;
	}


	// Export utils
	Sortable.utils = {
		on: _on,
		off: _off,
		css: _css,
		find: _find,
		is: function (el, selector) {
			return !!_closest(el, selector, el);
		},
		extend: _extend,
		throttle: _throttle,
		closest: _closest,
		toggleClass: _toggleClass,
		index: _index
	};


	/**
	 * Create sortable instance
	 * @param {HTMLElement}  el
	 * @param {Object}      [options]
	 */
	Sortable.create = function (el, options) {
		return new Sortable(el, options);
	};


	// Export
	Sortable.version = '1.4.2';
	return Sortable;
});


/***/ },
/* 149 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 150 */
/***/ function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

function withFlex(value, handler) {
    return element => {
        element.style.flex = value;
        handler(element);
    };
}
exports.withFlex = withFlex;
function withStyle(style, handler) {
    return element => {
        Object.assign(element.style, style);
        handler(element);
    };
}
exports.withStyle = withStyle;
function withAttributes(attributes, handler) {
    return element => {
        Object.assign(element, attributes);
        handler(element);
    };
}
exports.withAttributes = withAttributes;
;
function box(flexDirection, spec) {
    return container => {
        container.style.display = 'flex';
        container.style.flexDirection = flexDirection;
        for (var handler of spec) {
            var element = container.ownerDocument.createElement('div');
            container.appendChild(element);
            handler(element);
        }
    };
}
exports.box = box;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
var json_1 = __webpack_require__(8);
var signals_1 = __webpack_require__(34);

var VoxelSize = function (_disposable_1$RefCoun) {
    _inherits(VoxelSize, _disposable_1$RefCoun);

    function VoxelSize(voxelSize) {
        _classCallCheck(this, VoxelSize);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(VoxelSize).call(this));

        _this.changed = new signals_1.Signal();
        var valid = true;
        if (voxelSize == null) {
            voxelSize = geom_1.vec3.create();
            valid = false;
        }
        _this.size = voxelSize;
        _this.valid = valid;
        return _this;
    }

    _createClass(VoxelSize, [{
        key: 'reset',
        value: function reset() {
            this.valid = false;
            this.changed.dispatch();
        }
        /**
         * This should be called after setting the voxel size initially.  The voxel
         * size should not be changed once it is valid.
         */

    }, {
        key: 'setValid',
        value: function setValid() {
            if (!this.valid) {
                this.valid = true;
                this.changed.dispatch();
            }
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            if (!this.valid) {
                return undefined;
            }
            return Array.prototype.slice.call(this.size);
        }
    }, {
        key: 'restoreState',
        value: function restoreState(obj) {
            try {
                json_1.parseFiniteVec(this.size, obj);
                this.valid = true;
                this.changed.dispatch();
            } catch (e) {
                this.valid = false;
                this.changed.dispatch();
            }
        }
    }, {
        key: 'toString',
        value: function toString() {
            if (!this.valid) {
                return null;
            }
            return this.size.toString();
        }
    }, {
        key: 'voxelFromSpatial',
        value: function voxelFromSpatial(voxel, spatial) {
            geom_1.vec3.divide(voxel, spatial, this.size);
        }
    }, {
        key: 'spatialFromVoxel',
        value: function spatialFromVoxel(spatial, voxel) {
            geom_1.vec3.multiply(spatial, voxel, this.size);
        }
    }]);

    return VoxelSize;
}(disposable_1.RefCounted);

exports.VoxelSize = VoxelSize;
;
var tempVec3 = geom_1.vec3.create();
var tempQuat = geom_1.quat.create();

var SpatialPosition = function (_disposable_1$RefCoun2) {
    _inherits(SpatialPosition, _disposable_1$RefCoun2);

    function SpatialPosition(voxelSize, spatialCoordinates) {
        _classCallCheck(this, SpatialPosition);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SpatialPosition).call(this));

        _this2.voxelCoordinates = null;
        _this2.changed = new signals_1.Signal();
        if (voxelSize == null) {
            voxelSize = new VoxelSize();
        }
        _this2.voxelSize = voxelSize;
        var spatialCoordinatesValid = true;
        if (spatialCoordinates == null) {
            spatialCoordinates = geom_1.vec3.create();
            spatialCoordinatesValid = false;
        }
        _this2.spatialCoordinates = spatialCoordinates;
        _this2.spatialCoordinatesValid = spatialCoordinatesValid;
        _this2.registerDisposer(voxelSize);
        _this2.registerSignalBinding(voxelSize.changed.add(_this2.handleVoxelSizeChanged, _this2));
        return _this2;
    }

    _createClass(SpatialPosition, [{
        key: 'reset',
        value: function reset() {
            this.spatialCoordinatesValid = false;
            this.voxelCoordinates = null;
            this.voxelSize.reset();
            this.changed.dispatch();
        }
    }, {
        key: 'getVoxelCoordinates',
        value: function getVoxelCoordinates(out) {
            var voxelCoordinates = this.voxelCoordinates;

            if (voxelCoordinates) {
                geom_1.vec3.copy(out, voxelCoordinates);
            } else if (this.valid) {
                this.voxelSize.voxelFromSpatial(out, this.spatialCoordinates);
            } else {
                return false;
            }
            return true;
        }
        /**
         * Sets this position to the spatial coordinats corresponding to the specified
         * voxelPosition.  If this.voxelSize.valid == false, then this position won't
         * be set until it is.
         */

    }, {
        key: 'setVoxelCoordinates',
        value: function setVoxelCoordinates(voxelCoordinates) {
            var voxelSize = this.voxelSize;
            if (voxelSize.valid) {
                voxelSize.spatialFromVoxel(this.spatialCoordinates, voxelCoordinates);
                this.markSpatialCoordinatesChanged();
            } else {
                var voxelCoordinates_ = this.voxelCoordinates;
                if (!voxelCoordinates_) {
                    this.voxelCoordinates = voxelCoordinates_ = geom_1.vec3.clone(voxelCoordinates);
                } else {
                    geom_1.vec3.copy(voxelCoordinates_, voxelCoordinates);
                }
            }
            this.changed.dispatch();
        }
    }, {
        key: 'markSpatialCoordinatesChanged',
        value: function markSpatialCoordinatesChanged() {
            this.spatialCoordinatesValid = true;
            this.voxelCoordinates = null;
            this.changed.dispatch();
        }
    }, {
        key: 'handleVoxelSizeChanged',
        value: function handleVoxelSizeChanged() {
            if (this.voxelCoordinates != null && !this.spatialCoordinatesValid) {
                this.voxelSize.spatialFromVoxel(this.spatialCoordinates, this.voxelCoordinates);
                this.spatialCoordinatesValid = true;
            }
            this.voxelCoordinates = null;
            this.changed.dispatch();
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            var empty = true;
            var voxelSizeJson = this.voxelSize.toJSON();
            var obj = {};
            if (voxelSizeJson !== undefined) {
                empty = false;
                obj['voxelSize'] = voxelSizeJson;
            }
            if (this.voxelCoordinatesValid) {
                var voxelCoordinates = tempVec3;
                this.getVoxelCoordinates(voxelCoordinates);
                obj['voxelCoordinates'] = Array.prototype.slice.call(voxelCoordinates);
                empty = false;
            } else if (this.spatialCoordinatesValid) {
                obj['spatialCoordinates'] = Array.prototype.slice.call(this.spatialCoordinates);
                empty = false;
            }
            if (empty) {
                return undefined;
            }
            return obj;
        }
    }, {
        key: 'restoreState',
        value: function restoreState(obj) {
            json_1.verifyObject(obj);
            json_1.verifyObjectProperty(obj, 'voxelSize', x => {
                if (x !== undefined) {
                    this.voxelSize.restoreState(x);
                }
            });
            this.spatialCoordinatesValid = false;
            json_1.verifyObjectProperty(obj, 'voxelCoordinates', x => {
                if (x !== undefined) {
                    this.setVoxelCoordinates(json_1.parseFiniteVec(geom_1.vec3.create(), x));
                }
            });
            json_1.verifyObjectProperty(obj, 'spatialCoordinates', x => {
                if (x !== undefined) {
                    json_1.parseFiniteVec(this.spatialCoordinates, x);
                    this.markSpatialCoordinatesChanged();
                }
            });
        }
    }, {
        key: 'snapToVoxel',
        value: function snapToVoxel() {
            if (!this.valid) {
                var voxelCoordinates = this.voxelCoordinates;

                if (voxelCoordinates != null) {
                    for (var i = 0; i < 3; ++i) {
                        voxelCoordinates[i] = Math.round(voxelCoordinates[i]);
                    }
                    this.changed.dispatch();
                }
            } else {
                var spatialCoordinates = this.spatialCoordinates;
                var voxelSize = this.voxelSize.size;
                for (var _i = 0; _i < 3; ++_i) {
                    var voxelSizeValue = voxelSize[_i];
                    spatialCoordinates[_i] = Math.round(spatialCoordinates[_i] / voxelSizeValue) * voxelSizeValue;
                }
                this.changed.dispatch();
            }
        }
    }, {
        key: 'valid',
        get: function () {
            return this.spatialCoordinatesValid && this.voxelSize.valid;
        }
    }, {
        key: 'voxelCoordinatesValid',
        get: function () {
            return this.valid || this.voxelCoordinates != null;
        }
    }]);

    return SpatialPosition;
}(disposable_1.RefCounted);

exports.SpatialPosition = SpatialPosition;
;
function quaternionIsIdentity(quat) {
    return quat[0] === 0 && quat[1] === 0 && quat[2] === 0 && quat[3] === 1;
}

var OrientationState = function (_disposable_1$RefCoun3) {
    _inherits(OrientationState, _disposable_1$RefCoun3);

    function OrientationState(orientation) {
        _classCallCheck(this, OrientationState);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(OrientationState).call(this));

        _this3.changed = new signals_1.Signal();
        if (orientation == null) {
            orientation = geom_1.quat.create();
        }
        _this3.orientation = orientation;
        return _this3;
    }

    _createClass(OrientationState, [{
        key: 'toJSON',
        value: function toJSON() {
            var orientation = this.orientation;

            if (quaternionIsIdentity(orientation)) {
                return undefined;
            }
            return Array.prototype.slice.call(this.orientation);
        }
    }, {
        key: 'restoreState',
        value: function restoreState(obj) {
            try {
                json_1.parseFiniteVec(this.orientation, obj);
                geom_1.quat.normalize(this.orientation, this.orientation);
            } catch (ignoredError) {
                geom_1.quat.identity(this.orientation);
            }
            this.changed.dispatch();
        }
    }, {
        key: 'reset',
        value: function reset() {
            geom_1.quat.identity(this.orientation);
            this.changed.dispatch();
        }
    }, {
        key: 'snap',
        value: function snap() {
            var mat = geom_1.mat3.create();
            geom_1.mat3.fromQuat(mat, this.orientation);
            // console.log(mat);
            var usedAxes = [false, false, false];
            for (var i = 0; i < 3; ++i) {
                var maxComponent = 0;
                var argmaxComponent = 0;
                for (var j = 0; j < 3; ++j) {
                    var value = mat[i * 3 + j];
                    mat[i * 3 + j] = 0;
                    if (usedAxes[j]) {
                        continue;
                    }
                    if (Math.abs(value) > Math.abs(maxComponent)) {
                        maxComponent = value;
                        argmaxComponent = j;
                    }
                }
                mat[i * 3 + argmaxComponent] = Math.sign(maxComponent);
                usedAxes[argmaxComponent] = true;
            }
            // console.log(mat);
            geom_1.quat.fromMat3(this.orientation, mat);
            this.changed.dispatch();
        }
        /**
         * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any
         * changes to the returned OrientationState will cause a corresponding change in peer, and vice
         * versa.
         */

    }], [{
        key: 'makeRelative',
        value: function makeRelative(peer, peerToSelf) {
            var self = new OrientationState(geom_1.quat.multiply(geom_1.quat.create(), peer.orientation, peerToSelf));
            var updatingPeer = false;
            self.registerSignalBinding(peer.changed.add(() => {
                if (!updatingPeer) {
                    updatingSelf = true;
                    geom_1.quat.multiply(self.orientation, peer.orientation, peerToSelf);
                    self.changed.dispatch();
                    updatingSelf = false;
                }
            }));
            var updatingSelf = false;
            var selfToPeer = geom_1.quat.invert(geom_1.quat.create(), peerToSelf);
            self.registerSignalBinding(self.changed.add(() => {
                if (!updatingSelf) {
                    updatingPeer = true;
                    geom_1.quat.multiply(peer.orientation, self.orientation, selfToPeer);
                    peer.changed.dispatch();
                    updatingPeer = false;
                }
            }));
            return self;
        }
    }]);

    return OrientationState;
}(disposable_1.RefCounted);

exports.OrientationState = OrientationState;
;

var Pose = function (_disposable_1$RefCoun4) {
    _inherits(Pose, _disposable_1$RefCoun4);

    function Pose(position, orientation) {
        _classCallCheck(this, Pose);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Pose).call(this));

        _this4.changed = new signals_1.Signal();
        if (position == null) {
            position = new SpatialPosition();
        }
        _this4.position = position;
        if (orientation == null) {
            orientation = new OrientationState();
        }
        _this4.orientation = orientation;
        _this4.registerDisposer(_this4.position);
        _this4.registerDisposer(_this4.orientation);
        _this4.registerSignalBinding(_this4.position.changed.add(_this4.changed.dispatch, _this4.changed));
        _this4.registerSignalBinding(_this4.orientation.changed.add(_this4.changed.dispatch, _this4.changed));
        return _this4;
    }

    _createClass(Pose, [{
        key: 'reset',

        /**
         * Resets everything.
         */
        value: function reset() {
            this.position.reset();
            this.orientation.reset();
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            this.position.changed.remove(this.changed.dispatch, this.changed);
            _get(Object.getPrototypeOf(Pose.prototype), 'disposed', this).call(this);
        }
    }, {
        key: 'toMat4',
        value: function toMat4(mat) {
            geom_1.mat4.fromRotationTranslation(mat, this.orientation.orientation, this.position.spatialCoordinates);
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            var positionJson = this.position.toJSON();
            var orientationJson = this.orientation.toJSON();
            if (positionJson === undefined && orientationJson === undefined) {
                return undefined;
            }
            return { 'position': positionJson, 'orientation': orientationJson };
        }
    }, {
        key: 'restoreState',
        value: function restoreState(obj) {
            json_1.verifyObject(obj);
            json_1.verifyObjectProperty(obj, 'position', x => {
                if (x !== undefined) {
                    this.position.restoreState(x);
                }
            });
            json_1.verifyObjectProperty(obj, 'orientation', x => {
                if (x !== undefined) {
                    this.orientation.restoreState(x);
                }
            });
        }
        /**
         * Snaps the orientation to the nearest axis-aligned orientation, and
         * snaps the position to the nearest voxel.
         */

    }, {
        key: 'snap',
        value: function snap() {
            this.orientation.snap();
            this.position.snapToVoxel();
            this.changed.dispatch();
        }
    }, {
        key: 'translateAbsolute',
        value: function translateAbsolute(translation) {
            geom_1.vec3.add(this.position.spatialCoordinates, this.position.spatialCoordinates, translation);
            this.position.changed.dispatch();
        }
    }, {
        key: 'translateRelative',
        value: function translateRelative(translation) {
            if (!this.valid) {
                return;
            }
            var temp = geom_1.vec3.create();
            geom_1.vec3.transformQuat(temp, translation, this.orientation.orientation);
            geom_1.vec3.add(this.position.spatialCoordinates, this.position.spatialCoordinates, temp);
            this.position.changed.dispatch();
        }
    }, {
        key: 'translateVoxelsRelative',
        value: function translateVoxelsRelative(translation) {
            if (!this.valid) {
                return;
            }
            var temp = geom_1.vec3.create();
            geom_1.vec3.transformQuat(temp, translation, this.orientation.orientation);
            geom_1.vec3.multiply(temp, temp, this.position.voxelSize.size);
            geom_1.vec3.add(this.position.spatialCoordinates, this.position.spatialCoordinates, temp);
            this.position.changed.dispatch();
        }
    }, {
        key: 'rotateRelative',
        value: function rotateRelative(axis, angle) {
            var temp = geom_1.quat.create();
            geom_1.quat.setAxisAngle(temp, axis, angle);
            var orientation = this.orientation.orientation;
            geom_1.quat.multiply(orientation, orientation, temp);
            this.orientation.changed.dispatch();
        }
    }, {
        key: 'rotateAbsolute',
        value: function rotateAbsolute(axis, angle, fixedPoint) {
            var temp = geom_1.quat.create();
            geom_1.quat.setAxisAngle(temp, axis, angle);
            var orientation = this.orientation.orientation;
            if (fixedPoint !== undefined) {
                // We want the coordinates in the transformed coordinate frame of the fixed point to remain
                // the same after the rotation.
                // We have the invariants:
                // oldOrienation * fixedPointLocal + oldPosition == fixedPoint.
                // newOrientation * fixedPointLocal + newPosition == fixedPoint.
                // Therefore, we compute fixedPointLocal by:
                // fixedPointLocal == inverse(oldOrientation) * (fixedPoint - oldPosition).
                var spatialCoordinates = this.position.spatialCoordinates;

                var fixedPointLocal = geom_1.vec3.subtract(tempVec3, fixedPoint, spatialCoordinates);
                var invOrientation = geom_1.quat.invert(tempQuat, orientation);
                geom_1.vec3.transformQuat(fixedPointLocal, fixedPointLocal, invOrientation);
                // We then compute the newPosition by:
                // newPosition := fixedPoint - newOrientation * fixedPointLocal.
                geom_1.quat.multiply(orientation, temp, orientation);
                geom_1.vec3.transformQuat(spatialCoordinates, fixedPointLocal, orientation);
                geom_1.vec3.subtract(spatialCoordinates, fixedPoint, spatialCoordinates);
                this.position.changed.dispatch();
            } else {
                geom_1.quat.multiply(orientation, temp, orientation);
            }
            this.orientation.changed.dispatch();
        }
    }, {
        key: 'valid',
        get: function () {
            return this.position.valid;
        }
    }]);

    return Pose;
}(disposable_1.RefCounted);

exports.Pose = Pose;
;

var TrackableZoomState = function () {
    function TrackableZoomState() {
        var value_ = arguments.length <= 0 || arguments[0] === undefined ? Number.NaN : arguments[0];
        var defaultValue = arguments.length <= 1 || arguments[1] === undefined ? value_ : arguments[1];

        _classCallCheck(this, TrackableZoomState);

        this.value_ = value_;
        this.defaultValue = defaultValue;
        this.changed = new signals_1.Signal();
    }

    _createClass(TrackableZoomState, [{
        key: 'toJSON',
        value: function toJSON() {
            var value_ = this.value_;
            var defaultValue = this.defaultValue;

            if (Number.isNaN(value_) && Number.isNaN(defaultValue) || value_ === defaultValue) {
                return undefined;
            }
            return value_;
        }
    }, {
        key: 'restoreState',
        value: function restoreState(obj) {
            if (typeof obj === 'number' && Number.isFinite(obj) && obj > 0) {
                this.value = obj;
            } else {
                this.value = this.defaultValue;
            }
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.value = this.defaultValue;
        }
    }, {
        key: 'zoomBy',
        value: function zoomBy(factor) {
            var value_ = this.value_;

            if (Number.isNaN(value_)) {
                return;
            }
            this.value = value_ * factor;
        }
    }, {
        key: 'value',
        get: function () {
            return this.value_;
        },
        set: function (newValue) {
            if (newValue !== this.value_) {
                this.value_ = newValue;
                this.changed.dispatch();
            }
        }
    }]);

    return TrackableZoomState;
}();

exports.TrackableZoomState = TrackableZoomState;
;

var NavigationState = function (_disposable_1$RefCoun5) {
    _inherits(NavigationState, _disposable_1$RefCoun5);

    function NavigationState() {
        var pose = arguments.length <= 0 || arguments[0] === undefined ? new Pose() : arguments[0];
        var zoomFactor = arguments.length <= 1 || arguments[1] === undefined ? Number.NaN : arguments[1];

        _classCallCheck(this, NavigationState);

        var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(NavigationState).call(this));

        _this5.pose = pose;
        _this5.changed = new signals_1.Signal();
        if (typeof zoomFactor === 'number') {
            _this5.zoomFactor = new TrackableZoomState(zoomFactor);
        } else {
            _this5.zoomFactor = zoomFactor;
        }
        _this5.registerDisposer(pose);
        _this5.registerSignalBinding(_this5.pose.changed.add(() => {
            _this5.changed.dispatch();
        }));
        _this5.registerSignalBinding(_this5.zoomFactor.changed.add(() => {
            _this5.changed.dispatch();
        }));
        _this5.registerSignalBinding(_this5.voxelSize.changed.add(() => {
            _this5.handleVoxelSizeChanged();
        }));
        _this5.handleVoxelSizeChanged();
        return _this5;
    }

    _createClass(NavigationState, [{
        key: 'reset',

        /**
         * Resets everything.
         */
        value: function reset() {
            this.pose.reset();
            this.zoomFactor.reset();
        }
    }, {
        key: 'setZoomFactorFromVoxelSize',
        value: function setZoomFactorFromVoxelSize() {
            var voxelSize = this.voxelSize;

            if (voxelSize.valid) {
                this.zoomFactor.value = Math.min.apply(null, this.voxelSize.size);
            }
        }
        /**
         * Sets the zoomFactor to the minimum voxelSize if it is not already set.
         */

    }, {
        key: 'handleVoxelSizeChanged',
        value: function handleVoxelSizeChanged() {
            if (Number.isNaN(this.zoomFactor.value)) {
                this.setZoomFactorFromVoxelSize();
            }
        }
    }, {
        key: 'toMat4',
        value: function toMat4(mat) {
            this.pose.toMat4(mat);
            var zoom = this.zoomFactor.value;
            geom_1.mat4.scale(mat, mat, geom_1.vec3.fromValues(zoom, zoom, zoom));
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            var poseJson = this.pose.toJSON();
            var zoomFactorJson = this.zoomFactor.toJSON();
            if (poseJson === undefined && zoomFactorJson === undefined) {
                return undefined;
            }
            return { 'pose': poseJson, 'zoomFactor': zoomFactorJson };
        }
    }, {
        key: 'restoreState',
        value: function restoreState(obj) {
            try {
                json_1.verifyObject(obj);
                json_1.verifyObjectProperty(obj, 'pose', x => {
                    if (x !== undefined) {
                        this.pose.restoreState(x);
                    }
                });
                json_1.verifyObjectProperty(obj, 'zoomFactor', x => {
                    if (x !== undefined) {
                        this.zoomFactor.restoreState(x);
                    }
                });
                this.handleVoxelSizeChanged();
                this.changed.dispatch();
            } catch (parseError) {
                this.reset();
            }
        }
    }, {
        key: 'zoomBy',
        value: function zoomBy(factor) {
            this.zoomFactor.zoomBy(factor);
        }
    }, {
        key: 'voxelSize',
        get: function () {
            return this.pose.position.voxelSize;
        }
    }, {
        key: 'position',
        get: function () {
            return this.pose.position;
        }
    }, {
        key: 'valid',
        get: function () {
            return this.pose.valid;
        }
    }]);

    return NavigationState;
}(disposable_1.RefCounted);

exports.NavigationState = NavigationState;
;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var disposable_1 = __webpack_require__(23);
var geom_1 = __webpack_require__(9);
__webpack_require__(153);
var ROUND_POSITIONS = true;

var PositionStatusPanel = function (_disposable_1$RefCoun) {
    _inherits(PositionStatusPanel, _disposable_1$RefCoun);

    function PositionStatusPanel(element, viewer) {
        _classCallCheck(this, PositionStatusPanel);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PositionStatusPanel).call(this));

        _this.element = element;
        _this.viewer = viewer;
        _this.positionElements = new Array();
        _this.needsUpdate = null;
        _this.tempPosition = geom_1.vec3.create();
        element.setAttribute('class', 'position-status-panel');
        var positionElements = _this.positionElements;

        var _loop = function (i) {
            var label = element.ownerDocument.createElement('label');
            label.className = 'position-status-coord';
            var input = element.ownerDocument.createElement('input');
            input.type = 'number';
            input.className = 'position-status-coord';
            label.textContent = geom_1.AXES_NAMES[i];
            label.appendChild(input);
            element.appendChild(label);
            positionElements.push(input);
            var nextInputIsChange = false;
            _this.registerEventListener(input, 'change', event => {
                _this.handleCoordinateChange();
            });
            _this.registerEventListener(input, 'input', event => {
                if (nextInputIsChange) {
                    _this.handleCoordinateChange();
                    nextInputIsChange = false;
                }
                return true;
            });
            _this.registerEventListener(input, 'wheel', event => {
                nextInputIsChange = true;
                input.focus();
                return true;
            });
            _this.registerEventListener(input, 'keydown', event => {
                nextInputIsChange = false;
                return true;
            });
            _this.registerEventListener(input, 'mousedown', event => {
                nextInputIsChange = true;
                return true;
            });
            _this.registerEventListener(input, 'click', event => {
                return true;
            });
            _this.registerEventListener(input, 'blur', event => {
                nextInputIsChange = false;
                return true;
            });
        };

        for (var i = 0; i < 3; ++i) {
            _loop(i);
        }
        var mouseElement = _this.mouseElement = document.createElement('span');
        mouseElement.className = 'position-status-mouse';
        element.appendChild(mouseElement);
        var navigationState = viewer.navigationState;
        var mouseState = viewer.mouseState;

        _this.registerSignalBinding(navigationState.pose.changed.add(_this.handleChange, _this));
        _this.registerSignalBinding(mouseState.changed.add(_this.handleChange, _this));
        _this.handleChange();
        return _this;
    }

    _createClass(PositionStatusPanel, [{
        key: 'handleChange',
        value: function handleChange() {
            if (this.needsUpdate == null) {
                this.needsUpdate = requestAnimationFrame(this.update.bind(this));
            }
        }
    }, {
        key: 'handleCoordinateChange',
        value: function handleCoordinateChange() {
            var positionElements = this.positionElements;
            var position = this.viewer.navigationState.pose.position;
            var voxelPosition = this.tempPosition;
            if (!position.voxelCoordinatesValid) {
                return;
            }
            position.getVoxelCoordinates(voxelPosition);
            for (var i = 0; i < 3; ++i) {
                var value = parseFloat(positionElements[i].value);
                if (!Number.isNaN(value)) {
                    voxelPosition[i] = value;
                }
            }
            position.setVoxelCoordinates(voxelPosition);
        }
    }, {
        key: 'update',
        value: function update() {
            this.needsUpdate = null;
            var _viewer = this.viewer;
            var navigationState = _viewer.navigationState;
            var mouseState = _viewer.mouseState;

            var voxelPosition = this.tempPosition;
            var position = navigationState.pose.position;
            // console.log("updating position view", this.navigationState.position.voxelCoordinatesValid);
            if (position.getVoxelCoordinates(voxelPosition)) {
                // console.log("got new position: " + voxelPosition);
                var positionElements = this.positionElements;
                for (var i = 0; i < 3; ++i) {
                    var value = voxelPosition[i];
                    positionElements[i].value = '' + Math.floor(value);
                }
            }
            var voxelSize = position.voxelSize;
            {
                var text = '';
                if (mouseState.active) {
                    voxelSize.voxelFromSpatial(voxelPosition, mouseState.position);
                    var p = voxelPosition;
                    if (ROUND_POSITIONS) {
                        text = `x ${ Math.round(p[0]) }  y ${ Math.round(p[1]) }  z ${ Math.round(p[2]) }`;
                    } else {
                        text = `x ${ p[0].toFixed(2) }  y ${ p[1].toFixed(2) }  z ${ p[2].toFixed(2) }`;
                    }
                }
                this.mouseElement.textContent = text;
            }
        }
    }, {
        key: 'disposed',
        value: function disposed() {
            for (var x of this.positionElements) {
                this.element.removeChild(x);
            }
            this.positionElements = undefined;
            this.element = undefined;
            _get(Object.getPrototypeOf(PositionStatusPanel.prototype), 'disposed', this).call(this);
        }
    }]);

    return PositionStatusPanel;
}(disposable_1.RefCounted);

exports.PositionStatusPanel = PositionStatusPanel;
;

/***/ },
/* 153 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
// Facility for storing global state in the url hash.

var json_1 = __webpack_require__(8);
// Maps keys to objects.
var trackedKeys = new Map();
// Maps objects to keys.
var trackedObjects = new Map();
var currentHashState = {};
var updatingObject = null;
var updatedObjects = new Set();
var lastHash = null;
var pendingUpdate = null;
var UPDATE_DELAY = 500;
function updateTrackedObjectsFromHash() {
    // console.log("updateTrackedObjectsFromHash called");
    try {
        var s = location.href.replace(/^[^#]+/, '');
        // console.log(`hash str: ${s}`);
        if (s === '' || s === '#' || s === '#!') {
            s = '#!{}';
        }
        if (s.startsWith('#!+')) {
            s = s.slice(3);
            // Firefox always %-encodes the URL even if it is not typed that way.
            s = decodeURI(s);
            var state = json_1.urlSafeParse(s);
            if (typeof state === 'object') {
                updateTrackedObjects(state);
            }
        } else if (s.startsWith('#!')) {
            s = s.slice(2);
            // Firefox always %-encodes the URL even if it is not typed that way.
            s = decodeURI(s);
            if (s === lastHash) {
                // We caused this update.
                return;
            }
            lastHash = s;
            resetTrackedObjects();
            var _state = json_1.urlSafeParse(s);
            if (typeof _state === 'object') {
                updateTrackedObjects(_state);
            }
        } else {
            lastHash = null;
        }
    } catch (e) {
        // Failed to parse hash, ignore.
        console.log(e);
    }
}
function resetTrackedObjects() {
    for (var object of trackedKeys.values()) {
        object.reset();
    }
}
function restoreObjectState(key, obj) {
    try {
        updatingObject = obj;
        obj.restoreState(currentHashState[key]);
    } catch (e) {
        console.log(`Failed to restore ${ key } state: ${ e }`);
    } finally {
        updatingObject = null;
    }
}
function updateTrackedObjects(newState) {
    currentHashState = newState;
    for (var key of Object.keys(currentHashState)) {
        var obj = trackedKeys.get(key);
        if (obj !== undefined) {
            restoreObjectState(key, obj);
        }
    }
}
function scheduleUpdate() {
    // Wait another UPDATE_DELAY ms before updating hash.
    if (pendingUpdate != null) {
        clearTimeout(pendingUpdate);
    }
    pendingUpdate = setTimeout(updateHash, UPDATE_DELAY);
}
function delayHashUpdate() {
    if (pendingUpdate != null) {
        scheduleUpdate();
    }
}
exports.delayHashUpdate = delayHashUpdate;
function updateHash() {
    pendingUpdate = null;
    // console.log(`updateHash at ${Date.now()}`);
    var updated = false;
    for (var obj of updatedObjects) {
        var key = trackedObjects.get(obj);
        if (key === undefined) {
            if (currentHashState.hasOwnProperty(key)) {
                updated = true;
            }
            // Object may have been unregistered after update event.
            continue;
        }
        updated = true;
        currentHashState[key] = obj.toJSON();
    }
    updatedObjects.clear();
    if (updated) {
        var newHash = json_1.urlSafeStringify(currentHashState);
        if (newHash !== lastHash) {
            lastHash = newHash;
            // console.log(`replaceState at ${Date.now()}`);
            if (lastHash === '{}') {
                history.replaceState(null, undefined, '#');
            } else {
                history.replaceState(null, undefined, '#!' + lastHash);
            }
        }
    }
}
addEventListener('hashchange', updateTrackedObjectsFromHash);
// Called with this == the object.
function handleObjectUpdate() {
    var obj = this;
    if (updatingObject === obj) {
        // We caused this event, so ignore it.
        return;
    }
    updatedObjects.add(obj);
    scheduleUpdate();
}
function registerTrackable(key, obj) {
    if (trackedKeys.has(key)) {
        throw new Error(`Key ${ JSON.stringify(key) } already registered.`);
    }
    if (trackedObjects.has(obj)) {
        throw new Error(`Object already registered.`);
    }
    trackedKeys.set(key, obj);
    trackedObjects.set(obj, key);
    if (currentHashState.hasOwnProperty(key)) {
        // console.log(`registering ${key} which has existing state`);
        obj.restoreState(currentHashState[key]);
    }
    obj.changed.add(handleObjectUpdate, obj);
    handleObjectUpdate.call(obj);
}
exports.registerTrackable = registerTrackable;
;
function unregisterTrackable(keyOrObject) {
    var obj = trackedKeys.get(keyOrObject);
    var key = void 0;
    if (obj !== undefined) {
        key = keyOrObject;
    } else {
        key = trackedObjects.get(keyOrObject);
        if (key === undefined) {
            throw new Error('Key or object not registered.');
        }
        obj = keyOrObject;
    }
    trackedKeys.delete(key);
    trackedObjects.delete(obj);
    obj.changed.remove(handleObjectUpdate, obj);
    handleObjectUpdate.call(obj);
}
exports.unregisterTrackable = unregisterTrackable;
;
// Initialize currentHashState.
updateTrackedObjectsFromHash();

/***/ },
/* 155 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }
/******/ ]);
//# sourceMappingURL=main.bundle.js.map